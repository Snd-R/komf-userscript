// ==UserScript==
// @name         Komf
// @namespace    https://github.com/Snd-R/komf-userscript
// @version      0.11.0
// @description  Komf userscript
// @author       snd-r
// @include      http://localhost:8080/*
// @include      http://localhost:5000/*
// @grant        none
// @run-at       document-start
// @updateURL    https://raw.githubusercontent.com/Snd-R/komf-userscript/main/komf.meta.js
// @downloadURL  https://github.com/Snd-R/komf-userscript/releases/latest/download/komf.user.js

// ==/UserScript==
(function(){"use strict";try{if(typeof document!="undefined"){var n=document.createElement("style");n.appendChild(document.createTextNode(`@charset "UTF-8";
/* * Normalizing -- forked from Normalize.css v8
 * */
*, *:before, *:after {
  box-sizing: inherit;
  -webkit-tap-highlight-color: transparent;
  -moz-tap-highlight-color: transparent;
}
html, body, #q-app {
  width: 100%;
  direction: ltr;
}
body.platform-ios.within-iframe, body.platform-ios.within-iframe #q-app {
  width: 100px;
  min-width: 100%;
}
html, body {
  margin: 0;
  box-sizing: border-box;
}
article,
aside,
details,
figcaption,
figure,
footer,
header,
main,
menu,
nav,
section,
summary {
  display: block;
}
/* * line 1: Remove the bottom border in Firefox 39-.
 * * lines 2,3: Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.
 * */
abbr[title] {
  border-bottom: none;
  text-decoration: underline;
  text-decoration: underline dotted;
}
/**
 * * Remove the border on images inside links in IE 10.
 * */
img {
  border-style: none;
}
/* * Hide the overflow in IE.
 * */
svg:not(:root) {
  overflow: hidden;
}
/* * line 1: Correct the inheritance and scaling of font size in all browsers.
 * * line 2: Correct the odd \`em\` font sizing in all browsers.
 * */
code, kbd, pre, samp {
  font-family: monospace, monospace;
  font-size: 1em;
}
/* * lines 1,2: Add the correct box sizing in Firefox.
 * * line 3: Show the overflow in Edge and IE.
 * */
hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}
/* * Change font properties to \`inherit\` in all browsers (opinionated).
 * */
button,
input,
optgroup,
select,
textarea {
  font: inherit;
  font-family: inherit;
  margin: 0;
}
/* * Restore the font weight unset by the previous rule.
 * */
optgroup {
  font-weight: bold;
}
/* * Show the overflow in IE.
 * *  input: Show the overflow in Edge.
 * *  select: Show the overflow in Edge, Firefox, and IE.
 * * Remove the inheritance of text transform in Edge, Firefox, and IE.
 * *  select: Remove the inheritance of text transform in Firefox.
 * */
button,
input,
select {
  overflow: visible;
  text-transform: none;
}
/* * Remove the inner border and padding in Firefox.
 * */
button::-moz-focus-inner, input::-moz-focus-inner {
  border: 0;
  padding: 0;
}
/* * Restore the focus styles unset by the previous rule.
 * */
button:-moz-focusring, input:-moz-focusring {
  outline: 1px dotted ButtonText;
}
/**
 * * Correct the padding in Firefox.
 * */
fieldset {
  padding: 0.35em 0.75em 0.625em;
}
/**
 * * lines 1,3,4,6: Correct the text wrapping in Edge and IE.
 * * line 2: Correct the color inheritance from \`fieldset\` elements in IE.
 * * line 5: Remove the padding so developers are not caught out when they zero out
 * *    \`fieldset\` elements in all browsers.
 * */
legend {
  box-sizing: border-box;
  color: inherit;
  display: table;
  max-width: 100%;
  padding: 0;
  white-space: normal;
}
/**
 * * Add the correct vertical alignment in Chrome, Firefox, and Opera.
 * */
progress {
  vertical-align: baseline;
}
/* * Remove the default vertical scrollbar in IE.
 * */
textarea {
  overflow: auto;
}
/* * Remove the inner padding and cancel buttons in Chrome on OS X and
 * * Safari on OS X.
 * */
input[type=search]::-webkit-search-cancel-button,
input[type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
}
.q-icon {
  line-height: 1;
  width: 1em;
  height: 1em;
  flex-shrink: 0;
  letter-spacing: normal;
  text-transform: none;
  white-space: nowrap;
  word-wrap: normal;
  direction: ltr;
  text-align: center;
  position: relative;
  box-sizing: content-box;
  fill: currentColor;
}
.q-icon:before, .q-icon:after {
  width: 100%;
  height: 100%;
  display: flex !important;
  align-items: center;
  justify-content: center;
}
.q-icon > svg,
.q-icon > img {
  width: 100%;
  height: 100%;
}
.q-icon,
.material-icons,
.material-icons-outlined,
.material-icons-round,
.material-icons-sharp,
.material-symbols-outlined,
.material-symbols-rounded,
.material-symbols-sharp {
  user-select: none;
  cursor: inherit;
  font-size: inherit;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  vertical-align: middle;
}
/* Composables */
.q-panel {
  height: 100%;
  width: 100%;
}
.q-panel > div {
  height: 100%;
  width: 100%;
}
.q-panel-parent {
  overflow: hidden;
  position: relative;
}
/* Components */
.q-loading-bar {
  position: fixed;
  z-index: 9998;
  transition: transform 0.5s cubic-bezier(0, 0, 0.2, 1), opacity 0.5s;
  background: #f44336;
}
.q-loading-bar--top {
  left: 0 /* rtl:ignore */;
  right: 0 /* rtl:ignore */;
  top: 0;
  width: 100%;
}
.q-loading-bar--bottom {
  left: 0 /* rtl:ignore */;
  right: 0 /* rtl:ignore */;
  bottom: 0;
  width: 100%;
}
.q-loading-bar--right {
  top: 0;
  bottom: 0;
  right: 0;
  height: 100%;
}
.q-loading-bar--left {
  top: 0;
  bottom: 0;
  left: 0;
  height: 100%;
}
.q-avatar {
  position: relative;
  vertical-align: middle;
  display: inline-block;
  border-radius: 50%;
  font-size: 48px;
  height: 1em;
  width: 1em;
}
.q-avatar__content {
  font-size: 0.5em;
  line-height: 0.5em;
}
.q-avatar__content, .q-avatar img:not(.q-icon):not(.q-img__image) {
  border-radius: inherit;
  height: inherit;
  width: inherit;
}
.q-avatar--square {
  border-radius: 0;
}
.q-badge {
  background-color: var(--q-primary);
  color: #fff;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 12px;
  line-height: 12px;
  min-height: 12px;
  font-weight: normal;
  vertical-align: baseline;
}
.q-badge--single-line {
  white-space: nowrap;
}
.q-badge--multi-line {
  word-break: break-all;
  word-wrap: break-word;
}
.q-badge--floating {
  position: absolute;
  top: -4px;
  right: -3px;
  cursor: inherit;
}
.q-badge--transparent {
  opacity: 0.8;
}
.q-badge--outline {
  background-color: transparent;
  border: 1px solid currentColor;
}
.q-badge--rounded {
  border-radius: 1em;
}
.q-banner {
  min-height: 54px;
  padding: 8px 16px;
  background: #fff;
}
.q-banner--top-padding {
  padding-top: 14px;
}
.q-banner__avatar {
  min-width: 1px !important;
}
.q-banner__avatar > .q-avatar {
  font-size: 46px;
}
.q-banner__avatar > .q-icon {
  font-size: 40px;
}
.q-banner__avatar:not(:empty) + .q-banner__content {
  padding-left: 16px;
}
.q-banner__actions.col-auto {
  padding-left: 16px;
}
.q-banner__actions.col-all .q-btn-item {
  margin: 4px 0 0 4px;
}
.q-banner--dense {
  min-height: 32px;
  padding: 8px;
}
.q-banner--dense.q-banner--top-padding {
  padding-top: 12px;
}
.q-banner--dense .q-banner__avatar > .q-avatar, .q-banner--dense .q-banner__avatar > .q-icon {
  font-size: 28px;
}
.q-banner--dense .q-banner__avatar:not(:empty) + .q-banner__content {
  padding-left: 8px;
}
.q-banner--dense .q-banner__actions.col-auto {
  padding-left: 8px;
}
.q-bar {
  background: rgba(0, 0, 0, 0.2);
}
.q-bar > .q-icon {
  margin-left: 2px;
}
.q-bar > div, .q-bar > div + .q-icon {
  margin-left: 8px;
}
.q-bar > .q-btn {
  margin-left: 2px;
}
.q-bar > .q-icon:first-child, .q-bar > .q-btn:first-child, .q-bar > div:first-child {
  margin-left: 0;
}
.q-bar--standard {
  padding: 0 12px;
  height: 32px;
  font-size: 18px;
}
.q-bar--standard > div {
  font-size: 16px;
}
.q-bar--standard .q-btn {
  font-size: 11px;
}
.q-bar--dense {
  padding: 0 8px;
  height: 24px;
  font-size: 14px;
}
.q-bar--dense .q-btn {
  font-size: 8px;
}
.q-bar--dark {
  background: rgba(255, 255, 255, 0.15);
}
.q-breadcrumbs__el {
  color: inherit;
}
.q-breadcrumbs__el-icon {
  font-size: 125%;
}
.q-breadcrumbs__el-icon--with-label {
  margin-right: 8px;
}
[dir=rtl] .q-breadcrumbs__separator .q-icon {
  transform: scaleX(-1) /* rtl:ignore */;
}
.q-btn {
  display: inline-flex;
  flex-direction: column;
  align-items: stretch;
  position: relative;
  outline: 0;
  border: 0;
  vertical-align: middle;
  font-size: 14px;
  line-height: 1.715em;
  text-decoration: none;
  color: inherit;
  background: transparent;
  font-weight: 500;
  text-transform: uppercase;
  text-align: center;
  width: auto;
  height: auto;
  cursor: default;
  padding: 4px 16px;
  min-height: 2.572em;
}
.q-btn .q-icon, .q-btn .q-spinner {
  font-size: 1.715em;
}
.q-btn.disabled {
  opacity: 0.7 !important;
}
.q-btn:before {
  content: "";
  display: block;
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  border-radius: inherit;
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
}
.q-btn--actionable {
  cursor: pointer;
}
.q-btn--actionable.q-btn--standard:before {
  transition: box-shadow 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);
}
.q-btn--actionable.q-btn--standard:active:before, .q-btn--actionable.q-btn--standard.q-btn--active:before {
  box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 5px 8px rgba(0, 0, 0, 0.14), 0 1px 14px rgba(0, 0, 0, 0.12);
}
.q-btn--no-uppercase {
  text-transform: none;
}
.q-btn--rectangle {
  border-radius: 3px;
}
.q-btn--outline {
  background: transparent !important;
}
.q-btn--outline:before {
  border: 1px solid currentColor;
}
.q-btn--push {
  border-radius: 7px;
}
.q-btn--push:before {
  border-bottom: 3px solid rgba(0, 0, 0, 0.15);
}
.q-btn--push.q-btn--actionable {
  transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);
}
.q-btn--push.q-btn--actionable:before {
  transition: border-width 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);
}
.q-btn--push.q-btn--actionable:active, .q-btn--push.q-btn--actionable.q-btn--active {
  transform: translateY(2px);
}
.q-btn--push.q-btn--actionable:active:before, .q-btn--push.q-btn--actionable.q-btn--active:before {
  border-bottom-width: 0;
}
.q-btn--rounded {
  border-radius: 28px;
}
.q-btn--round {
  border-radius: 50%;
  padding: 0;
  min-width: 3em;
  min-height: 3em;
}
.q-btn--square {
  border-radius: 0;
}
.q-btn--flat:before, .q-btn--outline:before, .q-btn--unelevated:before {
  box-shadow: none;
}
.q-btn--dense {
  padding: 0.285em;
  min-height: 2em;
}
.q-btn--dense.q-btn--round {
  padding: 0;
  min-height: 2.4em;
  min-width: 2.4em;
}
.q-btn--dense .on-left {
  margin-right: 6px;
}
.q-btn--dense .on-right {
  margin-left: 6px;
}
.q-btn--fab .q-icon, .q-btn--fab-mini .q-icon {
  font-size: 24px;
}
.q-btn--fab {
  padding: 16px;
  min-height: 56px;
  min-width: 56px;
}
.q-btn--fab .q-icon {
  margin: auto;
}
.q-btn--fab-mini {
  padding: 8px;
  min-height: 40px;
  min-width: 40px;
}
.q-btn__content {
  transition: opacity 0.3s;
  z-index: 0;
}
.q-btn__content--hidden {
  opacity: 0;
  pointer-events: none;
}
.q-btn__progress {
  border-radius: inherit;
  z-index: 0;
}
.q-btn__progress-indicator {
  z-index: -1;
  transform: translateX(-100%);
  background: rgba(255, 255, 255, 0.25);
}
.q-btn__progress--dark .q-btn__progress-indicator {
  background: rgba(0, 0, 0, 0.2);
}
.q-btn--flat .q-btn__progress-indicator, .q-btn--outline .q-btn__progress-indicator {
  opacity: 0.2;
  background: currentColor;
}
.q-btn-dropdown--split .q-btn-dropdown__arrow-container {
  padding: 0 4px;
}
.q-btn-dropdown--split .q-btn-dropdown__arrow-container.q-btn--outline {
  border-left: 1px solid currentColor;
}
.q-btn-dropdown--split .q-btn-dropdown__arrow-container:not(.q-btn--outline) {
  border-left: 1px solid rgba(255, 255, 255, 0.3);
}
.q-btn-dropdown--simple * + .q-btn-dropdown__arrow {
  margin-left: 8px;
}
.q-btn-dropdown__arrow {
  transition: transform 0.28s;
}
.q-btn-dropdown--current {
  flex-grow: 1;
}
.q-btn-group {
  border-radius: 3px;
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
  vertical-align: middle;
}
.q-btn-group > .q-btn-item {
  border-radius: inherit;
  align-self: stretch;
}
.q-btn-group > .q-btn-item:before {
  box-shadow: none;
}
.q-btn-group > .q-btn-item .q-badge--floating {
  right: 0;
}
.q-btn-group > .q-btn-group {
  box-shadow: none;
}
.q-btn-group > .q-btn-group:first-child > .q-btn:first-child {
  border-top-left-radius: inherit;
  border-bottom-left-radius: inherit;
}
.q-btn-group > .q-btn-group:last-child > .q-btn:last-child {
  border-top-right-radius: inherit;
  border-bottom-right-radius: inherit;
}
.q-btn-group > .q-btn-group:not(:first-child) > .q-btn:first-child:before {
  border-left: 0;
}
.q-btn-group > .q-btn-group:not(:last-child) > .q-btn:last-child:before {
  border-right: 0;
}
.q-btn-group > .q-btn-item:not(:last-child) {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.q-btn-group > .q-btn-item:not(:first-child) {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.q-btn-group > .q-btn-item.q-btn--standard:before {
  z-index: -1;
}
.q-btn-group--push {
  border-radius: 7px;
}
.q-btn-group--push > .q-btn--push.q-btn--actionable {
  transform: none;
}
.q-btn-group--push > .q-btn--push.q-btn--actionable .q-btn__content {
  transition: margin-top 0.3s cubic-bezier(0.25, 0.8, 0.5, 1), margin-bottom 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);
}
.q-btn-group--push > .q-btn--push.q-btn--actionable:active .q-btn__content, .q-btn-group--push > .q-btn--push.q-btn--actionable.q-btn--active .q-btn__content {
  margin-top: 2px;
  margin-bottom: -2px;
}
.q-btn-group--rounded {
  border-radius: 28px;
}
.q-btn-group--square {
  border-radius: 0;
}
.q-btn-group--flat, .q-btn-group--outline, .q-btn-group--unelevated {
  box-shadow: none;
}
.q-btn-group--outline > .q-separator {
  display: none;
}
.q-btn-group--outline > .q-btn-item + .q-btn-item:before {
  border-left: 0;
}
.q-btn-group--outline > .q-btn-item:not(:last-child):before {
  border-right: 0;
}
.q-btn-group--stretch {
  align-self: stretch;
  border-radius: 0;
}
.q-btn-group--glossy > .q-btn-item {
  background-image: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.12) 51%, rgba(0, 0, 0, 0.04)) !important;
}
.q-btn-group--spread > .q-btn-group {
  display: flex !important;
}
.q-btn-group--spread > .q-btn-item, .q-btn-group--spread > .q-btn-group > .q-btn-item:not(.q-btn-dropdown__arrow-container) {
  width: auto;
  min-width: 0;
  max-width: 100%;
  flex: 10000 1 0%;
}
.q-btn-toggle {
  position: relative;
}
.q-card {
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  vertical-align: top;
  background: #fff;
  position: relative;
}
.q-card > div:first-child,
.q-card > img:first-child {
  border-top: 0;
  border-top-left-radius: inherit;
  border-top-right-radius: inherit;
}
.q-card > div:last-child,
.q-card > img:last-child {
  border-bottom: 0;
  border-bottom-left-radius: inherit;
  border-bottom-right-radius: inherit;
}
.q-card > div:not(:first-child),
.q-card > img:not(:first-child) {
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}
.q-card > div:not(:last-child),
.q-card > img:not(:last-child) {
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}
.q-card > div {
  border-left: 0;
  border-right: 0;
  box-shadow: none;
}
.q-card--bordered {
  border: 1px solid rgba(0, 0, 0, 0.12);
}
.q-card--dark {
  border-color: rgba(255, 255, 255, 0.28);
}
.q-card__section {
  position: relative;
}
.q-card__section--vert {
  padding: 16px;
}
.q-card__section--horiz > div:first-child,
.q-card__section--horiz > img:first-child {
  border-top-left-radius: inherit;
  border-bottom-left-radius: inherit;
}
.q-card__section--horiz > div:last-child,
.q-card__section--horiz > img:last-child {
  border-top-right-radius: inherit;
  border-bottom-right-radius: inherit;
}
.q-card__section--horiz > div:not(:first-child),
.q-card__section--horiz > img:not(:first-child) {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.q-card__section--horiz > div:not(:last-child),
.q-card__section--horiz > img:not(:last-child) {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.q-card__section--horiz > div {
  border-top: 0;
  border-bottom: 0;
  box-shadow: none;
}
.q-card__actions {
  padding: 8px;
  align-items: center;
}
.q-card__actions .q-btn {
  padding: 0 8px;
}
.q-card__actions--horiz > .q-btn-item + .q-btn-item,
.q-card__actions--horiz > .q-btn-group + .q-btn-item,
.q-card__actions--horiz > .q-btn-item + .q-btn-group {
  margin-left: 8px;
}
.q-card__actions--vert > .q-btn-item.q-btn--round {
  align-self: center;
}
.q-card__actions--vert > .q-btn-item + .q-btn-item,
.q-card__actions--vert > .q-btn-group + .q-btn-item,
.q-card__actions--vert > .q-btn-item + .q-btn-group {
  margin-top: 4px;
}
.q-card__actions--vert > .q-btn-group > .q-btn-item {
  flex-grow: 1;
}
.q-card > img {
  display: block;
  width: 100%;
  max-width: 100%;
  border: 0;
}
.q-carousel {
  background-color: #fff;
  height: 400px;
}
.q-carousel__slide {
  min-height: 100%;
  background-size: cover;
  background-position: 50%;
}
.q-carousel__slide, .q-carousel .q-carousel--padding {
  padding: 16px;
}
.q-carousel__slides-container {
  height: 100%;
}
.q-carousel__control {
  color: #fff;
}
.q-carousel__arrow {
  pointer-events: none;
}
.q-carousel__arrow .q-icon {
  font-size: 28px;
}
.q-carousel__arrow .q-btn {
  pointer-events: all;
}
.q-carousel__prev-arrow--horizontal, .q-carousel__next-arrow--horizontal {
  top: 16px;
  bottom: 16px;
}
.q-carousel__prev-arrow--horizontal {
  left: 16px;
}
.q-carousel__next-arrow--horizontal {
  right: 16px;
}
.q-carousel__prev-arrow--vertical, .q-carousel__next-arrow--vertical {
  left: 16px;
  right: 16px;
}
.q-carousel__prev-arrow--vertical {
  top: 16px;
}
.q-carousel__next-arrow--vertical {
  bottom: 16px;
}
.q-carousel__navigation--top, .q-carousel__navigation--bottom {
  left: 16px;
  right: 16px;
  overflow-x: auto;
  overflow-y: hidden;
}
.q-carousel__navigation--top {
  top: 16px;
}
.q-carousel__navigation--bottom {
  bottom: 16px;
}
.q-carousel__navigation--left, .q-carousel__navigation--right {
  top: 16px;
  bottom: 16px;
  overflow-x: hidden;
  overflow-y: auto;
}
.q-carousel__navigation--left > .q-carousel__navigation-inner, .q-carousel__navigation--right > .q-carousel__navigation-inner {
  flex-direction: column;
}
.q-carousel__navigation--left {
  left: 16px;
}
.q-carousel__navigation--right {
  right: 16px;
}
.q-carousel__navigation-inner {
  flex: 1 1 auto;
}
.q-carousel__navigation .q-btn {
  margin: 6px 4px;
  padding: 5px;
}
.q-carousel__navigation-icon--inactive {
  opacity: 0.7;
}
.q-carousel .q-carousel__thumbnail {
  margin: 2px;
  height: 50px;
  width: auto;
  display: inline-block;
  cursor: pointer;
  border: 1px solid transparent;
  border-radius: 4px;
  vertical-align: middle;
  opacity: 0.7;
  transition: opacity 0.3s;
}
.q-carousel .q-carousel__thumbnail:hover,
.q-carousel .q-carousel__thumbnail--active {
  opacity: 1;
}
.q-carousel .q-carousel__thumbnail--active {
  border-color: currentColor;
  cursor: default;
}
.q-carousel--navigation-top.q-carousel--with-padding .q-carousel__slide, .q-carousel--navigation-top .q-carousel--padding, .q-carousel--arrows-vertical.q-carousel--with-padding .q-carousel__slide, .q-carousel--arrows-vertical .q-carousel--padding {
  padding-top: 60px;
}
.q-carousel--navigation-bottom.q-carousel--with-padding .q-carousel__slide, .q-carousel--navigation-bottom .q-carousel--padding, .q-carousel--arrows-vertical.q-carousel--with-padding .q-carousel__slide, .q-carousel--arrows-vertical .q-carousel--padding {
  padding-bottom: 60px;
}
.q-carousel--navigation-left.q-carousel--with-padding .q-carousel__slide, .q-carousel--navigation-left .q-carousel--padding, .q-carousel--arrows-horizontal.q-carousel--with-padding .q-carousel__slide, .q-carousel--arrows-horizontal .q-carousel--padding {
  padding-left: 60px;
}
.q-carousel--navigation-right.q-carousel--with-padding .q-carousel__slide, .q-carousel--navigation-right .q-carousel--padding, .q-carousel--arrows-horizontal.q-carousel--with-padding .q-carousel__slide, .q-carousel--arrows-horizontal .q-carousel--padding {
  padding-right: 60px;
}
.q-carousel.fullscreen {
  height: 100%;
}
.q-message-name, .q-message-stamp, .q-message-label {
  font-size: small;
}
.q-message-label {
  margin: 24px 0;
  text-align: center;
}
.q-message-stamp {
  color: inherit;
  margin-top: 4px;
  opacity: 0.6;
  display: none;
}
.q-message-avatar {
  border-radius: 50%;
  width: 48px;
  height: 48px;
  min-width: 48px;
}
.q-message {
  margin-bottom: 8px;
}
.q-message:first-child .q-message-label {
  margin-top: 0;
}
.q-message-avatar--received {
  margin-right: 8px;
}
.q-message-text--received {
  color: #81c784;
  border-radius: 4px 4px 4px 0;
}
.q-message-text--received:last-child:before {
  right: 100%;
  border-right: 0 solid transparent;
  border-left: 8px solid transparent;
  border-bottom: 8px solid currentColor;
}
.q-message-text-content--received {
  color: #000;
}
.q-message-name--sent {
  text-align: right;
}
.q-message-avatar--sent {
  margin-left: 8px;
}
.q-message-container--sent {
  flex-direction: row-reverse;
}
.q-message-text--sent {
  color: #e0e0e0;
  border-radius: 4px 4px 0 4px;
}
.q-message-text--sent:last-child:before {
  left: 100%;
  border-left: 0 solid transparent;
  border-right: 8px solid transparent;
  border-bottom: 8px solid currentColor;
}
.q-message-text-content--sent {
  color: #000;
}
.q-message-text {
  background: currentColor;
  padding: 8px;
  line-height: 1.2;
  word-break: break-word;
  position: relative;
}
.q-message-text + .q-message-text {
  margin-top: 3px;
}
.q-message-text:last-child {
  min-height: 48px;
}
.q-message-text:last-child .q-message-stamp {
  display: block;
}
.q-message-text:last-child:before {
  content: "";
  position: absolute;
  bottom: 0;
  width: 0;
  height: 0;
}
.q-checkbox {
  vertical-align: middle;
}
.q-checkbox__native {
  width: 1px;
  height: 1px;
}
.q-checkbox__bg, .q-checkbox__icon-container {
  user-select: none;
}
.q-checkbox__bg {
  top: 25%;
  left: 25%;
  width: 50%;
  height: 50%;
  border: 2px solid currentColor;
  border-radius: 2px;
  transition: background 0.22s cubic-bezier(0, 0, 0.2, 1) 0ms;
  -webkit-print-color-adjust: exact;
}
.q-checkbox__icon {
  color: currentColor;
  font-size: 0.5em;
}
.q-checkbox__svg {
  color: #fff;
}
.q-checkbox__truthy {
  stroke: currentColor;
  stroke-width: 3.12px;
  stroke-dashoffset: 29.78334;
  stroke-dasharray: 29.78334;
}
.q-checkbox__indet {
  fill: currentColor;
  transform-origin: 50% 50%;
  transform: rotate(-280deg) scale(0);
}
.q-checkbox__inner {
  font-size: 40px;
  width: 1em;
  min-width: 1em;
  height: 1em;
  outline: 0;
  border-radius: 50%;
  color: rgba(0, 0, 0, 0.54);
}
.q-checkbox__inner--truthy, .q-checkbox__inner--indet {
  color: var(--q-primary);
}
.q-checkbox__inner--truthy .q-checkbox__bg, .q-checkbox__inner--indet .q-checkbox__bg {
  background: currentColor;
}
.q-checkbox__inner--truthy path {
  stroke-dashoffset: 0;
  transition: stroke-dashoffset 0.18s cubic-bezier(0.4, 0, 0.6, 1) 0ms;
}
.q-checkbox__inner--indet .q-checkbox__indet {
  transform: rotate(0) scale(1);
  transition: transform 0.22s cubic-bezier(0, 0, 0.2, 1) 0ms;
}
.q-checkbox.disabled {
  opacity: 0.75 !important;
}
.q-checkbox--dark .q-checkbox__inner {
  color: rgba(255, 255, 255, 0.7);
}
.q-checkbox--dark .q-checkbox__inner:before {
  opacity: 0.32 !important;
}
.q-checkbox--dark .q-checkbox__inner--truthy, .q-checkbox--dark .q-checkbox__inner--indet {
  color: var(--q-primary);
}
.q-checkbox--dense .q-checkbox__inner {
  width: 0.5em;
  min-width: 0.5em;
  height: 0.5em;
}
.q-checkbox--dense .q-checkbox__bg {
  left: 5%;
  top: 5%;
  width: 90%;
  height: 90%;
}
.q-checkbox--dense .q-checkbox__label {
  padding-left: 0.5em;
}
.q-checkbox--dense.reverse .q-checkbox__label {
  padding-left: 0;
  padding-right: 0.5em;
}
body.desktop .q-checkbox:not(.disabled) .q-checkbox__inner:before {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  border-radius: 50%;
  background: currentColor;
  opacity: 0.12;
  transform: scale3d(0, 0, 1);
  transition: transform 0.22s cubic-bezier(0, 0, 0.2, 1);
}
body.desktop .q-checkbox:not(.disabled):focus .q-checkbox__inner:before, body.desktop .q-checkbox:not(.disabled):hover .q-checkbox__inner:before {
  transform: scale3d(1, 1, 1);
}
body.desktop .q-checkbox--dense:not(.disabled):focus .q-checkbox__inner:before, body.desktop .q-checkbox--dense:not(.disabled):hover .q-checkbox__inner:before {
  transform: scale3d(1.4, 1.4, 1);
}
.q-chip {
  vertical-align: middle;
  border-radius: 16px;
  outline: 0;
  position: relative;
  height: 2em;
  max-width: 100%;
  margin: 4px;
  background: #e0e0e0;
  color: rgba(0, 0, 0, 0.87);
  font-size: 14px;
  padding: 0.5em 0.9em;
}
.q-chip--colored .q-chip__icon, .q-chip--dark .q-chip__icon {
  color: inherit;
}
.q-chip--outline {
  background: transparent !important;
  border: 1px solid currentColor;
}
.q-chip .q-avatar {
  font-size: 2em;
  margin-left: -0.45em;
  margin-right: 0.2em;
  border-radius: 16px;
}
.q-chip--selected .q-avatar {
  display: none;
}
.q-chip__icon {
  color: rgba(0, 0, 0, 0.54);
  font-size: 1.5em;
  margin: -0.2em;
}
.q-chip__icon--left {
  margin-right: 0.2em;
}
.q-chip__icon--right {
  margin-left: 0.2em;
}
.q-chip__icon--remove {
  margin-left: 0.1em;
  margin-right: -0.5em;
  opacity: 0.6;
  outline: 0;
}
.q-chip__icon--remove:hover, .q-chip__icon--remove:focus {
  opacity: 1;
}
.q-chip__content {
  white-space: nowrap;
}
.q-chip--dense {
  border-radius: 12px;
  padding: 0 0.4em;
  height: 1.5em;
}
.q-chip--dense .q-avatar {
  font-size: 1.5em;
  margin-left: -0.27em;
  margin-right: 0.1em;
  border-radius: 12px;
}
.q-chip--dense .q-chip__icon {
  font-size: 1.25em;
}
.q-chip--dense .q-chip__icon--left {
  margin-right: 0.195em;
}
.q-chip--dense .q-chip__icon--remove {
  margin-right: -0.25em;
}
.q-chip--square {
  border-radius: 4px;
}
.q-chip--square .q-avatar {
  border-radius: 3px 0 0 3px;
}
body.desktop .q-chip--clickable:focus {
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2), 0 1px 1px rgba(0, 0, 0, 0.14), 0 2px 1px -1px rgba(0, 0, 0, 0.12);
}
.q-circular-progress {
  display: inline-block;
  position: relative;
  vertical-align: middle;
  width: 1em;
  height: 1em;
  line-height: 1;
}
.q-circular-progress.q-focusable {
  border-radius: 50%;
}
.q-circular-progress__svg {
  width: 100%;
  height: 100%;
}
.q-circular-progress__text {
  font-size: 0.25em;
}
.q-circular-progress--indeterminate .q-circular-progress__svg {
  transform-origin: 50% 50%;
  animation: q-spin 2s linear infinite /* rtl:ignore */;
}
.q-circular-progress--indeterminate .q-circular-progress__circle {
  stroke-dasharray: 1 400;
  stroke-dashoffset: 0;
  animation: q-circular-progress-circle 1.5s ease-in-out infinite /* rtl:ignore */;
}
@keyframes q-circular-progress-circle {
  0% {
    stroke-dasharray: 1, 400;
    stroke-dashoffset: 0;
  }
  50% {
    stroke-dasharray: 400, 400;
    stroke-dashoffset: -100;
  }
  100% {
    stroke-dasharray: 400, 400;
    stroke-dashoffset: -300;
  }
}
.q-color-picker {
  overflow: hidden;
  background: #fff;
  max-width: 350px;
  vertical-align: top;
  min-width: 180px;
  border-radius: 4px;
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
  /* Saturation Tab */
  /* Tune Tab */
  /* Palette Tab */
  /* Generic  */
}
.q-color-picker .q-tab {
  padding: 0 !important;
}
.q-color-picker--bordered {
  border: 1px solid rgba(0, 0, 0, 0.12);
}
.q-color-picker__header-tabs {
  height: 32px;
}
.q-color-picker__header-banner {
  height: 36px;
}
.q-color-picker__header input {
  line-height: 24px;
  border: 0;
}
.q-color-picker__header .q-tab {
  min-height: 32px !important;
  height: 32px !important;
}
.q-color-picker__header .q-tab--inactive {
  background: linear-gradient(to top, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 25%, rgba(0, 0, 0, 0.1));
}
.q-color-picker__error-icon {
  bottom: 2px;
  right: 2px;
  font-size: 24px;
  opacity: 0;
  transition: opacity 0.3s ease-in;
}
.q-color-picker__header-content {
  position: relative;
  background: #fff;
}
.q-color-picker__header-content--light {
  color: #000;
}
.q-color-picker__header-content--dark {
  color: #fff;
}
.q-color-picker__header-content--dark .q-tab--inactive:before {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background: rgba(255, 255, 255, 0.2);
}
.q-color-picker__header-banner {
  height: 36px;
}
.q-color-picker__header-bg {
  background: #fff;
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAH0lEQVQoU2NkYGAwZkAFZ5G5jPRRgOYEVDeB3EBjBQBOZwTVugIGyAAAAABJRU5ErkJggg==") !important;
}
.q-color-picker__footer {
  height: 36px;
}
.q-color-picker__footer .q-tab {
  min-height: 36px !important;
  height: 36px !important;
}
.q-color-picker__footer .q-tab--inactive {
  background: linear-gradient(to bottom, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 25%, rgba(0, 0, 0, 0.1));
}
.q-color-picker__spectrum {
  width: 100%;
  height: 100%;
}
.q-color-picker__spectrum-tab {
  padding: 0 !important;
}
.q-color-picker__spectrum-white {
  background: linear-gradient(to right, #fff, rgba(255, 255, 255, 0));
}
.q-color-picker__spectrum-black {
  background: linear-gradient(to top, #000, rgba(0, 0, 0, 0));
}
.q-color-picker__spectrum-circle {
  width: 10px;
  height: 10px;
  box-shadow: 0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0, 0, 0, 0.3), 0 0 1px 2px rgba(0, 0, 0, 0.4);
  border-radius: 50%;
  transform: translate(-5px, -5px);
}
.q-color-picker__hue .q-slider__track {
  background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%) !important;
  opacity: 1;
}
.q-color-picker__alpha .q-slider__track-container {
  padding-top: 0;
}
.q-color-picker__alpha .q-slider__track:before {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  border-radius: inherit;
  background: linear-gradient(90deg, rgba(255, 255, 255, 0), #757575);
}
.q-color-picker__sliders {
  padding: 0 16px;
}
.q-color-picker__sliders .q-slider__thumb {
  color: #424242;
}
.q-color-picker__sliders .q-slider__thumb path {
  stroke-width: 2px;
  fill: transparent;
}
.q-color-picker__sliders .q-slider--active path {
  stroke-width: 3px;
}
.q-color-picker__tune-tab .q-slider {
  margin-left: 18px;
  margin-right: 18px;
}
.q-color-picker__tune-tab input {
  font-size: 11px;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  width: 3.5em;
}
.q-color-picker__palette-tab {
  padding: 0 !important;
}
.q-color-picker__palette-rows--editable .q-color-picker__cube {
  cursor: pointer;
}
.q-color-picker__cube {
  padding-bottom: 10%;
  width: 10% !important;
}
.q-color-picker input {
  color: inherit;
  background: transparent;
  outline: 0;
  text-align: center;
}
.q-color-picker .q-tabs {
  overflow: hidden;
}
.q-color-picker .q-tab--active {
  box-shadow: 0 0 14px 3px rgba(0, 0, 0, 0.2);
}
.q-color-picker .q-tab--active .q-focus-helper {
  display: none;
}
.q-color-picker .q-tab__indicator {
  display: none;
}
.q-color-picker .q-tab-panels {
  background: inherit;
}
.q-color-picker--dark .q-color-picker__tune-tab input {
  border: 1px solid rgba(255, 255, 255, 0.3);
}
.q-color-picker--dark .q-slider__thumb {
  color: #fafafa;
}
.q-date {
  display: inline-flex;
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  background: #fff;
  width: 290px;
  min-width: 290px;
  max-width: 100%;
}
.q-date--bordered {
  border: 1px solid rgba(0, 0, 0, 0.12);
}
.q-date__header {
  border-top-left-radius: inherit;
  color: #fff;
  background-color: var(--q-primary);
  padding: 16px;
}
.q-date__actions {
  padding: 0 16px 16px;
}
.q-date__content, .q-date__main {
  outline: 0;
}
.q-date__content .q-btn {
  font-weight: normal;
}
.q-date__header-link {
  opacity: 0.64;
  outline: 0;
  transition: opacity 0.3s ease-out;
}
.q-date__header-link--active, .q-date__header-link:hover, .q-date__header-link:focus {
  opacity: 1;
}
.q-date__header-subtitle {
  font-size: 14px;
  line-height: 1.75;
  letter-spacing: 0.00938em;
}
.q-date__header-title-label {
  font-size: 24px;
  line-height: 1.2;
  letter-spacing: 0.00735em;
}
.q-date__view {
  height: 100%;
  width: 100%;
  min-height: 290px;
  padding: 16px;
}
.q-date__navigation {
  height: 12.5%;
}
.q-date__navigation > div:first-child {
  width: 8%;
  min-width: 24px;
  justify-content: flex-end;
}
.q-date__navigation > div:last-child {
  width: 8%;
  min-width: 24px;
  justify-content: flex-start;
}
.q-date__calendar-weekdays {
  height: 12.5%;
}
.q-date__calendar-weekdays > div {
  opacity: 0.38;
  font-size: 12px;
}
.q-date__calendar-item {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  vertical-align: middle;
  width: 14.285% !important;
  height: 12.5% !important;
  position: relative;
  padding: 1px;
}
.q-date__calendar-item:after {
  content: "";
  position: absolute;
  pointer-events: none;
  top: 1px;
  right: 0;
  bottom: 1px;
  left: 0;
  border-style: dashed;
  border-color: transparent;
  border-width: 1px;
}
.q-date__calendar-item > div, .q-date__calendar-item button {
  width: 30px;
  height: 30px;
  border-radius: 50%;
}
.q-date__calendar-item > div {
  line-height: 30px;
  text-align: center;
}
.q-date__calendar-item > button {
  line-height: 22px;
}
.q-date__calendar-item--out {
  opacity: 0.18;
}
.q-date__calendar-item--fill {
  visibility: hidden;
}
.q-date__range:before, .q-date__range-from:before, .q-date__range-to:before {
  content: "";
  background-color: currentColor;
  position: absolute;
  top: 1px;
  bottom: 1px;
  left: 0;
  right: 0;
  opacity: 0.3;
}
.q-date__range:nth-child(7n-6):before, .q-date__range-from:nth-child(7n-6):before, .q-date__range-to:nth-child(7n-6):before {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.q-date__range:nth-child(7n):before, .q-date__range-from:nth-child(7n):before, .q-date__range-to:nth-child(7n):before {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.q-date__range-from:before {
  left: 50%;
}
.q-date__range-to:before {
  right: 50%;
}
.q-date__edit-range:after {
  border-color: currentColor transparent;
}
.q-date__edit-range:nth-child(7n-6):after {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.q-date__edit-range:nth-child(7n):after {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.q-date__edit-range-from:after, .q-date__edit-range-from-to:after {
  left: 4px;
  border-left-color: currentColor;
  border-top-color: currentColor;
  border-bottom-color: currentColor;
  border-top-left-radius: 28px;
  border-bottom-left-radius: 28px;
}
.q-date__edit-range-to:after, .q-date__edit-range-from-to:after {
  right: 4px;
  border-right-color: currentColor;
  border-top-color: currentColor;
  border-bottom-color: currentColor;
  border-top-right-radius: 28px;
  border-bottom-right-radius: 28px;
}
.q-date__calendar-days-container {
  height: 75%;
  min-height: 192px;
}
.q-date__calendar-days > div {
  height: 16.66% !important;
}
.q-date__event {
  position: absolute;
  bottom: 2px;
  left: 50%;
  height: 5px;
  width: 8px;
  border-radius: 5px;
  background-color: var(--q-secondary);
  transform: translate3d(-50%, 0, 0);
}
.q-date__today {
  box-shadow: 0 0 1px 0 currentColor;
}
.q-date__years-content {
  padding: 0 8px;
}
.q-date__years-item, .q-date__months-item {
  flex: 0 0 33.3333%;
}
.q-date.disabled .q-date__header, .q-date.disabled .q-date__content, .q-date--readonly .q-date__header, .q-date--readonly .q-date__content {
  pointer-events: none;
}
.q-date--readonly .q-date__navigation {
  display: none;
}
.q-date--portrait {
  flex-direction: column;
}
.q-date--portrait-standard .q-date__content {
  height: calc(100% - 86px);
}
.q-date--portrait-standard .q-date__header {
  border-top-right-radius: inherit;
  height: 86px;
}
.q-date--portrait-standard .q-date__header-title {
  align-items: center;
  height: 30px;
}
.q-date--portrait-minimal .q-date__content {
  height: 100%;
}
.q-date--landscape {
  flex-direction: row;
  align-items: stretch;
  min-width: 420px;
}
.q-date--landscape > div {
  display: flex;
  flex-direction: column;
}
.q-date--landscape .q-date__content {
  height: 100%;
}
.q-date--landscape-standard {
  min-width: 420px;
}
.q-date--landscape-standard .q-date__header {
  border-bottom-left-radius: inherit;
  min-width: 110px;
  width: 110px;
}
.q-date--landscape-standard .q-date__header-title {
  flex-direction: column;
}
.q-date--landscape-standard .q-date__header-today {
  margin-top: 12px;
  margin-left: -8px;
}
.q-date--landscape-minimal {
  width: 310px;
}
.q-date--dark {
  border-color: rgba(255, 255, 255, 0.28);
}
.q-dialog__title {
  font-size: 1.25rem;
  font-weight: 500;
  line-height: 2rem;
  letter-spacing: 0.0125em;
}
.q-dialog__progress {
  font-size: 4rem;
}
.q-dialog__inner {
  outline: 0;
}
.q-dialog__inner > div {
  pointer-events: all;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  will-change: scroll-position;
  border-radius: 4px;
  box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px rgba(0, 0, 0, 0.14), 0 1px 10px rgba(0, 0, 0, 0.12);
}
.q-dialog__inner--square > div {
  border-radius: 0 !important;
}
.q-dialog__inner > .q-card > .q-card__actions .q-btn--rectangle {
  min-width: 64px;
}
.q-dialog__inner--minimized {
  padding: 24px;
}
.q-dialog__inner--minimized > div {
  max-height: calc(100vh - 48px);
}
.q-dialog__inner--maximized > div {
  height: 100%;
  width: 100%;
  max-height: 100vh;
  max-width: 100vw;
  border-radius: 0 !important;
  top: 0 !important;
  left: 0 !important;
}
.q-dialog__inner--top, .q-dialog__inner--bottom {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}
.q-dialog__inner--right, .q-dialog__inner--left {
  padding-right: 0 !important;
  padding-left: 0 !important;
}
.q-dialog__inner--left:not(.q-dialog__inner--animating) > div, .q-dialog__inner--top:not(.q-dialog__inner--animating) > div {
  border-top-left-radius: 0;
}
.q-dialog__inner--right:not(.q-dialog__inner--animating) > div, .q-dialog__inner--top:not(.q-dialog__inner--animating) > div {
  border-top-right-radius: 0;
}
.q-dialog__inner--left:not(.q-dialog__inner--animating) > div, .q-dialog__inner--bottom:not(.q-dialog__inner--animating) > div {
  border-bottom-left-radius: 0;
}
.q-dialog__inner--right:not(.q-dialog__inner--animating) > div, .q-dialog__inner--bottom:not(.q-dialog__inner--animating) > div {
  border-bottom-right-radius: 0;
}
.q-dialog__inner--fullwidth > div {
  width: 100% !important;
  max-width: 100% !important;
}
.q-dialog__inner--fullheight > div {
  height: 100% !important;
  max-height: 100% !important;
}
.q-dialog__backdrop {
  z-index: -1;
  pointer-events: all;
  outline: 0;
  background: rgba(0, 0, 0, 0.4);
}
body.platform-ios .q-dialog__inner--minimized > div, body.platform-android:not(.native-mobile) .q-dialog__inner--minimized > div {
  max-height: calc(100vh - 108px);
}
body.q-ios-padding .q-dialog__inner {
  padding-top: 20px !important;
  padding-top: env(safe-area-inset-top) !important;
  padding-bottom: env(safe-area-inset-bottom) !important;
}
body.q-ios-padding .q-dialog__inner > div {
  max-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom)) !important;
}
@media (max-width: 599.98px) {
  .q-dialog__inner--top, .q-dialog__inner--bottom {
    padding-left: 0;
    padding-right: 0;
  }
  .q-dialog__inner--top > div, .q-dialog__inner--bottom > div {
    width: 100% !important;
  }
}
@media (min-width: 600px) {
  .q-dialog__inner--minimized > div {
    max-width: 560px;
  }
}
.q-body--dialog {
  overflow: hidden;
}
.q-bottom-sheet {
  padding-bottom: 8px;
}
.q-bottom-sheet__avatar {
  border-radius: 50%;
}
.q-bottom-sheet--list {
  width: 400px;
}
.q-bottom-sheet--list .q-icon, .q-bottom-sheet--list img {
  font-size: 24px;
  width: 24px;
  height: 24px;
}
.q-bottom-sheet--grid {
  width: 700px;
}
.q-bottom-sheet--grid .q-bottom-sheet__item {
  padding: 8px;
  text-align: center;
  min-width: 100px;
}
.q-bottom-sheet--grid .q-icon, .q-bottom-sheet--grid img, .q-bottom-sheet--grid .q-bottom-sheet__empty-icon {
  font-size: 48px;
  width: 48px;
  height: 48px;
  margin-bottom: 8px;
}
.q-bottom-sheet--grid .q-separator {
  margin: 12px 0;
}
.q-bottom-sheet__item {
  flex: 0 0 33.3333%;
}
@media (min-width: 600px) {
  .q-bottom-sheet__item {
    flex: 0 0 25%;
  }
}
.q-dialog-plugin {
  width: 400px;
}
.q-dialog-plugin__form {
  max-height: 50vh;
}
.q-dialog-plugin .q-card__section + .q-card__section {
  padding-top: 0;
}
.q-dialog-plugin--progress {
  text-align: center;
}
.q-editor {
  border: 1px solid rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  background-color: #fff;
}
.q-editor.disabled {
  border-style: dashed;
}
.q-editor > div:first-child, .q-editor__toolbars-container, .q-editor__toolbars-container > div:first-child {
  border-top-left-radius: inherit;
  border-top-right-radius: inherit;
}
.q-editor__content {
  outline: 0;
  padding: 10px;
  min-height: 10em;
  border-bottom-left-radius: inherit;
  border-bottom-right-radius: inherit;
  overflow: auto;
  max-width: 100%;
}
.q-editor__content pre {
  white-space: pre-wrap;
}
.q-editor__content hr {
  border: 0;
  outline: 0;
  margin: 1px;
  height: 1px;
  background: rgba(0, 0, 0, 0.12);
}
.q-editor__content:empty:not(:focus):before {
  content: attr(placeholder);
  opacity: 0.7;
}
.q-editor__toolbar {
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
  min-height: 32px;
}
.q-editor__toolbars-container {
  max-width: 100%;
}
.q-editor .q-btn {
  margin: 4px;
}
.q-editor__toolbar-group {
  position: relative;
  margin: 0 4px;
}
.q-editor__toolbar-group + .q-editor__toolbar-group:before {
  content: "";
  position: absolute;
  left: -4px;
  top: 4px;
  bottom: 4px;
  width: 1px;
  background: rgba(0, 0, 0, 0.12);
}
.q-editor__link-input {
  color: inherit;
  text-decoration: none;
  text-transform: none;
  border: none;
  border-radius: 0;
  background: none;
  outline: 0;
}
.q-editor--flat, .q-editor--flat .q-editor__toolbar {
  border: 0;
}
.q-editor--dense .q-editor__toolbar-group {
  display: flex;
  align-items: center;
  flex-wrap: nowrap;
}
.q-editor--dark {
  border-color: rgba(255, 255, 255, 0.28);
}
.q-editor--dark .q-editor__content hr {
  background: rgba(255, 255, 255, 0.28);
}
.q-editor--dark .q-editor__toolbar {
  border-color: rgba(255, 255, 255, 0.28);
}
.q-editor--dark .q-editor__toolbar-group + .q-editor__toolbar-group:before {
  background: rgba(255, 255, 255, 0.28);
}
.q-expansion-item__border {
  opacity: 0;
}
.q-expansion-item__toggle-icon {
  position: relative;
  transition: transform 0.3s;
}
.q-expansion-item__toggle-icon--rotated {
  transform: rotate(180deg);
}
.q-expansion-item__toggle-focus {
  width: 1em !important;
  height: 1em !important;
  position: relative !important;
}
.q-expansion-item__toggle-focus + .q-expansion-item__toggle-icon {
  margin-top: -1em;
}
.q-expansion-item--standard.q-expansion-item--expanded > div > .q-expansion-item__border {
  opacity: 1;
}
.q-expansion-item--popup {
  transition: padding 0.5s;
}
.q-expansion-item--popup > .q-expansion-item__container {
  border: 1px solid rgba(0, 0, 0, 0.12);
}
.q-expansion-item--popup > .q-expansion-item__container > .q-separator {
  display: none;
}
.q-expansion-item--popup.q-expansion-item--collapsed {
  padding: 0 15px;
}
.q-expansion-item--popup.q-expansion-item--expanded {
  padding: 15px 0;
}
.q-expansion-item--popup.q-expansion-item--expanded + .q-expansion-item--popup.q-expansion-item--expanded {
  padding-top: 0;
}
.q-expansion-item--popup.q-expansion-item--collapsed:not(:first-child) > .q-expansion-item__container {
  border-top-width: 0;
}
.q-expansion-item--popup.q-expansion-item--expanded + .q-expansion-item--popup.q-expansion-item--collapsed > .q-expansion-item__container {
  border-top-width: 1px;
}
.q-expansion-item__content > .q-card {
  box-shadow: none;
  border-radius: 0;
}
.q-expansion-item:first-child > div > .q-expansion-item__border--top {
  opacity: 0;
}
.q-expansion-item:last-child > div > .q-expansion-item__border--bottom {
  opacity: 0;
}
.q-expansion-item--expanded + .q-expansion-item--expanded > div > .q-expansion-item__border--top {
  opacity: 0;
}
.q-expansion-item--expanded .q-textarea--autogrow textarea {
  animation: q-expansion-done 0s;
}
/* needed for compilation */
@keyframes q-expansion-done {
  0% {
    --q-exp-done: 1;
  }
}
.z-fab {
  z-index: 990;
}
.q-fab {
  position: relative;
  vertical-align: middle;
}
.q-fab > .q-btn {
  width: 100%;
}
.q-fab--form-rounded {
  border-radius: 28px;
}
.q-fab--form-square {
  border-radius: 4px;
}
.q-fab__icon, .q-fab__active-icon {
  transition: opacity 0.4s, transform 0.4s;
}
.q-fab__icon {
  opacity: 1;
  transform: rotate(0deg);
}
.q-fab__active-icon {
  opacity: 0;
  transform: rotate(-180deg);
}
.q-fab__label--external {
  position: absolute;
  padding: 0 8px;
  transition: opacity 0.18s cubic-bezier(0.65, 0.815, 0.735, 0.395);
}
.q-fab__label--external-hidden {
  opacity: 0;
  pointer-events: none;
}
.q-fab__label--external-left {
  top: 50%;
  left: -12px;
  transform: translate(-100%, -50%);
}
.q-fab__label--external-right {
  top: 50%;
  right: -12px;
  transform: translate(100%, -50%);
}
.q-fab__label--external-bottom {
  bottom: -12px;
  left: 50%;
  transform: translate(-50%, 100%);
}
.q-fab__label--external-top {
  top: -12px;
  left: 50%;
  transform: translate(-50%, -100%);
}
.q-fab__label--internal {
  padding: 0;
  transition: font-size 0.12s cubic-bezier(0.65, 0.815, 0.735, 0.395), max-height 0.12s cubic-bezier(0.65, 0.815, 0.735, 0.395), opacity 0.07s cubic-bezier(0.65, 0.815, 0.735, 0.395);
  max-height: 30px;
}
.q-fab__label--internal-hidden {
  font-size: 0;
  opacity: 0;
}
.q-fab__label--internal-top {
  padding-bottom: 0.12em;
}
.q-fab__label--internal-bottom {
  padding-top: 0.12em;
}
.q-fab__label--internal-top.q-fab__label--internal-hidden, .q-fab__label--internal-bottom.q-fab__label--internal-hidden {
  max-height: 0;
}
.q-fab__label--internal-left {
  padding-left: 0.285em;
  padding-right: 0.571em;
}
.q-fab__label--internal-right {
  padding-right: 0.285em;
  padding-left: 0.571em;
}
.q-fab__icon-holder {
  min-width: 24px;
  min-height: 24px;
  position: relative;
}
.q-fab__icon-holder--opened .q-fab__icon {
  transform: rotate(180deg);
  opacity: 0;
}
.q-fab__icon-holder--opened .q-fab__active-icon {
  transform: rotate(0deg);
  opacity: 1;
}
.q-fab__actions {
  position: absolute;
  opacity: 0;
  transition: transform 0.18s ease-in, opacity 0.18s ease-in;
  pointer-events: none;
  align-items: center;
  justify-content: center;
  align-self: center;
  padding: 3px;
}
.q-fab__actions .q-btn {
  margin: 5px;
}
.q-fab__actions--right {
  transform-origin: 0 50%;
  transform: scale(0.4) translateX(-62px);
  height: 56px;
  left: 100%;
  margin-left: 9px;
}
.q-fab__actions--left {
  transform-origin: 100% 50%;
  transform: scale(0.4) translateX(62px);
  height: 56px;
  right: 100%;
  margin-right: 9px;
  flex-direction: row-reverse;
}
.q-fab__actions--up {
  transform-origin: 50% 100%;
  transform: scale(0.4) translateY(62px);
  width: 56px;
  bottom: 100%;
  margin-bottom: 9px;
  flex-direction: column-reverse;
}
.q-fab__actions--down {
  transform-origin: 50% 0;
  transform: scale(0.4) translateY(-62px);
  width: 56px;
  top: 100%;
  margin-top: 9px;
  flex-direction: column;
}
.q-fab__actions--up, .q-fab__actions--down {
  left: 50%;
  margin-left: -28px;
}
.q-fab__actions--opened {
  opacity: 1;
  transform: scale(1) translate(0.1px, 0);
  pointer-events: all;
}
.q-fab--align-left > .q-fab__actions--up, .q-fab--align-left > .q-fab__actions--down {
  align-items: flex-start;
  left: 28px;
}
.q-fab--align-right > .q-fab__actions--up, .q-fab--align-right > .q-fab__actions--down {
  align-items: flex-end;
  left: auto;
  right: 0;
}
.q-field {
  font-size: 14px;
}
.q-field ::-ms-clear,
.q-field ::-ms-reveal {
  display: none;
}
.q-field--with-bottom {
  padding-bottom: 20px;
}
.q-field__marginal {
  height: 56px;
  color: rgba(0, 0, 0, 0.54);
  font-size: 24px;
}
.q-field__marginal > * + * {
  margin-left: 2px;
}
.q-field__marginal .q-avatar {
  font-size: 32px;
}
.q-field__before, .q-field__prepend {
  padding-right: 12px;
}
.q-field__after, .q-field__append {
  padding-left: 12px;
}
.q-field__after:empty, .q-field__append:empty {
  display: none;
}
.q-field__append + .q-field__append {
  padding-left: 2px;
}
.q-field__inner {
  text-align: left;
}
.q-field__bottom {
  font-size: 12px;
  min-height: 20px;
  line-height: 1;
  color: rgba(0, 0, 0, 0.54);
  padding: 8px 12px 0;
  backface-visibility: hidden;
}
.q-field__bottom--animated {
  transform: translateY(100%);
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
}
.q-field__messages {
  line-height: 1;
}
.q-field__messages > div {
  word-break: break-word;
  word-wrap: break-word;
  overflow-wrap: break-word;
}
.q-field__messages > div + div {
  margin-top: 4px;
}
.q-field__counter {
  padding-left: 8px;
  line-height: 1;
}
.q-field--item-aligned {
  padding: 8px 16px;
}
.q-field--item-aligned .q-field__before {
  min-width: 56px;
}
.q-field__control-container {
  height: inherit;
}
.q-field__control {
  color: var(--q-primary);
  height: 56px;
  max-width: 100%;
  outline: none;
}
.q-field__control:before, .q-field__control:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  pointer-events: none;
}
.q-field__control:before {
  border-radius: inherit;
}
.q-field__shadow {
  top: 8px;
  opacity: 0;
  overflow: hidden;
  white-space: pre-wrap;
  transition: opacity 0.36s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-field__shadow + .q-field__native::placeholder {
  transition: opacity 0.36s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-field__shadow + .q-field__native:focus::placeholder {
  opacity: 0;
}
.q-field__native, .q-field__prefix, .q-field__suffix, .q-field__input {
  font-weight: 400;
  line-height: 28px;
  letter-spacing: 0.00937em;
  text-decoration: inherit;
  text-transform: inherit;
  border: none;
  border-radius: 0;
  background: none;
  color: rgba(0, 0, 0, 0.87);
  outline: 0;
  padding: 6px 0;
}
.q-field__native, .q-field__input {
  width: 100%;
  min-width: 0;
  outline: 0 !important;
  user-select: auto;
}
.q-field__native:-webkit-autofill, .q-field__input:-webkit-autofill {
  -webkit-animation-name: q-autofill;
  -webkit-animation-fill-mode: both;
}
.q-field__native:-webkit-autofill + .q-field__label, .q-field__input:-webkit-autofill + .q-field__label {
  transform: translateY(-40%) scale(0.75);
}
.q-field__native[type=number]:invalid + .q-field__label, .q-field__input[type=number]:invalid + .q-field__label {
  transform: translateY(-40%) scale(0.75);
}
.q-field__native:invalid, .q-field__input:invalid {
  box-shadow: none;
}
.q-field__native[type=file] {
  line-height: 1em;
}
.q-field__input {
  padding: 0;
  height: 0;
  min-height: 24px;
  line-height: 24px;
}
.q-field__prefix, .q-field__suffix {
  transition: opacity 0.36s cubic-bezier(0.4, 0, 0.2, 1);
  white-space: nowrap;
}
.q-field__prefix {
  padding-right: 4px;
}
.q-field__suffix {
  padding-left: 4px;
}
.q-field--readonly .q-placeholder, .q-field--disabled .q-placeholder {
  opacity: 1 !important;
}
.q-field--readonly.q-field--labeled .q-field__native, .q-field--readonly.q-field--labeled .q-field__input {
  cursor: default;
}
.q-field--readonly.q-field--float .q-field__native, .q-field--readonly.q-field--float .q-field__input {
  cursor: text;
}
.q-field--disabled .q-field__inner {
  cursor: not-allowed;
}
.q-field--disabled .q-field__control {
  pointer-events: none;
}
.q-field--disabled .q-field__control > div {
  opacity: 0.6 !important;
}
.q-field--disabled .q-field__control > div, .q-field--disabled .q-field__control > div * {
  outline: 0 !important;
}
.q-field__label {
  left: 0;
  top: 18px;
  max-width: 100%;
  color: rgba(0, 0, 0, 0.6);
  font-size: 16px;
  line-height: 20px;
  font-weight: 400;
  letter-spacing: 0.00937em;
  text-decoration: inherit;
  text-transform: inherit;
  transform-origin: left top;
  transition: transform 0.36s cubic-bezier(0.4, 0, 0.2, 1), max-width 0.324s cubic-bezier(0.4, 0, 0.2, 1);
  backface-visibility: hidden;
}
.q-field--float .q-field__label {
  max-width: 133%;
  transform: translateY(-40%) scale(0.75);
  transition: transform 0.36s cubic-bezier(0.4, 0, 0.2, 1), max-width 0.396s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-field--highlighted .q-field__label {
  color: currentColor;
}
.q-field--highlighted .q-field__shadow {
  opacity: 0.5;
}
.q-field--filled .q-field__control {
  padding: 0 12px;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 4px 4px 0 0;
}
.q-field--filled .q-field__control:before {
  background: rgba(0, 0, 0, 0.05);
  border-bottom: 1px solid rgba(0, 0, 0, 0.42);
  opacity: 0;
  transition: opacity 0.36s cubic-bezier(0.4, 0, 0.2, 1), background 0.36s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-field--filled .q-field__control:hover:before {
  opacity: 1;
}
.q-field--filled .q-field__control:after {
  height: 2px;
  top: auto;
  transform-origin: center bottom;
  transform: scale3d(0, 1, 1);
  background: currentColor;
  transition: transform 0.36s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-field--filled.q-field--rounded .q-field__control {
  border-radius: 28px 28px 0 0;
}
.q-field--filled.q-field--highlighted .q-field__control:before {
  opacity: 1;
  background: rgba(0, 0, 0, 0.12);
}
.q-field--filled.q-field--highlighted .q-field__control:after {
  transform: scale3d(1, 1, 1);
}
.q-field--filled.q-field--dark .q-field__control, .q-field--filled.q-field--dark .q-field__control:before {
  background: rgba(255, 255, 255, 0.07);
}
.q-field--filled.q-field--dark.q-field--highlighted .q-field__control:before {
  background: rgba(255, 255, 255, 0.1);
}
.q-field--filled.q-field--readonly .q-field__control:before {
  opacity: 1;
  background: transparent;
  border-bottom-style: dashed;
}
.q-field--outlined .q-field__control {
  border-radius: 4px;
  padding: 0 12px;
}
.q-field--outlined .q-field__control:before {
  border: 1px solid rgba(0, 0, 0, 0.24);
  transition: border-color 0.36s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-field--outlined .q-field__control:hover:before {
  border-color: #000;
}
.q-field--outlined .q-field__control:after {
  height: inherit;
  border-radius: inherit;
  border: 2px solid transparent;
  transition: border-color 0.36s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-field--outlined .q-field__native:-webkit-autofill,
.q-field--outlined .q-field__input:-webkit-autofill {
  margin-top: 1px;
  margin-bottom: 1px;
}
.q-field--outlined.q-field--rounded .q-field__control {
  border-radius: 28px;
}
.q-field--outlined.q-field--highlighted .q-field__control:hover:before {
  border-color: transparent;
}
.q-field--outlined.q-field--highlighted .q-field__control:after {
  border-color: currentColor;
  border-width: 2px;
  transform: scale3d(1, 1, 1);
}
.q-field--outlined.q-field--readonly .q-field__control:before {
  border-style: dashed;
}
.q-field--standard .q-field__control:before {
  border-bottom: 1px solid rgba(0, 0, 0, 0.24);
  transition: border-color 0.36s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-field--standard .q-field__control:hover:before {
  border-color: #000;
}
.q-field--standard .q-field__control:after {
  height: 2px;
  top: auto;
  border-bottom-left-radius: inherit;
  border-bottom-right-radius: inherit;
  transform-origin: center bottom;
  transform: scale3d(0, 1, 1);
  background: currentColor;
  transition: transform 0.36s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-field--standard.q-field--highlighted .q-field__control:after {
  transform: scale3d(1, 1, 1);
}
.q-field--standard.q-field--readonly .q-field__control:before {
  border-bottom-style: dashed;
}
.q-field--dark .q-field__control:before {
  border-color: rgba(255, 255, 255, 0.6);
}
.q-field--dark .q-field__control:hover:before {
  border-color: #fff;
}
.q-field--dark .q-field__native, .q-field--dark .q-field__prefix, .q-field--dark .q-field__suffix, .q-field--dark .q-field__input {
  color: #fff;
}
.q-field--dark:not(.q-field--highlighted) .q-field__label, .q-field--dark .q-field__marginal, .q-field--dark .q-field__bottom {
  color: rgba(255, 255, 255, 0.7);
}
.q-field--standout .q-field__control {
  padding: 0 12px;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 4px;
  transition: box-shadow 0.36s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.36s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-field--standout .q-field__control:before {
  background: rgba(0, 0, 0, 0.07);
  opacity: 0;
  transition: opacity 0.36s cubic-bezier(0.4, 0, 0.2, 1), background 0.36s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-field--standout .q-field__control:hover:before {
  opacity: 1;
}
.q-field--standout.q-field--rounded .q-field__control {
  border-radius: 28px;
}
.q-field--standout.q-field--highlighted .q-field__control {
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
  background: #000;
}
.q-field--standout.q-field--highlighted .q-field__native, .q-field--standout.q-field--highlighted .q-field__prefix, .q-field--standout.q-field--highlighted .q-field__suffix, .q-field--standout.q-field--highlighted .q-field__prepend, .q-field--standout.q-field--highlighted .q-field__append, .q-field--standout.q-field--highlighted .q-field__input {
  color: #fff;
}
.q-field--standout.q-field--readonly .q-field__control:before {
  opacity: 1;
  background: transparent;
  border: 1px dashed rgba(0, 0, 0, 0.24);
}
.q-field--standout.q-field--dark .q-field__control {
  background: rgba(255, 255, 255, 0.07);
}
.q-field--standout.q-field--dark .q-field__control:before {
  background: rgba(255, 255, 255, 0.07);
}
.q-field--standout.q-field--dark.q-field--highlighted .q-field__control {
  background: #fff;
}
.q-field--standout.q-field--dark.q-field--highlighted .q-field__native, .q-field--standout.q-field--dark.q-field--highlighted .q-field__prefix, .q-field--standout.q-field--dark.q-field--highlighted .q-field__suffix, .q-field--standout.q-field--dark.q-field--highlighted .q-field__prepend, .q-field--standout.q-field--dark.q-field--highlighted .q-field__append, .q-field--standout.q-field--dark.q-field--highlighted .q-field__input {
  color: #000;
}
.q-field--standout.q-field--dark.q-field--readonly .q-field__control:before {
  border-color: rgba(255, 255, 255, 0.24);
}
.q-field--labeled .q-field__native, .q-field--labeled .q-field__prefix, .q-field--labeled .q-field__suffix {
  line-height: 24px;
  padding-top: 24px;
  padding-bottom: 8px;
}
.q-field--labeled .q-field__shadow {
  top: 0;
}
.q-field--labeled:not(.q-field--float) .q-field__prefix, .q-field--labeled:not(.q-field--float) .q-field__suffix {
  opacity: 0;
}
.q-field--labeled:not(.q-field--float) .q-field__native::-webkit-input-placeholder, .q-field--labeled:not(.q-field--float) .q-field__input::-webkit-input-placeholder {
  color: transparent;
}
.q-field--labeled:not(.q-field--float) .q-field__native::-moz-placeholder, .q-field--labeled:not(.q-field--float) .q-field__input::-moz-placeholder {
  color: transparent;
}
.q-field--labeled:not(.q-field--float) .q-field__native:-ms-input-placeholder, .q-field--labeled:not(.q-field--float) .q-field__input:-ms-input-placeholder {
  color: transparent !important;
}
.q-field--labeled:not(.q-field--float) .q-field__native::-ms-input-placeholder, .q-field--labeled:not(.q-field--float) .q-field__input::-ms-input-placeholder {
  color: transparent;
}
.q-field--labeled:not(.q-field--float) .q-field__native::placeholder, .q-field--labeled:not(.q-field--float) .q-field__input::placeholder {
  color: transparent;
}
.q-field--labeled.q-field--dense .q-field__native, .q-field--labeled.q-field--dense .q-field__prefix, .q-field--labeled.q-field--dense .q-field__suffix {
  padding-top: 14px;
  padding-bottom: 2px;
}
.q-field--dense .q-field__shadow {
  top: 0;
}
.q-field--dense .q-field__control, .q-field--dense .q-field__marginal {
  height: 40px;
}
.q-field--dense .q-field__bottom {
  font-size: 11px;
}
.q-field--dense .q-field__label {
  font-size: 14px;
  top: 10px;
}
.q-field--dense .q-field__before, .q-field--dense .q-field__prepend {
  padding-right: 6px;
}
.q-field--dense .q-field__after, .q-field--dense .q-field__append {
  padding-left: 6px;
}
.q-field--dense .q-field__append + .q-field__append {
  padding-left: 2px;
}
.q-field--dense .q-field__marginal .q-avatar {
  font-size: 24px;
}
.q-field--dense.q-field--float .q-field__label {
  transform: translateY(-30%) scale(0.75);
}
.q-field--dense .q-field__native:-webkit-autofill + .q-field__label, .q-field--dense .q-field__input:-webkit-autofill + .q-field__label {
  transform: translateY(-30%) scale(0.75);
}
.q-field--dense .q-field__native[type=number]:invalid + .q-field__label, .q-field--dense .q-field__input[type=number]:invalid + .q-field__label {
  transform: translateY(-30%) scale(0.75);
}
.q-field--borderless .q-field__bottom, .q-field--borderless.q-field--dense .q-field__control, .q-field--standard .q-field__bottom, .q-field--standard.q-field--dense .q-field__control {
  padding-left: 0;
  padding-right: 0;
}
.q-field--error .q-field__label {
  animation: q-field-label 0.36s;
}
.q-field--error .q-field__bottom {
  color: var(--q-negative);
}
.q-field__focusable-action {
  opacity: 0.6;
  cursor: pointer;
  outline: 0 !important;
  border: 0;
  color: inherit;
  background: transparent;
  padding: 0;
}
.q-field__focusable-action:hover, .q-field__focusable-action:focus {
  opacity: 1;
}
.q-field--auto-height .q-field__control {
  height: auto;
}
.q-field--auto-height .q-field__control, .q-field--auto-height .q-field__native {
  min-height: 56px;
}
.q-field--auto-height .q-field__native {
  align-items: center;
}
.q-field--auto-height .q-field__control-container {
  padding-top: 0;
}
.q-field--auto-height .q-field__native, .q-field--auto-height .q-field__prefix, .q-field--auto-height .q-field__suffix {
  line-height: 18px;
}
.q-field--auto-height.q-field--labeled .q-field__control-container {
  padding-top: 24px;
}
.q-field--auto-height.q-field--labeled .q-field__shadow {
  top: 24px;
}
.q-field--auto-height.q-field--labeled .q-field__native, .q-field--auto-height.q-field--labeled .q-field__prefix, .q-field--auto-height.q-field--labeled .q-field__suffix {
  padding-top: 0;
}
.q-field--auto-height.q-field--labeled .q-field__native {
  min-height: 24px;
}
.q-field--auto-height.q-field--dense .q-field__control, .q-field--auto-height.q-field--dense .q-field__native {
  min-height: 40px;
}
.q-field--auto-height.q-field--dense.q-field--labeled .q-field__control-container {
  padding-top: 14px;
}
.q-field--auto-height.q-field--dense.q-field--labeled .q-field__shadow {
  top: 14px;
}
.q-field--auto-height.q-field--dense.q-field--labeled .q-field__native {
  min-height: 24px;
}
.q-field--square .q-field__control {
  border-radius: 0 !important;
}
.q-transition--field-message-enter-active, .q-transition--field-message-leave-active {
  transition: transform 0.6s cubic-bezier(0.86, 0, 0.07, 1), opacity 0.6s cubic-bezier(0.86, 0, 0.07, 1);
}
.q-transition--field-message-enter-from, .q-transition--field-message-leave-to {
  opacity: 0;
  transform: translateY(-10px);
}
.q-transition--field-message-leave-from, .q-transition--field-message-leave-active {
  position: absolute;
}
@keyframes q-field-label {
  40% {
    margin-left: 2px;
  }
  60%, 80% {
    margin-left: -2px;
  }
  70%, 90% {
    margin-left: 2px;
  }
}
@keyframes q-autofill {
  to {
    background: transparent;
    color: inherit;
  }
}
.q-file .q-field__native {
  word-break: break-all;
  overflow: hidden;
}
.q-file .q-field__input {
  opacity: 0 !important;
}
.q-file .q-field__input::-webkit-file-upload-button {
  cursor: pointer;
}
.q-file__filler {
  visibility: hidden;
  width: 100%;
  border: none;
  padding: 0;
}
.q-file__dnd {
  outline: 1px dashed currentColor;
  outline-offset: -4px;
}
.q-form {
  position: relative;
}
.q-img {
  position: relative;
  width: 100%;
  display: inline-block;
  vertical-align: middle;
  overflow: hidden;
}
.q-img__loading .q-spinner {
  font-size: 50px;
}
.q-img__container {
  border-radius: inherit;
  font-size: 0;
}
.q-img__image {
  border-radius: inherit;
  width: 100%;
  height: 100%;
  opacity: 0;
}
.q-img__image--with-transition {
  transition: opacity 0.28s ease-in;
}
.q-img__image--loaded {
  opacity: 1;
}
.q-img__content {
  border-radius: inherit;
  pointer-events: none;
}
.q-img__content > div {
  pointer-events: all;
  position: absolute;
  padding: 16px;
  color: #fff;
  background: rgba(0, 0, 0, 0.47);
}
.q-img--no-menu .q-img__image,
.q-img--no-menu .q-img__placeholder {
  pointer-events: none;
}
.q-inner-loading {
  background: rgba(255, 255, 255, 0.6);
}
.q-inner-loading--dark {
  background: rgba(0, 0, 0, 0.4);
}
.q-inner-loading__label {
  margin-top: 8px;
}
.q-textarea .q-field__control {
  min-height: 56px;
  height: auto;
}
.q-textarea .q-field__control-container {
  padding-top: 2px;
  padding-bottom: 2px;
}
.q-textarea .q-field__shadow {
  top: 2px;
  bottom: 2px;
}
.q-textarea .q-field__native, .q-textarea .q-field__prefix, .q-textarea .q-field__suffix {
  line-height: 18px;
}
.q-textarea .q-field__native {
  resize: vertical;
  padding-top: 17px;
  min-height: 52px;
}
.q-textarea.q-field--labeled .q-field__control-container {
  padding-top: 26px;
}
.q-textarea.q-field--labeled .q-field__shadow {
  top: 26px;
}
.q-textarea.q-field--labeled .q-field__native, .q-textarea.q-field--labeled .q-field__prefix, .q-textarea.q-field--labeled .q-field__suffix {
  padding-top: 0;
}
.q-textarea.q-field--labeled .q-field__native {
  min-height: 26px;
  padding-top: 1px;
}
.q-textarea--autogrow .q-field__native {
  resize: none;
}
.q-textarea.q-field--dense .q-field__control, .q-textarea.q-field--dense .q-field__native {
  min-height: 36px;
}
.q-textarea.q-field--dense .q-field__native {
  padding-top: 9px;
}
.q-textarea.q-field--dense.q-field--labeled .q-field__control-container {
  padding-top: 14px;
}
.q-textarea.q-field--dense.q-field--labeled .q-field__shadow {
  top: 14px;
}
.q-textarea.q-field--dense.q-field--labeled .q-field__native {
  min-height: 24px;
  padding-top: 3px;
}
.q-textarea.q-field--dense.q-field--labeled .q-field__prefix, .q-textarea.q-field--dense.q-field--labeled .q-field__suffix {
  padding-top: 2px;
}
body.mobile .q-textarea .q-field__native,
.q-textarea.disabled .q-field__native {
  resize: none;
}
.q-intersection {
  position: relative;
}
.q-item {
  min-height: 48px;
  padding: 8px 16px;
  color: inherit;
  transition: color 0.3s, background-color 0.3s;
}
.q-item__section--side {
  color: #757575;
  align-items: flex-start;
  padding-right: 16px;
  width: auto;
  min-width: 0;
  max-width: 100%;
}
.q-item__section--side > .q-icon {
  font-size: 24px;
}
.q-item__section--side > .q-avatar {
  font-size: 40px;
}
.q-item__section--avatar {
  color: inherit;
  min-width: 56px;
}
.q-item__section--thumbnail img {
  width: 100px;
  height: 56px;
}
.q-item__section--nowrap {
  white-space: nowrap;
}
.q-item > .q-item__section--thumbnail:first-child,
.q-item > .q-focus-helper + .q-item__section--thumbnail {
  margin-left: -16px;
}
.q-item > .q-item__section--thumbnail:last-of-type {
  margin-right: -16px;
}
.q-item__label {
  line-height: 1.2em !important;
  max-width: 100%;
}
.q-item__label--overline {
  color: rgba(0, 0, 0, 0.7);
}
.q-item__label--caption {
  color: rgba(0, 0, 0, 0.54);
}
.q-item__label--header {
  color: #757575;
  padding: 16px;
  font-size: 0.875rem;
  line-height: 1.25rem;
  letter-spacing: 0.01786em;
}
.q-separator--spaced + .q-item__label--header, .q-list--padding .q-item__label--header {
  padding-top: 8px;
}
.q-item__label + .q-item__label {
  margin-top: 4px;
}
.q-item__section--main {
  width: auto;
  min-width: 0;
  max-width: 100%;
  flex: 10000 1 0%;
}
.q-item__section--main + .q-item__section--main {
  margin-left: 8px;
}
.q-item__section--main ~ .q-item__section--side {
  align-items: flex-end;
  padding-right: 0;
  padding-left: 16px;
}
.q-item__section--main.q-item__section--thumbnail {
  margin-left: 0;
  margin-right: -16px;
}
.q-list--bordered {
  border: 1px solid rgba(0, 0, 0, 0.12);
}
.q-list--separator > .q-item-type + .q-item-type,
.q-list--separator > .q-virtual-scroll__content > .q-item-type + .q-item-type {
  border-top: 1px solid rgba(0, 0, 0, 0.12);
}
.q-list--padding {
  padding: 8px 0;
}
.q-list--dense > .q-item, .q-item--dense {
  min-height: 32px;
  padding: 2px 16px;
}
.q-list--dark.q-list--separator > .q-item-type + .q-item-type,
.q-list--dark.q-list--separator > .q-virtual-scroll__content > .q-item-type + .q-item-type {
  border-top-color: rgba(255, 255, 255, 0.28);
}
.q-list--dark, .q-item--dark {
  color: #fff;
  border-color: rgba(255, 255, 255, 0.28);
}
.q-list--dark .q-item__section--side:not(.q-item__section--avatar), .q-item--dark .q-item__section--side:not(.q-item__section--avatar) {
  color: rgba(255, 255, 255, 0.7);
}
.q-list--dark .q-item__label--header, .q-item--dark .q-item__label--header {
  color: rgba(255, 255, 255, 0.64);
}
.q-list--dark .q-item__label--overline, .q-list--dark .q-item__label--caption, .q-item--dark .q-item__label--overline, .q-item--dark .q-item__label--caption {
  color: rgba(255, 255, 255, 0.8);
}
.q-item {
  position: relative;
}
.q-item.q-router-link--active, .q-item--active {
  color: var(--q-primary);
}
.q-knob {
  font-size: 48px;
}
.q-knob--editable {
  cursor: pointer;
  outline: 0;
}
.q-knob--editable:before {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  border-radius: 50%;
  box-shadow: none;
  transition: box-shadow 0.24s ease-in-out;
}
.q-knob--editable:focus:before {
  box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px rgba(0, 0, 0, 0.14), 0 1px 10px rgba(0, 0, 0, 0.12);
}
.q-layout {
  width: 100%;
}
.q-layout-container {
  position: relative;
  width: 100%;
  height: 100%;
}
.q-layout-container .q-layout {
  min-height: 100%;
}
.q-layout-container > div {
  transform: translate3d(0, 0, 0);
}
.q-layout-container > div > div {
  min-height: 0;
  max-height: 100%;
}
.q-layout__shadow {
  width: 100%;
}
.q-layout__shadow:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  box-shadow: 0 0 10px 2px rgba(0, 0, 0, 0.2), 0 0px 10px rgba(0, 0, 0, 0.24);
}
.q-layout__section--marginal {
  background-color: var(--q-primary);
  color: #fff;
}
.q-header--hidden {
  transform: translateY(-110%);
}
.q-header--bordered {
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
}
.q-header .q-layout__shadow {
  bottom: -10px;
}
.q-header .q-layout__shadow:after {
  bottom: 10px;
}
.q-footer--hidden {
  transform: translateY(110%);
}
.q-footer--bordered {
  border-top: 1px solid rgba(0, 0, 0, 0.12);
}
.q-footer .q-layout__shadow {
  top: -10px;
}
.q-footer .q-layout__shadow:after {
  top: 10px;
}
.q-header, .q-footer {
  z-index: 2000;
}
.q-drawer {
  position: absolute;
  top: 0;
  bottom: 0;
  background: #fff;
  z-index: 1000;
}
.q-drawer--on-top {
  z-index: 3000;
}
.q-drawer--left {
  left: 0;
  transform: translateX(-100%);
}
.q-drawer--left.q-drawer--bordered {
  border-right: 1px solid rgba(0, 0, 0, 0.12);
}
.q-drawer--left .q-layout__shadow {
  left: 10px;
  right: -10px;
}
.q-drawer--left .q-layout__shadow:after {
  right: 10px;
}
.q-drawer--right {
  right: 0;
  transform: translateX(100%);
}
.q-drawer--right.q-drawer--bordered {
  border-left: 1px solid rgba(0, 0, 0, 0.12);
}
.q-drawer--right .q-layout__shadow {
  left: -10px;
}
.q-drawer--right .q-layout__shadow:after {
  left: 10px;
}
.q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini {
  padding: 0 !important;
}
.q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini .q-item, .q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini .q-item__section {
  text-align: center;
  justify-content: center;
  padding-left: 0;
  padding-right: 0;
  min-width: 0;
}
.q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini .q-item__label, .q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini .q-item__section--main, .q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini .q-item__section--side ~ .q-item__section--side {
  display: none;
}
.q-drawer--mini .q-mini-drawer-hide, .q-drawer--mini .q-expansion-item__content {
  display: none;
}
.q-drawer--mini-animate .q-drawer__content {
  overflow-x: hidden !important;
  white-space: nowrap;
}
.q-drawer--standard .q-mini-drawer-only {
  display: none;
}
.q-drawer--mobile .q-mini-drawer-only, .q-drawer--mobile .q-mini-drawer-hide {
  display: none;
}
.q-drawer__backdrop {
  z-index: 2999 !important;
  will-change: background-color;
}
.q-drawer__opener {
  z-index: 2001;
  height: 100%;
  width: 15px;
  user-select: none;
}
.q-layout, .q-header, .q-footer, .q-page {
  position: relative;
}
.q-page-sticky--shrink {
  pointer-events: none;
}
.q-page-sticky--shrink > div {
  display: inline-block;
  pointer-events: auto;
}
body.q-ios-padding .q-layout--standard .q-header > .q-toolbar:nth-child(1),
body.q-ios-padding .q-layout--standard .q-header > .q-tabs:nth-child(1) .q-tabs-head,
body.q-ios-padding .q-layout--standard .q-drawer--top-padding .q-drawer__content {
  padding-top: 20px;
  min-height: 70px;
  padding-top: env(safe-area-inset-top);
  min-height: calc(env(safe-area-inset-top) + 50px);
}
body.q-ios-padding .q-layout--standard .q-footer > .q-toolbar:last-child,
body.q-ios-padding .q-layout--standard .q-footer > .q-tabs:last-child .q-tabs-head,
body.q-ios-padding .q-layout--standard .q-drawer--top-padding .q-drawer__content {
  padding-bottom: env(safe-area-inset-bottom);
  min-height: calc(env(safe-area-inset-bottom) + 50px);
}
.q-body--layout-animate .q-drawer__backdrop {
  transition: background-color 0.12s !important;
}
.q-body--layout-animate .q-drawer {
  transition: transform 0.12s, width 0.12s, top 0.12s, bottom 0.12s !important;
}
.q-body--layout-animate .q-layout__section--marginal {
  transition: transform 0.12s, left 0.12s, right 0.12s !important;
}
.q-body--layout-animate .q-page-container {
  transition: padding-top 0.12s, padding-right 0.12s, padding-bottom 0.12s, padding-left 0.12s !important;
}
.q-body--layout-animate .q-page-sticky {
  transition: transform 0.12s, left 0.12s, right 0.12s, top 0.12s, bottom 0.12s !important;
}
body:not(.q-body--layout-animate) .q-layout--prevent-focus {
  visibility: hidden;
}
.q-body--drawer-toggle {
  overflow-x: hidden !important;
}
@media (max-width: 599.98px) {
  .q-layout-padding {
    padding: 8px;
  }
}
@media (min-width: 600px) and (max-width: 1439.98px) {
  .q-layout-padding {
    padding: 16px;
  }
}
@media (min-width: 1440px) {
  .q-layout-padding {
    padding: 24px;
  }
}
body.body--dark .q-header, body.body--dark .q-footer, body.body--dark .q-drawer {
  border-color: rgba(255, 255, 255, 0.28);
}
body.platform-ios .q-layout--containerized {
  position: unset !important;
}
.q-linear-progress {
  --q-linear-progress-speed: .3s;
  position: relative;
  width: 100%;
  overflow: hidden;
  font-size: 4px;
  height: 1em;
  color: var(--q-primary);
  transform: scale3d(1, 1, 1);
}
.q-linear-progress__model, .q-linear-progress__track {
  transform-origin: 0 0;
}
.q-linear-progress__model--with-transition, .q-linear-progress__track--with-transition {
  transition: transform var(--q-linear-progress-speed);
}
.q-linear-progress--reverse .q-linear-progress__model, .q-linear-progress--reverse .q-linear-progress__track {
  transform-origin: 0 100%;
}
.q-linear-progress__model--determinate {
  background: currentColor;
}
.q-linear-progress__model--indeterminate, .q-linear-progress__model--query {
  transition: none;
}
.q-linear-progress__model--indeterminate:before, .q-linear-progress__model--indeterminate:after, .q-linear-progress__model--query:before, .q-linear-progress__model--query:after {
  background: currentColor;
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  transform-origin: 0 0;
}
.q-linear-progress__model--indeterminate:before, .q-linear-progress__model--query:before {
  animation: q-linear-progress--indeterminate 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
}
.q-linear-progress__model--indeterminate:after, .q-linear-progress__model--query:after {
  transform: translate3d(-101%, 0, 0) scale3d(1, 1, 1);
  animation: q-linear-progress--indeterminate-short 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) infinite;
  animation-delay: 1.15s;
}
.q-linear-progress__track {
  opacity: 0.4;
}
.q-linear-progress__track--light {
  background: rgba(0, 0, 0, 0.26);
}
.q-linear-progress__track--dark {
  background: rgba(255, 255, 255, 0.6);
}
.q-linear-progress__stripe {
  transition: width var(--q-linear-progress-speed);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, rgba(255, 255, 255, 0) 25%, rgba(255, 255, 255, 0) 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, rgba(255, 255, 255, 0) 75%, rgba(255, 255, 255, 0)) !important;
  background-size: 40px 40px !important;
}
@keyframes q-linear-progress--indeterminate {
  0% {
    transform: translate3d(-35%, 0, 0) scale3d(0.35, 1, 1);
  }
  60% {
    transform: translate3d(100%, 0, 0) scale3d(0.9, 1, 1);
  }
  100% {
    transform: translate3d(100%, 0, 0) scale3d(0.9, 1, 1);
  }
}
@keyframes q-linear-progress--indeterminate-short {
  0% {
    transform: translate3d(-101%, 0, 0) scale3d(1, 1, 1);
  }
  60% {
    transform: translate3d(107%, 0, 0) scale3d(0.01, 1, 1);
  }
  100% {
    transform: translate3d(107%, 0, 0) scale3d(0.01, 1, 1);
  }
}
.q-menu {
  position: fixed !important;
  display: inline-block;
  max-width: 95vw;
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
  background: #fff;
  border-radius: 4px;
  overflow-y: auto;
  overflow-x: hidden;
  outline: 0;
  max-height: 65vh;
  z-index: 6000;
}
.q-menu--square {
  border-radius: 0;
}
.q-option-group--inline > div {
  display: inline-block;
}
.q-pagination input {
  text-align: center;
  -moz-appearance: textfield;
}
.q-pagination input::-webkit-outer-spin-button,
.q-pagination input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.q-pagination__content {
  --q-pagination-gutter-parent: -2px;
  --q-pagination-gutter-child: 2px;
  margin-top: var(--q-pagination-gutter-parent);
  margin-left: var(--q-pagination-gutter-parent);
}
.q-pagination__content > .q-btn, .q-pagination__content > .q-input, .q-pagination__middle > .q-btn {
  margin-top: var(--q-pagination-gutter-child);
  margin-left: var(--q-pagination-gutter-child);
}
.q-parallax {
  position: relative;
  width: 100%;
  overflow: hidden;
  border-radius: inherit;
}
.q-parallax__media > img, .q-parallax__media > video {
  position: absolute;
  left: 50% /* rtl:ignore */;
  bottom: 0;
  min-width: 100%;
  min-height: 100%;
  will-change: transform;
  display: none;
}
.q-popup-edit {
  padding: 8px 16px;
}
.q-popup-edit__buttons {
  margin-top: 8px;
}
.q-popup-edit__buttons .q-btn + .q-btn {
  margin-left: 8px;
}
.q-pull-to-refresh {
  position: relative;
}
.q-pull-to-refresh__puller {
  border-radius: 50%;
  width: 40px;
  height: 40px;
  color: var(--q-primary);
  background: #fff;
  box-shadow: 0 0 4px 0 rgba(0, 0, 0, 0.3);
}
.q-pull-to-refresh__puller--animating {
  transition: transform 0.3s, opacity 0.3s;
}
.q-radio {
  vertical-align: middle;
}
.q-radio__native {
  width: 1px;
  height: 1px;
}
.q-radio__bg, .q-radio__icon-container {
  user-select: none;
}
.q-radio__bg {
  top: 25%;
  left: 25%;
  width: 50%;
  height: 50%;
  -webkit-print-color-adjust: exact;
}
.q-radio__bg path {
  fill: currentColor;
}
.q-radio__icon {
  color: currentColor;
  font-size: 0.5em;
}
.q-radio__check {
  transform-origin: 50% 50%;
  transform: scale3d(0, 0, 1);
  transition: transform 0.22s cubic-bezier(0, 0, 0.2, 1) 0ms;
}
.q-radio__inner {
  font-size: 40px;
  width: 1em;
  min-width: 1em;
  height: 1em;
  outline: 0;
  border-radius: 50%;
  color: rgba(0, 0, 0, 0.54);
}
.q-radio__inner--truthy {
  color: var(--q-primary);
}
.q-radio__inner--truthy .q-radio__check {
  transform: scale3d(1, 1, 1);
}
.q-radio.disabled {
  opacity: 0.75 !important;
}
.q-radio--dark .q-radio__inner {
  color: rgba(255, 255, 255, 0.7);
}
.q-radio--dark .q-radio__inner:before {
  opacity: 0.32 !important;
}
.q-radio--dark .q-radio__inner--truthy {
  color: var(--q-primary);
}
.q-radio--dense .q-radio__inner {
  width: 0.5em;
  min-width: 0.5em;
  height: 0.5em;
}
.q-radio--dense .q-radio__bg {
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
}
.q-radio--dense .q-radio__label {
  padding-left: 0.5em;
}
.q-radio--dense.reverse .q-radio__label {
  padding-left: 0;
  padding-right: 0.5em;
}
body.desktop .q-radio:not(.disabled) .q-radio__inner:before {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  border-radius: 50%;
  background: currentColor;
  opacity: 0.12;
  transform: scale3d(0, 0, 1);
  transition: transform 0.22s cubic-bezier(0, 0, 0.2, 1) 0ms;
}
body.desktop .q-radio:not(.disabled):focus .q-radio__inner:before, body.desktop .q-radio:not(.disabled):hover .q-radio__inner:before {
  transform: scale3d(1, 1, 1);
}
body.desktop .q-radio--dense:not(.disabled):focus .q-radio__inner:before, body.desktop .q-radio--dense:not(.disabled):hover .q-radio__inner:before {
  transform: scale3d(1.5, 1.5, 1);
}
.q-rating {
  color: #ffeb3b;
  vertical-align: middle;
}
.q-rating__icon-container {
  height: 1em;
  outline: 0;
}
.q-rating__icon-container + .q-rating__icon-container {
  margin-left: 2px;
}
.q-rating__icon {
  color: currentColor;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
  position: relative;
  opacity: 0.4;
  transition: transform 0.2s ease-in, opacity 0.2s ease-in;
}
.q-rating__icon--hovered {
  transform: scale(1.3);
}
.q-rating__icon--active {
  opacity: 1;
}
.q-rating__icon--exselected {
  opacity: 0.7;
}
.q-rating--no-dimming .q-rating__icon {
  opacity: 1;
}
.q-rating--editable .q-rating__icon-container {
  cursor: pointer;
}
.q-responsive {
  position: relative;
  max-width: 100%;
  max-height: 100%;
}
.q-responsive__filler {
  width: inherit;
  max-width: inherit;
  height: inherit;
  max-height: inherit;
}
.q-responsive__content {
  border-radius: inherit;
}
.q-responsive__content > * {
  width: 100% !important;
  height: 100% !important;
  max-height: 100% !important;
  max-width: 100% !important;
}
.q-scrollarea {
  position: relative;
  contain: strict;
}
.q-scrollarea__bar, .q-scrollarea__thumb {
  opacity: 0.2;
  transition: opacity 0.3s;
  will-change: opacity;
  cursor: grab;
}
.q-scrollarea__bar--v, .q-scrollarea__thumb--v {
  right: 0;
  width: 10px;
}
.q-scrollarea__bar--h, .q-scrollarea__thumb--h {
  bottom: 0;
  height: 10px;
}
.q-scrollarea__bar--invisible, .q-scrollarea__thumb--invisible {
  opacity: 0 !important;
  pointer-events: none;
}
.q-scrollarea__thumb {
  background: #000;
  border-radius: 3px;
}
.q-scrollarea__thumb:hover {
  opacity: 0.3;
}
.q-scrollarea__thumb:active {
  opacity: 0.5;
}
.q-scrollarea__content {
  min-height: 100%;
  min-width: 100%;
}
.q-scrollarea--dark .q-scrollarea__thumb {
  background: #fff;
}
.q-select--without-input .q-field__control {
  cursor: pointer;
}
.q-select--with-input .q-field__control {
  cursor: text;
}
.q-select .q-field__input {
  min-width: 50px !important;
  cursor: text;
}
.q-select .q-field__input--padding {
  padding-left: 4px;
}
.q-select__focus-target, .q-select__autocomplete-input {
  position: absolute;
  outline: 0 !important;
  width: 1px;
  height: 1px;
  padding: 0;
  border: 0;
  opacity: 0;
}
.q-select__dropdown-icon {
  cursor: pointer;
  transition: transform 0.28s;
}
.q-select.q-field--readonly .q-field__control, .q-select.q-field--readonly .q-select__dropdown-icon {
  cursor: default;
}
.q-select__dialog {
  width: 90vw !important;
  max-width: 90vw !important;
  max-height: calc(100vh - 70px) !important;
  background: #fff;
  display: flex;
  flex-direction: column;
}
.q-select__dialog > .scroll {
  position: relative;
  background: inherit;
}
body.mobile:not(.native-mobile) .q-select__dialog {
  max-height: calc(100vh - 108px) !important;
}
body.platform-android.native-mobile .q-dialog__inner--top .q-select__dialog {
  max-height: calc(100vh - 24px) !important;
}
body.platform-android:not(.native-mobile) .q-dialog__inner--top .q-select__dialog {
  max-height: calc(100vh - 80px) !important;
}
body.platform-ios.native-mobile .q-dialog__inner--top > div {
  border-radius: 4px;
}
body.platform-ios.native-mobile .q-dialog__inner--top .q-select__dialog--focused {
  max-height: 47vh !important;
}
body.platform-ios:not(.native-mobile) .q-dialog__inner--top .q-select__dialog--focused {
  max-height: 50vh !important;
}
.q-separator {
  border: 0;
  background: rgba(0, 0, 0, 0.12);
  margin: 0;
  transition: background 0.3s, opacity 0.3s;
  flex-shrink: 0;
}
.q-separator--dark {
  background: rgba(255, 255, 255, 0.28);
}
.q-separator--horizontal {
  display: block;
  height: 1px;
}
.q-separator--horizontal-inset {
  margin-left: 16px;
  margin-right: 16px;
}
.q-separator--horizontal-item-inset {
  margin-left: 72px;
  margin-right: 0;
}
.q-separator--horizontal-item-thumbnail-inset {
  margin-left: 116px;
  margin-right: 0;
}
.q-separator--vertical {
  width: 1px;
  height: auto;
  align-self: stretch;
}
.q-separator--vertical-inset {
  margin-top: 8px;
  margin-bottom: 8px;
}
.q-skeleton {
  --q-skeleton-speed: 1500ms;
  background: rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  /* maintain size even with border
  * for types that have height specified
  * */
  box-sizing: border-box;
}
.q-skeleton--anim {
  cursor: wait;
}
.q-skeleton:before {
  content: "\xA0";
}
.q-skeleton--type-text {
  transform: scale(1, 0.5);
}
.q-skeleton--type-circle, .q-skeleton--type-QAvatar {
  height: 48px;
  width: 48px;
  border-radius: 50%;
}
.q-skeleton--type-QBtn {
  width: 90px;
  height: 36px;
}
.q-skeleton--type-QBadge {
  width: 70px;
  height: 16px;
}
.q-skeleton--type-QChip {
  width: 90px;
  height: 28px;
  border-radius: 16px;
}
.q-skeleton--type-QToolbar {
  height: 50px;
}
.q-skeleton--type-QCheckbox, .q-skeleton--type-QRadio {
  width: 40px;
  height: 40px;
  border-radius: 50%;
}
.q-skeleton--type-QToggle {
  width: 56px;
  height: 40px;
  border-radius: 7px;
}
.q-skeleton--type-QSlider, .q-skeleton--type-QRange {
  height: 40px;
}
.q-skeleton--type-QInput {
  height: 56px;
}
.q-skeleton--bordered {
  border: 1px solid rgba(0, 0, 0, 0.05);
}
.q-skeleton--square {
  border-radius: 0;
}
.q-skeleton--anim-fade {
  animation: q-skeleton--fade var(--q-skeleton-speed) linear 0.5s infinite;
}
.q-skeleton--anim-pulse {
  animation: q-skeleton--pulse var(--q-skeleton-speed) ease-in-out 0.5s infinite;
}
.q-skeleton--anim-pulse-x {
  animation: q-skeleton--pulse-x var(--q-skeleton-speed) ease-in-out 0.5s infinite;
}
.q-skeleton--anim-pulse-y {
  animation: q-skeleton--pulse-y var(--q-skeleton-speed) ease-in-out 0.5s infinite;
}
.q-skeleton--anim-wave, .q-skeleton--anim-blink, .q-skeleton--anim-pop {
  position: relative;
  overflow: hidden;
  z-index: 1;
}
.q-skeleton--anim-wave:after, .q-skeleton--anim-blink:after, .q-skeleton--anim-pop:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 0;
}
.q-skeleton--anim-blink:after {
  background: rgba(255, 255, 255, 0.7);
  animation: q-skeleton--fade var(--q-skeleton-speed) linear 0.5s infinite;
}
.q-skeleton--anim-wave:after {
  background: linear-gradient(90deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0));
  animation: q-skeleton--wave var(--q-skeleton-speed) linear 0.5s infinite;
}
.q-skeleton--dark {
  background: rgba(255, 255, 255, 0.05);
}
.q-skeleton--dark.q-skeleton--bordered {
  border: 1px solid rgba(255, 255, 255, 0.25);
}
.q-skeleton--dark.q-skeleton--anim-wave:after {
  background: linear-gradient(90deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));
}
.q-skeleton--dark.q-skeleton--anim-blink:after {
  background: rgba(255, 255, 255, 0.2);
}
@keyframes q-skeleton--fade {
  0% {
    opacity: 1;
  }
  50% {
    opacity: 0.4;
  }
  100% {
    opacity: 1;
  }
}
@keyframes q-skeleton--pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(0.85);
  }
  100% {
    transform: scale(1);
  }
}
@keyframes q-skeleton--pulse-x {
  0% {
    transform: scaleX(1);
  }
  50% {
    transform: scaleX(0.75);
  }
  100% {
    transform: scaleX(1);
  }
}
@keyframes q-skeleton--pulse-y {
  0% {
    transform: scaleY(1);
  }
  50% {
    transform: scaleY(0.75);
  }
  100% {
    transform: scaleY(1);
  }
}
@keyframes q-skeleton--wave {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(100%);
  }
}
.q-slide-item {
  position: relative;
  background: white;
}
.q-slide-item__left, .q-slide-item__right, .q-slide-item__top, .q-slide-item__bottom {
  visibility: hidden;
  font-size: 14px;
  color: #fff;
}
.q-slide-item__left .q-icon, .q-slide-item__right .q-icon, .q-slide-item__top .q-icon, .q-slide-item__bottom .q-icon {
  font-size: 1.714em;
}
.q-slide-item__left {
  background: #4caf50;
  padding: 8px 16px;
}
.q-slide-item__left > div {
  transform-origin: left center;
}
.q-slide-item__right {
  background: #ff9800;
  padding: 8px 16px;
}
.q-slide-item__right > div {
  transform-origin: right center;
}
.q-slide-item__top {
  background: #2196f3;
  padding: 16px 8px;
}
.q-slide-item__top > div {
  transform-origin: top center;
}
.q-slide-item__bottom {
  background: #9c27b0;
  padding: 16px 8px;
}
.q-slide-item__bottom > div {
  transform-origin: bottom center;
}
.q-slide-item__content {
  background: inherit;
  transition: transform 0.2s ease-in;
  user-select: none;
  cursor: pointer;
}
.q-slider {
  position: relative;
}
.q-slider--h {
  width: 100%;
}
.q-slider--v {
  height: 200px;
}
.q-slider--editable .q-slider__track-container {
  cursor: grab;
}
.q-slider__track-container {
  outline: 0;
}
.q-slider__track-container--h {
  width: 100%;
  padding: 12px 0;
}
.q-slider__track-container--h .q-slider__selection {
  will-change: width, left;
}
.q-slider__track-container--v {
  height: 100%;
  padding: 0 12px;
}
.q-slider__track-container--v .q-slider__selection {
  will-change: height, top;
}
.q-slider__track {
  color: var(--q-primary);
  background: rgba(0, 0, 0, 0.1);
  border-radius: 4px;
  width: inherit;
  height: inherit;
}
.q-slider__inner {
  background: rgba(0, 0, 0, 0.1);
  border-radius: inherit;
  width: 100%;
  height: 100%;
}
.q-slider__selection {
  background: currentColor;
  border-radius: inherit;
  width: 100%;
  height: 100%;
}
.q-slider__markers {
  color: rgba(0, 0, 0, 0.3);
  border-radius: inherit;
  width: 100%;
  height: 100%;
}
.q-slider__markers:after {
  content: "";
  position: absolute;
  background: currentColor;
}
.q-slider__markers--h {
  background-image: repeating-linear-gradient(to right, currentColor, currentColor 2px, rgba(255, 255, 255, 0) 0, rgba(255, 255, 255, 0));
}
.q-slider__markers--h:after {
  height: 100%;
  width: 2px;
  top: 0;
  right: 0;
}
.q-slider__markers--v {
  background-image: repeating-linear-gradient(to bottom, currentColor, currentColor 2px, rgba(255, 255, 255, 0) 0, rgba(255, 255, 255, 0));
}
.q-slider__markers--v:after {
  width: 100%;
  height: 2px;
  left: 0;
  bottom: 0;
}
.q-slider__marker-labels-container {
  position: relative;
  width: 100%;
  height: 100%;
  min-height: 24px;
  min-width: 24px;
}
.q-slider__marker-labels {
  position: absolute;
}
.q-slider__marker-labels--h-standard {
  top: 0;
}
.q-slider__marker-labels--h-switched {
  bottom: 0;
}
.q-slider__marker-labels--h-ltr {
  transform: translateX(-50%) /* rtl:ignore */;
}
.q-slider__marker-labels--h-rtl {
  transform: translateX(50%) /* rtl:ignore */;
}
.q-slider__marker-labels--v-standard {
  left: 4px;
}
.q-slider__marker-labels--v-switched {
  right: 4px;
}
.q-slider__marker-labels--v-ltr {
  transform: translateY(-50%) /* rtl:ignore */;
}
.q-slider__marker-labels--v-rtl {
  transform: translateY(50%) /* rtl:ignore */;
}
.q-slider__thumb {
  z-index: 1;
  outline: 0;
  color: var(--q-primary);
  transition: transform 0.18s ease-out, fill 0.18s ease-out, stroke 0.18s ease-out;
}
.q-slider__thumb.q-slider--focus {
  opacity: 1 !important;
}
.q-slider__thumb--h {
  top: 50%;
  will-change: left;
}
.q-slider__thumb--h-ltr {
  transform: scale(1) translate(-50%, -50%) /* rtl:ignore */;
}
.q-slider__thumb--h-rtl {
  transform: scale(1) translate(50%, -50%) /* rtl:ignore */;
}
.q-slider__thumb--v {
  left: 50% /* rtl:ignore */;
  will-change: top;
}
.q-slider__thumb--v-ltr {
  transform: scale(1) translate(-50%, -50%) /* rtl:ignore */;
}
.q-slider__thumb--v-rtl {
  transform: scale(1) translate(-50%, 50%) /* rtl:ignore */;
}
.q-slider__thumb-shape {
  top: 0;
  left: 0;
  stroke-width: 3.5;
  stroke: currentColor;
  transition: transform 0.28s;
}
.q-slider__thumb-shape path {
  stroke: currentColor;
  fill: currentColor;
}
.q-slider__focus-ring {
  border-radius: 50%;
  opacity: 0;
  transition: transform 266.67ms ease-out, opacity 266.67ms ease-out, background-color 266.67ms ease-out;
  transition-delay: 0.14s;
}
.q-slider__pin {
  opacity: 0;
  white-space: nowrap;
  transition: opacity 0.28s ease-out;
  transition-delay: 0.14s;
}
.q-slider__pin:before {
  content: "";
  width: 0;
  height: 0;
  position: absolute;
}
.q-slider__pin--h:before {
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  left: 50%;
  transform: translateX(-50%);
}
.q-slider__pin--h-standard {
  bottom: 100%;
}
.q-slider__pin--h-standard:before {
  bottom: 2px;
  border-top: 6px solid currentColor;
}
.q-slider__pin--h-switched {
  top: 100%;
}
.q-slider__pin--h-switched:before {
  top: 2px;
  border-bottom: 6px solid currentColor;
}
.q-slider__pin--v {
  top: 0;
}
.q-slider__pin--v:before {
  top: 50%;
  transform: translateY(-50%);
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
}
.q-slider__pin--v-standard {
  left: 100%;
}
.q-slider__pin--v-standard:before {
  left: 2px;
  border-right: 6px solid currentColor;
}
.q-slider__pin--v-switched {
  right: 100%;
}
.q-slider__pin--v-switched:before {
  right: 2px;
  border-left: 6px solid currentColor;
}
.q-slider__label {
  z-index: 1;
  white-space: nowrap;
  position: absolute;
}
.q-slider__label--h {
  left: 50%;
  transform: translateX(-50%);
}
.q-slider__label--h-standard {
  bottom: 7px;
}
.q-slider__label--h-switched {
  top: 7px;
}
.q-slider__label--v {
  top: 50%;
  transform: translateY(-50%);
}
.q-slider__label--v-standard {
  left: 7px;
}
.q-slider__label--v-switched {
  right: 7px;
}
.q-slider__text-container {
  min-height: 25px;
  padding: 2px 8px;
  border-radius: 4px;
  background: currentColor;
  position: relative;
  text-align: center;
}
.q-slider__text {
  color: #fff;
  font-size: 12px;
}
.q-slider--no-value .q-slider__thumb,
.q-slider--no-value .q-slider__inner,
.q-slider--no-value .q-slider__selection {
  opacity: 0;
}
.q-slider--focus .q-slider__focus-ring, body.desktop .q-slider.q-slider--editable .q-slider__track-container:hover .q-slider__focus-ring {
  background: currentColor;
  transform: scale3d(1.55, 1.55, 1);
  opacity: 0.25;
}
.q-slider--focus .q-slider__thumb,
.q-slider--focus .q-slider__inner,
.q-slider--focus .q-slider__selection, body.desktop .q-slider.q-slider--editable .q-slider__track-container:hover .q-slider__thumb,
body.desktop .q-slider.q-slider--editable .q-slider__track-container:hover .q-slider__inner,
body.desktop .q-slider.q-slider--editable .q-slider__track-container:hover .q-slider__selection {
  opacity: 1;
}
.q-slider--inactive .q-slider__thumb--h {
  transition: left 0.28s, right 0.28s;
}
.q-slider--inactive .q-slider__thumb--v {
  transition: top 0.28s, bottom 0.28s;
}
.q-slider--inactive .q-slider__selection {
  transition: width 0.28s, left 0.28s, right 0.28s, height 0.28s, top 0.28s, bottom 0.28s;
}
.q-slider--inactive .q-slider__text-container {
  transition: transform 0.28s;
}
.q-slider--active {
  cursor: grabbing;
}
.q-slider--active .q-slider__thumb-shape {
  transform: scale(1.5);
}
.q-slider--active .q-slider__focus-ring, .q-slider--active.q-slider--label .q-slider__thumb-shape {
  transform: scale(0) !important;
}
body.desktop .q-slider.q-slider--enabled .q-slider__track-container:hover .q-slider__pin {
  opacity: 1;
}
.q-slider--label.q-slider--active .q-slider__pin,
.q-slider--label .q-slider--focus .q-slider__pin, .q-slider--label.q-slider--label-always .q-slider__pin {
  opacity: 1;
}
.q-slider--dark .q-slider__track {
  background: rgba(255, 255, 255, 0.1);
}
.q-slider--dark .q-slider__inner {
  background: rgba(255, 255, 255, 0.1);
}
.q-slider--dark .q-slider__markers {
  color: rgba(255, 255, 255, 0.3);
}
.q-slider--dense .q-slider__track-container--h {
  padding: 6px 0;
}
.q-slider--dense .q-slider__track-container--v {
  padding: 0 6px;
}
.q-space {
  flex-grow: 1 !important;
}
.q-spinner {
  vertical-align: middle;
}
.q-spinner-mat {
  animation: q-spin 2s linear infinite;
  transform-origin: center center;
}
.q-spinner-mat .path {
  stroke-dasharray: 1, 200 /* rtl:ignore */;
  stroke-dashoffset: 0 /* rtl:ignore */;
  animation: q-mat-dash 1.5s ease-in-out infinite;
}
@keyframes q-spin {
  0% {
    transform: rotate3d(0, 0, 1, 0deg) /* rtl:ignore */;
  }
  25% {
    transform: rotate3d(0, 0, 1, 90deg) /* rtl:ignore */;
  }
  50% {
    transform: rotate3d(0, 0, 1, 180deg) /* rtl:ignore */;
  }
  75% {
    transform: rotate3d(0, 0, 1, 270deg) /* rtl:ignore */;
  }
  100% {
    transform: rotate3d(0, 0, 1, 359deg) /* rtl:ignore */;
  }
}
@keyframes q-mat-dash {
  0% {
    stroke-dasharray: 1, 200;
    stroke-dashoffset: 0;
  }
  50% {
    stroke-dasharray: 89, 200;
    stroke-dashoffset: -35px;
  }
  100% {
    stroke-dasharray: 89, 200;
    stroke-dashoffset: -124px;
  }
}
.q-splitter__panel {
  position: relative;
  z-index: 0;
}
.q-splitter__panel > .q-splitter {
  width: 100%;
  height: 100%;
}
.q-splitter__separator {
  background-color: rgba(0, 0, 0, 0.12);
  user-select: none;
  position: relative;
  z-index: 1;
}
.q-splitter__separator-area > * {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
.q-splitter--dark .q-splitter__separator {
  background-color: rgba(255, 255, 255, 0.28);
}
.q-splitter--vertical > .q-splitter__panel {
  height: 100%;
}
.q-splitter--vertical.q-splitter--active {
  cursor: col-resize;
}
.q-splitter--vertical > .q-splitter__separator {
  width: 1px;
}
.q-splitter--vertical > .q-splitter__separator > div {
  left: -6px;
  right: -6px;
}
.q-splitter--vertical.q-splitter--workable > .q-splitter__separator {
  cursor: col-resize;
}
.q-splitter--horizontal > .q-splitter__panel {
  width: 100%;
}
.q-splitter--horizontal.q-splitter--active {
  cursor: row-resize;
}
.q-splitter--horizontal > .q-splitter__separator {
  height: 1px;
}
.q-splitter--horizontal > .q-splitter__separator > div {
  top: -6px;
  bottom: -6px;
}
.q-splitter--horizontal.q-splitter--workable > .q-splitter__separator {
  cursor: row-resize;
}
.q-splitter__before, .q-splitter__after {
  overflow: auto;
}
.q-stepper {
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  background: #fff;
}
.q-stepper__title {
  font-size: 14px;
  line-height: 18px;
  letter-spacing: 0.1px;
}
.q-stepper__caption {
  font-size: 12px;
  line-height: 14px;
}
.q-stepper__dot {
  contain: layout;
  margin-right: 8px;
  font-size: 14px;
  width: 24px;
  min-width: 24px;
  height: 24px;
  border-radius: 50%;
  background: currentColor;
}
.q-stepper__dot span {
  color: #fff;
}
.q-stepper__tab {
  padding: 8px 24px;
  font-size: 14px;
  color: #9e9e9e;
  flex-direction: row;
}
.q-stepper--dark .q-stepper__dot span {
  color: #000;
}
.q-stepper__tab--navigation {
  user-select: none;
  cursor: pointer;
}
.q-stepper__tab--active, .q-stepper__tab--done {
  color: var(--q-primary);
}
.q-stepper__tab--active .q-stepper__dot, .q-stepper__tab--active .q-stepper__label, .q-stepper__tab--done .q-stepper__dot, .q-stepper__tab--done .q-stepper__label {
  text-shadow: 0 0 0 currentColor;
}
.q-stepper__tab--disabled .q-stepper__dot {
  background: rgba(0, 0, 0, 0.22);
}
.q-stepper__tab--disabled .q-stepper__label {
  color: rgba(0, 0, 0, 0.32);
}
.q-stepper__tab--error {
  color: var(--q-negative);
}
.q-stepper__tab--error-with-icon .q-stepper__dot {
  background: transparent !important;
}
.q-stepper__tab--error-with-icon .q-stepper__dot span {
  color: currentColor;
  font-size: 24px;
}
.q-stepper__header {
  border-top-left-radius: inherit;
  border-top-right-radius: inherit;
}
.q-stepper__header--border {
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
}
.q-stepper__header--standard-labels .q-stepper__tab {
  min-height: 72px;
  justify-content: center;
}
.q-stepper__header--standard-labels .q-stepper__tab:first-child {
  justify-content: flex-start;
}
.q-stepper__header--standard-labels .q-stepper__tab:last-child {
  justify-content: flex-end;
}
.q-stepper__header--standard-labels .q-stepper__tab:only-child {
  justify-content: center;
}
.q-stepper__header--standard-labels .q-stepper__dot:after {
  display: none;
}
.q-stepper__header--alternative-labels .q-stepper__tab {
  min-height: 104px;
  padding: 24px 32px;
  flex-direction: column;
  justify-content: flex-start;
}
.q-stepper__header--alternative-labels .q-stepper__dot {
  margin-right: 0;
}
.q-stepper__header--alternative-labels .q-stepper__label {
  margin-top: 8px;
  text-align: center;
}
.q-stepper__header--alternative-labels .q-stepper__label:before, .q-stepper__header--alternative-labels .q-stepper__label:after {
  display: none;
}
.q-stepper__header--contracted {
  min-height: 72px;
}
.q-stepper__header--contracted.q-stepper__header--alternative-labels .q-stepper__tab {
  min-height: 72px;
}
.q-stepper__header--contracted.q-stepper__header--alternative-labels .q-stepper__tab:first-child {
  align-items: flex-start;
}
.q-stepper__header--contracted.q-stepper__header--alternative-labels .q-stepper__tab:last-child {
  align-items: flex-end;
}
.q-stepper__header--contracted .q-stepper__tab {
  padding: 24px 0;
}
.q-stepper__header--contracted .q-stepper__tab:first-child .q-stepper__dot {
  transform: translateX(24px);
}
.q-stepper__header--contracted .q-stepper__tab:last-child .q-stepper__dot {
  transform: translateX(-24px);
}
.q-stepper__header--contracted .q-stepper__tab:not(:last-child) .q-stepper__dot:after {
  display: block !important;
}
.q-stepper__header--contracted .q-stepper__dot {
  margin: 0;
}
.q-stepper__header--contracted .q-stepper__label {
  display: none;
}
.q-stepper__nav {
  padding-top: 24px;
}
.q-stepper--bordered {
  border: 1px solid rgba(0, 0, 0, 0.12);
}
.q-stepper--horizontal .q-stepper__step-inner {
  padding: 24px;
}
.q-stepper--horizontal .q-stepper__tab:first-child {
  border-top-left-radius: inherit;
}
.q-stepper--horizontal .q-stepper__tab:last-child {
  border-top-right-radius: inherit;
}
.q-stepper--horizontal .q-stepper__tab:first-child .q-stepper__dot:before,
.q-stepper--horizontal .q-stepper__tab:last-child .q-stepper__label:after,
.q-stepper--horizontal .q-stepper__tab:last-child .q-stepper__dot:after {
  display: none;
}
.q-stepper--horizontal .q-stepper__tab {
  overflow: hidden;
}
.q-stepper--horizontal .q-stepper__line {
  contain: layout;
}
.q-stepper--horizontal .q-stepper__line:before, .q-stepper--horizontal .q-stepper__line:after {
  position: absolute;
  top: 50%;
  height: 1px;
  width: 100vw;
  background: rgba(0, 0, 0, 0.12);
}
.q-stepper--horizontal .q-stepper__label:after, .q-stepper--horizontal .q-stepper__dot:after {
  content: "";
  left: 100%;
  margin-left: 8px;
}
.q-stepper--horizontal .q-stepper__dot:before {
  content: "";
  right: 100%;
  margin-right: 8px;
}
.q-stepper--horizontal > .q-stepper__nav {
  padding: 0 24px 24px;
}
.q-stepper--vertical {
  padding: 16px 0;
}
.q-stepper--vertical .q-stepper__tab {
  padding: 12px 24px;
}
.q-stepper--vertical .q-stepper__title {
  line-height: 18px;
}
.q-stepper--vertical .q-stepper__step-inner {
  padding: 0 24px 32px 60px;
}
.q-stepper--vertical > .q-stepper__nav {
  padding: 24px 24px 0;
}
.q-stepper--vertical .q-stepper__step {
  overflow: hidden;
}
.q-stepper--vertical .q-stepper__dot {
  margin-right: 12px;
}
.q-stepper--vertical .q-stepper__dot:before, .q-stepper--vertical .q-stepper__dot:after {
  content: "";
  position: absolute;
  left: 50%;
  width: 1px;
  height: 99999px;
  background: rgba(0, 0, 0, 0.12);
}
.q-stepper--vertical .q-stepper__dot:before {
  bottom: 100%;
  margin-bottom: 8px;
}
.q-stepper--vertical .q-stepper__dot:after {
  top: 100%;
  margin-top: 8px;
}
.q-stepper--vertical .q-stepper__step:first-child .q-stepper__dot:before,
.q-stepper--vertical .q-stepper__step:last-child .q-stepper__dot:after {
  display: none;
}
.q-stepper--vertical .q-stepper__step:last-child .q-stepper__step-inner {
  padding-bottom: 8px;
}
.q-stepper--dark.q-stepper--bordered,
.q-stepper--dark .q-stepper__header--border {
  border-color: rgba(255, 255, 255, 0.28);
}
.q-stepper--dark.q-stepper--horizontal .q-stepper__line:before, .q-stepper--dark.q-stepper--horizontal .q-stepper__line:after {
  background: rgba(255, 255, 255, 0.28);
}
.q-stepper--dark.q-stepper--vertical .q-stepper__dot:before, .q-stepper--dark.q-stepper--vertical .q-stepper__dot:after {
  background: rgba(255, 255, 255, 0.28);
}
.q-stepper--dark .q-stepper__tab--disabled {
  color: rgba(255, 255, 255, 0.28);
}
.q-stepper--dark .q-stepper__tab--disabled .q-stepper__dot {
  background: rgba(255, 255, 255, 0.28);
}
.q-stepper--dark .q-stepper__tab--disabled .q-stepper__label {
  color: rgba(255, 255, 255, 0.54);
}
.q-tab-panels {
  background: #fff;
}
.q-tab-panel {
  padding: 16px;
}
.q-markup-table {
  overflow: auto;
  background: #fff;
}
.q-table {
  width: 100%;
  max-width: 100%;
  border-collapse: separate;
  border-spacing: 0;
}
.q-table thead tr, .q-table tbody td {
  height: 48px;
}
.q-table th {
  font-weight: 500;
  font-size: 12px;
  user-select: none;
}
.q-table th.sortable {
  cursor: pointer;
}
.q-table th.sortable:hover .q-table__sort-icon {
  opacity: 0.64;
}
.q-table th.sorted .q-table__sort-icon {
  opacity: 0.86 !important;
}
.q-table th.sort-desc .q-table__sort-icon {
  transform: rotate(180deg);
}
.q-table th, .q-table td {
  padding: 7px 16px;
  background-color: inherit;
}
.q-table thead, .q-table td, .q-table th {
  border-style: solid;
  border-width: 0;
}
.q-table tbody td {
  font-size: 13px;
}
.q-table__card {
  color: #000;
  background-color: #fff;
  border-radius: 4px;
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
}
.q-table__card .q-table__middle {
  flex: 1 1 auto;
}
.q-table__card .q-table__top,
.q-table__card .q-table__bottom {
  flex: 0 0 auto;
}
.q-table__container {
  position: relative;
}
.q-table__container > div:first-child {
  border-top-left-radius: inherit;
  border-top-right-radius: inherit;
}
.q-table__container > div:last-child {
  border-bottom-left-radius: inherit;
  border-bottom-right-radius: inherit;
}
.q-table__container > .q-inner-loading {
  border-radius: inherit !important;
}
.q-table__top {
  padding: 12px 16px;
}
.q-table__top .q-table__control {
  flex-wrap: wrap;
}
.q-table__title {
  font-size: 20px;
  letter-spacing: 0.005em;
  font-weight: 400;
}
.q-table__separator {
  min-width: 8px !important;
}
.q-table__progress {
  height: 0 !important;
}
.q-table__progress th {
  padding: 0 !important;
  border: 0 !important;
}
.q-table__progress .q-linear-progress {
  position: absolute;
  bottom: 0;
}
.q-table__middle {
  max-width: 100%;
}
.q-table__bottom {
  min-height: 50px;
  padding: 4px 14px 4px 16px;
  font-size: 12px;
}
.q-table__bottom .q-table__control {
  min-height: 24px;
}
.q-table__bottom-nodata-icon {
  font-size: 200%;
  margin-right: 8px;
}
.q-table__bottom-item {
  margin-right: 16px;
}
.q-table__control {
  display: flex;
  align-items: center;
}
.q-table__sort-icon {
  transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);
  opacity: 0;
  font-size: 120%;
}
.q-table__sort-icon--left, .q-table__sort-icon--center {
  margin-left: 4px;
}
.q-table__sort-icon--right {
  margin-right: 4px;
}
.q-table--col-auto-width {
  width: 1px;
}
.q-table--flat {
  box-shadow: none;
}
.q-table--bordered {
  border: 1px solid rgba(0, 0, 0, 0.12);
}
.q-table--square {
  border-radius: 0;
}
.q-table__linear-progress {
  height: 2px;
}
.q-table--no-wrap th, .q-table--no-wrap td {
  white-space: nowrap;
}
.q-table--grid {
  box-shadow: none;
  border-radius: 4px;
}
.q-table--grid .q-table__top {
  padding-bottom: 4px;
}
.q-table--grid .q-table__middle {
  min-height: 2px;
  margin-bottom: 4px;
}
.q-table--grid .q-table__middle thead, .q-table--grid .q-table__middle thead th {
  border: 0 !important;
}
.q-table--grid .q-table__linear-progress {
  bottom: 0;
}
.q-table--grid .q-table__bottom {
  border-top: 0;
}
.q-table--grid .q-table__grid-content {
  flex: 1 1 auto;
}
.q-table--grid.fullscreen {
  background: inherit;
}
.q-table__grid-item-card {
  vertical-align: top;
  padding: 12px;
}
.q-table__grid-item-card .q-separator {
  margin: 12px 0;
}
.q-table__grid-item-row + .q-table__grid-item-row {
  margin-top: 8px;
}
.q-table__grid-item-title {
  opacity: 0.54;
  font-weight: 500;
  font-size: 12px;
}
.q-table__grid-item-value {
  font-size: 13px;
}
.q-table__grid-item {
  padding: 4px;
  transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);
}
.q-table__grid-item--selected {
  transform: scale(0.95);
}
/* * Separators
 * */
.q-table--horizontal-separator thead th, .q-table--horizontal-separator tbody tr:not(:last-child) > td, .q-table--cell-separator thead th, .q-table--cell-separator tbody tr:not(:last-child) > td {
  border-bottom-width: 1px;
}
.q-table--vertical-separator td, .q-table--vertical-separator th, .q-table--cell-separator td, .q-table--cell-separator th {
  border-left-width: 1px;
}
.q-table--vertical-separator thead tr:last-child th, .q-table--vertical-separator.q-table--loading tr:nth-last-child(2) th, .q-table--cell-separator thead tr:last-child th, .q-table--cell-separator.q-table--loading tr:nth-last-child(2) th {
  border-bottom-width: 1px;
}
.q-table--vertical-separator td:first-child, .q-table--vertical-separator th:first-child, .q-table--cell-separator td:first-child, .q-table--cell-separator th:first-child {
  border-left: 0;
}
.q-table--vertical-separator .q-table__top, .q-table--cell-separator .q-table__top {
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
}
/* * dense size
 * */
.q-table--dense .q-table__top {
  padding: 6px 16px;
}
.q-table--dense .q-table__bottom {
  min-height: 33px;
}
.q-table--dense .q-table__sort-icon {
  font-size: 110%;
}
.q-table--dense .q-table th, .q-table--dense .q-table td {
  padding: 4px 8px;
}
.q-table--dense .q-table thead tr, .q-table--dense .q-table tbody tr, .q-table--dense .q-table tbody td {
  height: 28px;
}
.q-table--dense .q-table th:first-child, .q-table--dense .q-table td:first-child {
  padding-left: 16px;
}
.q-table--dense .q-table th:last-child, .q-table--dense .q-table td:last-child {
  padding-right: 16px;
}
.q-table--dense .q-table__bottom-item {
  margin-right: 8px;
}
.q-table--dense .q-table__select .q-field__control, .q-table--dense .q-table__select .q-field__native {
  min-height: 24px;
  padding: 0;
}
.q-table--dense .q-table__select .q-field__marginal {
  height: 24px;
}
/* * On light background
 * */
.q-table__bottom {
  border-top: 1px solid rgba(0, 0, 0, 0.12);
}
.q-table thead, .q-table tr, .q-table th, .q-table td {
  border-color: rgba(0, 0, 0, 0.12);
}
.q-table tbody td {
  position: relative;
}
.q-table tbody td:before, .q-table tbody td:after {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
}
.q-table tbody td:before {
  background: rgba(0, 0, 0, 0.03);
}
.q-table tbody td:after {
  background: rgba(0, 0, 0, 0.06);
}
.q-table tbody tr.selected td:after {
  content: "";
}
body.desktop .q-table > tbody > tr:not(.q-tr--no-hover):hover > td:not(.q-td--no-hover):before {
  content: "";
}
/* * On dark background
 * */
.q-table__card--dark, .q-table--dark {
  border-color: rgba(255, 255, 255, 0.28);
}
.q-table--dark .q-table__bottom, .q-table--dark thead, .q-table--dark tr, .q-table--dark th, .q-table--dark td {
  border-color: rgba(255, 255, 255, 0.28);
}
.q-table--dark tbody td:before {
  background: rgba(255, 255, 255, 0.07);
}
.q-table--dark tbody td:after {
  background: rgba(255, 255, 255, 0.1);
}
.q-table--dark.q-table--vertical-separator .q-table__top, .q-table--dark.q-table--cell-separator .q-table__top {
  border-color: rgba(255, 255, 255, 0.28);
}
.q-tab {
  padding: 0 16px;
  min-height: 48px;
  transition: color 0.3s, background-color 0.3s;
  text-transform: uppercase;
  white-space: nowrap;
  color: inherit;
  text-decoration: none;
}
.q-tab--full {
  min-height: 72px;
}
.q-tab--no-caps {
  text-transform: none;
}
.q-tab__content {
  height: inherit;
  padding: 4px 0;
  min-width: 40px;
}
.q-tab__content--inline .q-tab__icon + .q-tab__label {
  padding-left: 8px;
}
.q-tab__content .q-chip--floating {
  top: 0;
  right: -16px;
}
.q-tab__icon {
  width: 24px;
  height: 24px;
  font-size: 24px;
}
.q-tab__label {
  font-size: 14px;
  line-height: 1.715em;
  font-weight: 500;
}
.q-tab .q-badge {
  top: 3px;
  right: -12px;
}
.q-tab__alert, .q-tab__alert-icon {
  position: absolute;
}
.q-tab__alert {
  top: 7px;
  right: -9px;
  height: 10px;
  width: 10px;
  border-radius: 50%;
  background: currentColor;
}
.q-tab__alert-icon {
  top: 2px;
  right: -12px;
  font-size: 18px;
}
.q-tab__indicator {
  opacity: 0;
  height: 2px;
  background: currentColor;
}
.q-tab--active .q-tab__indicator {
  opacity: 1;
  transform-origin: left /* rtl:ignore */;
}
.q-tab--inactive {
  opacity: 0.85;
}
.q-tabs {
  position: relative;
  transition: color 0.3s, background-color 0.3s;
}
.q-tabs--scrollable.q-tabs__arrows--outside.q-tabs--horizontal {
  padding-left: 36px;
  padding-right: 36px;
}
.q-tabs--scrollable.q-tabs__arrows--outside.q-tabs--vertical {
  padding-top: 36px;
  padding-bottom: 36px;
}
.q-tabs--scrollable.q-tabs__arrows--outside .q-tabs__arrow--faded {
  opacity: 0.3;
  pointer-events: none;
}
.q-tabs--scrollable.q-tabs__arrows--inside .q-tabs__arrow--faded {
  display: none;
}
.q-tabs--not-scrollable .q-tabs__arrow {
  display: none;
}
.q-tabs--not-scrollable .q-tabs__content {
  border-radius: inherit;
}
.q-tabs__arrow {
  cursor: pointer;
  font-size: 32px;
  min-width: 36px;
  text-shadow: 0 0 3px #fff, 0 0 1px #fff, 0 0 1px #000;
  transition: opacity 0.3s;
}
.q-tabs__content {
  overflow: hidden;
  flex: 1 1 auto;
}
.q-tabs__content--align-center {
  justify-content: center;
}
.q-tabs__content--align-right {
  justify-content: flex-end;
}
.q-tabs__content--align-justify .q-tab {
  flex: 1 1 auto;
}
.q-tabs__offset {
  display: none;
}
.q-tabs--horizontal .q-tabs__arrow {
  height: 100%;
}
.q-tabs--horizontal .q-tabs__arrow--left {
  top: 0;
  left: 0 /* rtl:ignore */;
  bottom: 0;
}
.q-tabs--horizontal .q-tabs__arrow--right {
  top: 0;
  right: 0 /* rtl:ignore */;
  bottom: 0;
}
.q-tabs--vertical {
  display: block !important;
  height: 100%;
}
.q-tabs--vertical .q-tabs__content {
  display: block !important;
  height: 100%;
}
.q-tabs--vertical .q-tabs__arrow {
  width: 100%;
  height: 36px;
  text-align: center;
}
.q-tabs--vertical .q-tabs__arrow--left {
  top: 0;
  left: 0;
  right: 0;
}
.q-tabs--vertical .q-tabs__arrow--right {
  left: 0;
  right: 0;
  bottom: 0;
}
.q-tabs--vertical .q-tab {
  padding: 0 8px;
}
.q-tabs--vertical .q-tab__indicator {
  height: unset;
  width: 2px;
}
.q-tabs--vertical.q-tabs--not-scrollable .q-tabs__content {
  height: 100%;
}
.q-tabs--vertical.q-tabs--dense .q-tab__content {
  min-width: 24px;
}
.q-tabs--dense .q-tab {
  min-height: 36px;
}
.q-tabs--dense .q-tab--full {
  min-height: 52px;
}
.q-time {
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  background: #fff;
  outline: 0;
  width: 290px;
  min-width: 290px;
  max-width: 100%;
}
.q-time--bordered {
  border: 1px solid rgba(0, 0, 0, 0.12);
}
.q-time__header {
  border-top-left-radius: inherit;
  color: #fff;
  background-color: var(--q-primary);
  padding: 16px;
  font-weight: 300;
}
.q-time__actions {
  padding: 0 16px 16px;
}
.q-time__header-label {
  font-size: 28px;
  line-height: 1;
  letter-spacing: -0.00833em;
}
.q-time__header-label > div + div {
  margin-left: 4px;
}
.q-time__link {
  opacity: 0.56;
  outline: 0;
  transition: opacity 0.3s ease-out;
}
.q-time__link--active, .q-time__link:hover, .q-time__link:focus {
  opacity: 1;
}
.q-time__header-ampm {
  font-size: 16px;
  letter-spacing: 0.1em;
}
.q-time__content {
  padding: 16px;
}
.q-time__content:before {
  content: "";
  display: block;
  padding-bottom: 100%;
}
.q-time__container-parent {
  padding: 16px;
}
.q-time__container-child {
  border-radius: 50%;
  background: rgba(0, 0, 0, 0.12);
}
.q-time__clock {
  padding: 24px;
  width: 100%;
  height: 100%;
  max-width: 100%;
  max-height: 100%;
  font-size: 14px;
}
.q-time__clock-circle {
  position: relative;
}
.q-time__clock-center {
  height: 6px;
  width: 6px;
  margin: auto;
  border-radius: 50%;
  min-height: 0;
  background: currentColor;
}
.q-time__clock-pointer {
  width: 2px;
  height: 50%;
  transform-origin: 0 0 /* rtl:ignore */;
  min-height: 0;
  position: absolute;
  left: 50%;
  right: 0;
  bottom: 0;
  color: var(--q-primary);
  background: currentColor;
  transform: translateX(-50%);
}
.q-time__clock-pointer:before, .q-time__clock-pointer:after {
  content: "";
  position: absolute;
  left: 50%;
  border-radius: 50%;
  background: currentColor;
  transform: translateX(-50%);
}
.q-time__clock-pointer:before {
  bottom: -4px;
  width: 8px;
  height: 8px;
}
.q-time__clock-pointer:after {
  top: -3px;
  height: 6px;
  width: 6px;
}
.q-time__clock-position {
  position: absolute;
  min-height: 32px;
  width: 32px;
  height: 32px;
  font-size: 12px;
  line-height: 32px;
  margin: 0;
  padding: 0;
  transform: translate(-50%, -50%) /* rtl:ignore */;
  border-radius: 50%;
}
.q-time__clock-position--disable {
  opacity: 0.4;
}
.q-time__clock-position--active {
  background-color: var(--q-primary);
  color: #fff;
}
.q-time__clock-pos-0 {
  top: 0%;
  left: 50% /* rtl:ignore */;
}
.q-time__clock-pos-1 {
  top: 6.7%;
  left: 75% /* rtl:ignore */;
}
.q-time__clock-pos-2 {
  top: 25%;
  left: 93.3% /* rtl:ignore */;
}
.q-time__clock-pos-3 {
  top: 50%;
  left: 100% /* rtl:ignore */;
}
.q-time__clock-pos-4 {
  top: 75%;
  left: 93.3% /* rtl:ignore */;
}
.q-time__clock-pos-5 {
  top: 93.3%;
  left: 75% /* rtl:ignore */;
}
.q-time__clock-pos-6 {
  top: 100%;
  left: 50% /* rtl:ignore */;
}
.q-time__clock-pos-7 {
  top: 93.3%;
  left: 25% /* rtl:ignore */;
}
.q-time__clock-pos-8 {
  top: 75%;
  left: 6.7% /* rtl:ignore */;
}
.q-time__clock-pos-9 {
  top: 50%;
  left: 0% /* rtl:ignore */;
}
.q-time__clock-pos-10 {
  top: 25%;
  left: 6.7% /* rtl:ignore */;
}
.q-time__clock-pos-11 {
  top: 6.7%;
  left: 25% /* rtl:ignore */;
}
.q-time__clock-pos-12 {
  top: 15%;
  left: 50% /* rtl:ignore */;
}
.q-time__clock-pos-13 {
  top: 19.69%;
  left: 67.5% /* rtl:ignore */;
}
.q-time__clock-pos-14 {
  top: 32.5%;
  left: 80.31% /* rtl:ignore */;
}
.q-time__clock-pos-15 {
  top: 50%;
  left: 85% /* rtl:ignore */;
}
.q-time__clock-pos-16 {
  top: 67.5%;
  left: 80.31% /* rtl:ignore */;
}
.q-time__clock-pos-17 {
  top: 80.31%;
  left: 67.5% /* rtl:ignore */;
}
.q-time__clock-pos-18 {
  top: 85%;
  left: 50% /* rtl:ignore */;
}
.q-time__clock-pos-19 {
  top: 80.31%;
  left: 32.5% /* rtl:ignore */;
}
.q-time__clock-pos-20 {
  top: 67.5%;
  left: 19.69% /* rtl:ignore */;
}
.q-time__clock-pos-21 {
  top: 50%;
  left: 15% /* rtl:ignore */;
}
.q-time__clock-pos-22 {
  top: 32.5%;
  left: 19.69% /* rtl:ignore */;
}
.q-time__clock-pos-23 {
  top: 19.69%;
  left: 32.5% /* rtl:ignore */;
}
.q-time__now-button {
  background-color: var(--q-primary);
  color: #fff;
  top: 12px;
  right: 12px;
}
.q-time.disabled .q-time__header-ampm, .q-time.disabled .q-time__content, .q-time--readonly .q-time__header-ampm, .q-time--readonly .q-time__content {
  pointer-events: none;
}
.q-time--portrait {
  display: inline-flex;
  flex-direction: column;
}
.q-time--portrait .q-time__header {
  border-top-right-radius: inherit;
  min-height: 86px;
}
.q-time--portrait .q-time__header-ampm {
  margin-left: 12px;
}
.q-time--portrait.q-time--bordered .q-time__content {
  margin: 1px 0;
}
.q-time--landscape {
  display: inline-flex;
  align-items: stretch;
  min-width: 420px;
}
.q-time--landscape > div {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.q-time--landscape .q-time__header {
  border-bottom-left-radius: inherit;
  min-width: 156px;
}
.q-time--landscape .q-time__header-ampm {
  margin-top: 12px;
}
.q-time--dark {
  border-color: rgba(255, 255, 255, 0.28);
}
.q-timeline {
  padding: 0;
  width: 100%;
  list-style: none;
}
.q-timeline--dark {
  color: #fff;
}
.q-timeline--dark .q-timeline__subtitle {
  opacity: 0.7;
}
.q-timeline__content {
  padding-bottom: 24px;
}
.q-timeline__title {
  margin-top: 0;
  margin-bottom: 16px;
}
.q-timeline__subtitle {
  font-size: 12px;
  margin-bottom: 8px;
  opacity: 0.6;
  text-transform: uppercase;
  letter-spacing: 1px;
  font-weight: 700;
}
.q-timeline__dot {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 15px;
}
.q-timeline__dot:before, .q-timeline__dot:after {
  content: "";
  background: currentColor;
  display: block;
  position: absolute;
}
.q-timeline__dot:before {
  border: 3px solid transparent;
  border-radius: 100%;
  height: 15px;
  width: 15px;
  top: 4px;
  left: 0;
  transition: background 0.3s ease-in-out, border 0.3s ease-in-out;
}
.q-timeline__dot:after {
  width: 3px;
  opacity: 0.4;
  top: 24px;
  bottom: 0;
  left: 6px;
}
.q-timeline__dot .q-icon {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  font-size: 16px;
  height: 38px;
  line-height: 38px;
  width: 100%;
  color: #fff;
}
.q-timeline__dot .q-icon > svg,
.q-timeline__dot .q-icon > img {
  width: 1em;
  height: 1em;
}
.q-timeline__dot-img {
  position: absolute;
  top: 4px;
  left: 0;
  right: 0;
  height: 31px;
  width: 31px;
  background: currentColor;
  border-radius: 50%;
}
.q-timeline__heading {
  position: relative;
}
.q-timeline__heading:first-child .q-timeline__heading-title {
  padding-top: 0;
}
.q-timeline__heading:last-child .q-timeline__heading-title {
  padding-bottom: 0;
}
.q-timeline__heading-title {
  padding: 32px 0;
  margin: 0;
}
.q-timeline__entry {
  position: relative;
  line-height: 22px;
}
.q-timeline__entry:last-child {
  padding-bottom: 0 !important;
}
.q-timeline__entry:last-child .q-timeline__dot:after {
  content: none;
}
.q-timeline__entry--icon .q-timeline__dot {
  width: 31px;
}
.q-timeline__entry--icon .q-timeline__dot:before {
  height: 31px;
  width: 31px;
}
.q-timeline__entry--icon .q-timeline__dot:after {
  top: 41px;
  left: 14px;
}
.q-timeline__entry--icon .q-timeline__subtitle {
  padding-top: 8px;
}
.q-timeline--dense--right .q-timeline__entry {
  padding-left: 40px;
}
.q-timeline--dense--right .q-timeline__entry--icon .q-timeline__dot {
  left: -8px;
}
.q-timeline--dense--right .q-timeline__dot {
  left: 0;
}
.q-timeline--dense--left .q-timeline__heading {
  text-align: right;
}
.q-timeline--dense--left .q-timeline__entry {
  padding-right: 40px;
}
.q-timeline--dense--left .q-timeline__entry--icon .q-timeline__dot {
  right: -8px;
}
.q-timeline--dense--left .q-timeline__content, .q-timeline--dense--left .q-timeline__title, .q-timeline--dense--left .q-timeline__subtitle {
  text-align: right;
}
.q-timeline--dense--left .q-timeline__dot {
  right: 0;
}
.q-timeline--comfortable {
  display: table;
}
.q-timeline--comfortable .q-timeline__heading {
  display: table-row;
  font-size: 200%;
}
.q-timeline--comfortable .q-timeline__heading > div {
  display: table-cell;
}
.q-timeline--comfortable .q-timeline__entry {
  display: table-row;
  padding: 0;
}
.q-timeline--comfortable .q-timeline__entry--icon .q-timeline__content {
  padding-top: 8px;
}
.q-timeline--comfortable .q-timeline__subtitle, .q-timeline--comfortable .q-timeline__dot, .q-timeline--comfortable .q-timeline__content {
  display: table-cell;
  vertical-align: top;
}
.q-timeline--comfortable .q-timeline__subtitle {
  width: 35%;
}
.q-timeline--comfortable .q-timeline__dot {
  position: relative;
  min-width: 31px;
}
.q-timeline--comfortable--right .q-timeline__heading .q-timeline__heading-title {
  margin-left: -50px;
}
.q-timeline--comfortable--right .q-timeline__subtitle {
  text-align: right;
  padding-right: 30px;
}
.q-timeline--comfortable--right .q-timeline__content {
  padding-left: 30px;
}
.q-timeline--comfortable--right .q-timeline__entry--icon .q-timeline__dot {
  left: -8px;
}
.q-timeline--comfortable--left .q-timeline__heading {
  text-align: right;
}
.q-timeline--comfortable--left .q-timeline__heading .q-timeline__heading-title {
  margin-right: -50px;
}
.q-timeline--comfortable--left .q-timeline__subtitle {
  padding-left: 30px;
}
.q-timeline--comfortable--left .q-timeline__content {
  padding-right: 30px;
}
.q-timeline--comfortable--left .q-timeline__content, .q-timeline--comfortable--left .q-timeline__title {
  text-align: right;
}
.q-timeline--comfortable--left .q-timeline__entry--icon .q-timeline__dot {
  right: 0;
}
.q-timeline--comfortable--left .q-timeline__dot {
  right: -8px;
}
.q-timeline--loose .q-timeline__heading-title {
  text-align: center;
  margin-left: 0;
}
.q-timeline--loose .q-timeline__entry, .q-timeline--loose .q-timeline__subtitle, .q-timeline--loose .q-timeline__dot, .q-timeline--loose .q-timeline__content {
  display: block;
  margin: 0;
  padding: 0;
}
.q-timeline--loose .q-timeline__dot {
  position: absolute;
  left: 50%;
  margin-left: -7.15px;
}
.q-timeline--loose .q-timeline__entry {
  padding-bottom: 24px;
  overflow: hidden;
}
.q-timeline--loose .q-timeline__entry--icon .q-timeline__dot {
  margin-left: -15px;
}
.q-timeline--loose .q-timeline__entry--icon .q-timeline__subtitle {
  line-height: 38px;
}
.q-timeline--loose .q-timeline__entry--icon .q-timeline__content {
  padding-top: 8px;
}
.q-timeline--loose .q-timeline__entry--left .q-timeline__content, .q-timeline--loose .q-timeline__entry--right .q-timeline__subtitle {
  float: left;
  padding-right: 30px;
  text-align: right;
}
.q-timeline--loose .q-timeline__entry--left .q-timeline__subtitle, .q-timeline--loose .q-timeline__entry--right .q-timeline__content {
  float: right;
  text-align: left;
  padding-left: 30px;
}
.q-timeline--loose .q-timeline__subtitle, .q-timeline--loose .q-timeline__content {
  width: 50%;
}
.q-toggle {
  vertical-align: middle;
}
.q-toggle__native {
  width: 1px;
  height: 1px;
}
.q-toggle__track {
  height: 0.35em;
  border-radius: 0.175em;
  opacity: 0.38;
  background: currentColor;
}
.q-toggle__thumb {
  top: 0.25em;
  left: 0.25em;
  width: 0.5em;
  height: 0.5em;
  transition: left 0.22s cubic-bezier(0.4, 0, 0.2, 1);
  user-select: none;
  z-index: 0;
}
.q-toggle__thumb:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  border-radius: 50%;
  background: #fff;
  box-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
}
.q-toggle__thumb .q-icon {
  font-size: 0.3em;
  min-width: 1em;
  color: #000;
  opacity: 0.54;
  z-index: 1;
}
.q-toggle__inner {
  font-size: 40px;
  width: 1.4em;
  min-width: 1.4em;
  height: 1em;
  padding: 0.325em 0.3em;
  -webkit-print-color-adjust: exact;
}
.q-toggle__inner--indet .q-toggle__thumb {
  left: 0.45em;
}
.q-toggle__inner--truthy {
  color: var(--q-primary);
}
.q-toggle__inner--truthy .q-toggle__track {
  opacity: 0.54;
}
.q-toggle__inner--truthy .q-toggle__thumb {
  left: 0.65em;
}
.q-toggle__inner--truthy .q-toggle__thumb:after {
  background-color: currentColor;
}
.q-toggle__inner--truthy .q-toggle__thumb .q-icon {
  color: #fff;
  opacity: 1;
}
.q-toggle.disabled {
  opacity: 0.75 !important;
}
.q-toggle--dark .q-toggle__inner {
  color: #fff;
}
.q-toggle--dark .q-toggle__inner--truthy {
  color: var(--q-primary);
}
.q-toggle--dark .q-toggle__thumb:before {
  opacity: 0.32 !important;
}
.q-toggle--dense .q-toggle__inner {
  width: 0.8em;
  min-width: 0.8em;
  height: 0.5em;
  padding: 0.07625em 0;
}
.q-toggle--dense .q-toggle__thumb {
  top: 0;
  left: 0;
}
.q-toggle--dense .q-toggle__inner--indet .q-toggle__thumb {
  left: 0.15em;
}
.q-toggle--dense .q-toggle__inner--truthy .q-toggle__thumb {
  left: 0.3em;
}
.q-toggle--dense .q-toggle__label {
  padding-left: 0.5em;
}
.q-toggle--dense.reverse .q-toggle__label {
  padding-left: 0;
  padding-right: 0.5em;
}
body.desktop .q-toggle:not(.disabled) .q-toggle__thumb:before {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  border-radius: 50%;
  background: currentColor;
  opacity: 0.12;
  transform: scale3d(0, 0, 1);
  transition: transform 0.22s cubic-bezier(0, 0, 0.2, 1);
}
body.desktop .q-toggle:not(.disabled):focus .q-toggle__thumb:before, body.desktop .q-toggle:not(.disabled):hover .q-toggle__thumb:before {
  transform: scale3d(2, 2, 1);
}
body.desktop .q-toggle--dense:not(.disabled):focus .q-toggle__thumb:before, body.desktop .q-toggle--dense:not(.disabled):hover .q-toggle__thumb:before {
  transform: scale3d(1.5, 1.5, 1);
}
.q-toolbar {
  position: relative;
  padding: 0 12px;
  min-height: 50px;
  width: 100%;
}
.q-toolbar--inset {
  padding-left: 58px;
}
.q-toolbar .q-avatar {
  font-size: 38px;
}
.q-toolbar__title {
  flex: 1 1 0%;
  min-width: 1px;
  max-width: 100%;
  font-size: 21px;
  font-weight: normal;
  letter-spacing: 0.01em;
  padding: 0 12px;
}
.q-toolbar__title:first-child {
  padding-left: 0;
}
.q-toolbar__title:last-child {
  padding-right: 0;
}
.q-tooltip--style {
  font-size: 10px;
  color: #fafafa;
  background: #757575;
  border-radius: 4px;
  text-transform: none;
  font-weight: normal;
}
.q-tooltip {
  z-index: 9000;
  position: fixed !important;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 6px 10px;
}
@media (max-width: 599.98px) {
  .q-tooltip {
    font-size: 14px;
    padding: 8px 16px;
  }
}
.q-tree {
  position: relative;
  color: #9e9e9e;
}
.q-tree__node {
  padding: 0 0 3px 22px;
}
.q-tree__node:after {
  content: "";
  position: absolute;
  top: -3px;
  bottom: 0;
  width: 2px;
  right: auto;
  left: -13px;
  border-left: 1px solid currentColor;
}
.q-tree__node:last-child:after {
  display: none;
}
.q-tree__node--disabled {
  pointer-events: none;
}
.q-tree__node--disabled .disabled {
  opacity: 1 !important;
}
.q-tree__node--disabled > div,
.q-tree__node--disabled > i,
.q-tree__node--disabled > .disabled {
  opacity: 0.6 !important;
}
.q-tree__node--disabled > div .q-tree__node--disabled > div,
.q-tree__node--disabled > div .q-tree__node--disabled > i,
.q-tree__node--disabled > div .q-tree__node--disabled > .disabled,
.q-tree__node--disabled > i .q-tree__node--disabled > div,
.q-tree__node--disabled > i .q-tree__node--disabled > i,
.q-tree__node--disabled > i .q-tree__node--disabled > .disabled,
.q-tree__node--disabled > .disabled .q-tree__node--disabled > div,
.q-tree__node--disabled > .disabled .q-tree__node--disabled > i,
.q-tree__node--disabled > .disabled .q-tree__node--disabled > .disabled {
  opacity: 1 !important;
}
.q-tree__node-header:before {
  content: "";
  position: absolute;
  top: -3px;
  bottom: 50%;
  width: 31px;
  left: -35px;
  border-left: 1px solid currentColor;
  border-bottom: 1px solid currentColor;
}
.q-tree__children {
  padding-left: 25px;
}
.q-tree__node-body {
  padding: 5px 0 8px 5px;
}
.q-tree__node--parent {
  padding-left: 2px;
}
.q-tree__node--parent > .q-tree__node-header:before {
  width: 15px;
  left: -15px;
}
.q-tree__node--parent > .q-tree__node-collapsible > .q-tree__node-body {
  padding: 5px 0 8px 27px;
}
.q-tree__node--parent > .q-tree__node-collapsible > .q-tree__node-body:after {
  content: "";
  position: absolute;
  top: 0;
  width: 2px;
  height: 100%;
  right: auto;
  left: 12px;
  border-left: 1px solid currentColor;
  bottom: 50px;
}
.q-tree__node--link {
  cursor: pointer;
}
.q-tree__node-header {
  padding: 4px;
  margin-top: 3px;
  border-radius: 4px;
  outline: 0;
}
.q-tree__node-header-content {
  color: #000;
  transition: color 0.3s;
}
.q-tree__node--selected .q-tree__node-header-content {
  color: #9e9e9e;
}
.q-tree__icon, .q-tree__node-header-content .q-icon {
  font-size: 21px;
}
.q-tree__img {
  height: 42px;
  border-radius: 2px;
}
.q-tree__avatar, .q-tree__node-header-content .q-avatar {
  font-size: 28px;
  border-radius: 50%;
  width: 28px;
  height: 28px;
}
.q-tree__arrow, .q-tree__spinner {
  font-size: 16px;
  margin-right: 4px;
}
.q-tree__arrow {
  transition: transform 0.3s;
}
.q-tree__arrow--rotate {
  transform: rotate3d(0, 0, 1, 90deg);
}
.q-tree__tickbox {
  margin-right: 4px;
}
.q-tree > .q-tree__node {
  padding: 0;
}
.q-tree > .q-tree__node:after, .q-tree > .q-tree__node > .q-tree__node-header:before {
  display: none;
}
.q-tree > .q-tree__node--child > .q-tree__node-header {
  padding-left: 24px;
}
.q-tree--dark .q-tree__node-header-content {
  color: #fff;
}
.q-tree--no-connectors .q-tree__node:after,
.q-tree--no-connectors .q-tree__node-header:before,
.q-tree--no-connectors .q-tree__node-body:after {
  display: none !important;
}
.q-tree--dense > .q-tree__node--child > .q-tree__node-header {
  padding-left: 1px;
}
.q-tree--dense .q-tree__arrow, .q-tree--dense .q-tree__spinner {
  margin-right: 1px;
}
.q-tree--dense .q-tree__img {
  height: 32px;
}
.q-tree--dense .q-tree__tickbox {
  margin-right: 3px;
}
.q-tree--dense .q-tree__node {
  padding: 0;
}
.q-tree--dense .q-tree__node:after {
  top: 0;
  left: -8px;
}
.q-tree--dense .q-tree__node-header {
  margin-top: 0;
  padding: 1px;
}
.q-tree--dense .q-tree__node-header:before {
  top: 0;
  left: -8px;
  width: 8px;
}
.q-tree--dense .q-tree__node--child {
  padding-left: 17px;
}
.q-tree--dense .q-tree__node--child > .q-tree__node-header:before {
  left: -25px;
  width: 21px;
}
.q-tree--dense .q-tree__node-body {
  padding: 0 0 2px;
}
.q-tree--dense .q-tree__node--parent > .q-tree__node-collapsible > .q-tree__node-body {
  padding: 0 0 2px 20px;
}
.q-tree--dense .q-tree__node--parent > .q-tree__node-collapsible > .q-tree__node-body:after {
  left: 8px;
}
.q-tree--dense .q-tree__children {
  padding-left: 16px;
}
[dir=rtl] .q-tree__arrow {
  transform: rotate3d(0, 0, 1, 180deg) /* rtl:ignore */;
}
[dir=rtl] .q-tree__arrow--rotate {
  transform: rotate3d(0, 0, 1, 90deg) /* rtl:ignore */;
}
.q-uploader {
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  vertical-align: top;
  background: #fff;
  position: relative;
  width: 320px;
  max-height: 320px;
}
.q-uploader--bordered {
  border: 1px solid rgba(0, 0, 0, 0.12);
}
.q-uploader__input {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer !important;
  z-index: 1;
}
.q-uploader__input::-webkit-file-upload-button {
  cursor: pointer;
}
.q-uploader__file:before {
  content: "";
  border-top-left-radius: inherit;
  border-top-right-radius: inherit;
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  pointer-events: none;
  background: currentColor;
  opacity: 0.04;
}
.q-uploader__header {
  position: relative;
  border-top-left-radius: inherit;
  border-top-right-radius: inherit;
  background-color: var(--q-primary);
  color: #fff;
  width: 100%;
}
.q-uploader__spinner {
  font-size: 24px;
  margin-right: 4px;
}
.q-uploader__header-content {
  padding: 8px;
}
.q-uploader__dnd {
  outline: 1px dashed currentColor;
  outline-offset: -4px;
  background: rgba(255, 255, 255, 0.6);
}
.q-uploader__overlay {
  font-size: 36px;
  color: #000;
  background-color: rgba(255, 255, 255, 0.6);
}
.q-uploader__list {
  position: relative;
  border-bottom-left-radius: inherit;
  border-bottom-right-radius: inherit;
  padding: 8px;
  min-height: 60px;
  flex: 1 1 auto;
}
.q-uploader__file {
  border-radius: 4px 4px 0 0;
  border: 1px solid rgba(0, 0, 0, 0.12);
}
.q-uploader__file .q-circular-progress {
  font-size: 24px;
}
.q-uploader__file--img {
  color: #fff;
  height: 200px;
  min-width: 200px;
  background-position: 50% 50%;
  background-size: cover;
  background-repeat: no-repeat;
}
.q-uploader__file--img:before {
  content: none;
}
.q-uploader__file--img .q-circular-progress {
  color: #fff;
}
.q-uploader__file--img .q-uploader__file-header {
  padding-bottom: 24px;
  background: linear-gradient(to bottom, rgba(0, 0, 0, 0.7) 20%, rgba(255, 255, 255, 0));
}
.q-uploader__file + .q-uploader__file {
  margin-top: 8px;
}
.q-uploader__file-header {
  position: relative;
  padding: 4px 8px;
  border-top-left-radius: inherit;
  border-top-right-radius: inherit;
}
.q-uploader__file-header-content {
  padding-right: 8px;
}
.q-uploader__file-status {
  font-size: 24px;
  margin-right: 4px;
}
.q-uploader__title {
  font-size: 14px;
  font-weight: bold;
  line-height: 18px;
  word-break: break-word;
}
.q-uploader__subtitle {
  font-size: 12px;
  line-height: 18px;
}
.q-uploader--disable .q-uploader__header, .q-uploader--disable .q-uploader__list {
  pointer-events: none;
}
.q-uploader--dark {
  border-color: rgba(255, 255, 255, 0.28);
}
.q-uploader--dark .q-uploader__file {
  border-color: rgba(255, 255, 255, 0.28);
}
.q-uploader--dark .q-uploader__dnd, .q-uploader--dark .q-uploader__overlay {
  background: rgba(255, 255, 255, 0.3);
}
.q-uploader--dark .q-uploader__overlay {
  color: #fff;
}
img.responsive {
  max-width: 100%;
  height: auto;
}
.q-video {
  position: relative;
  overflow: hidden;
  border-radius: inherit;
}
.q-video iframe,
.q-video object,
.q-video embed {
  width: 100%;
  height: 100%;
}
.q-video--responsive {
  height: 0;
}
.q-video--responsive iframe,
.q-video--responsive object,
.q-video--responsive embed {
  position: absolute;
  top: 0;
  left: 0;
}
.q-virtual-scroll:focus {
  outline: 0;
}
.q-virtual-scroll__content {
  outline: none;
  contain: content;
}
.q-virtual-scroll__content > * {
  overflow-anchor: none;
}
.q-virtual-scroll__content > [data-q-vs-anchor] {
  overflow-anchor: auto;
}
.q-virtual-scroll__padding {
  background: linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 20%, rgba(128, 128, 128, 0.03) 20%, rgba(128, 128, 128, 0.08) 50%, rgba(128, 128, 128, 0.03) 80%, rgba(255, 255, 255, 0) 80%, rgba(255, 255, 255, 0)) /* rtl:ignore */;
  background-size: var(--q-virtual-scroll-item-width, 100%) var(--q-virtual-scroll-item-height, 50px) /* rtl:ignore */;
}
.q-table .q-virtual-scroll__padding tr {
  height: 0 !important;
}
.q-table .q-virtual-scroll__padding td {
  padding: 0 !important;
}
.q-virtual-scroll--horizontal {
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  align-items: stretch;
}
.q-virtual-scroll--horizontal .q-virtual-scroll__content {
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
}
.q-virtual-scroll--horizontal .q-virtual-scroll__padding, .q-virtual-scroll--horizontal .q-virtual-scroll__content, .q-virtual-scroll--horizontal .q-virtual-scroll__content > * {
  flex: 0 0 auto;
}
.q-virtual-scroll--horizontal .q-virtual-scroll__padding {
  background: linear-gradient(to left, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 20%, rgba(128, 128, 128, 0.03) 20%, rgba(128, 128, 128, 0.08) 50%, rgba(128, 128, 128, 0.03) 80%, rgba(255, 255, 255, 0) 80%, rgba(255, 255, 255, 0)) /* rtl:ignore */;
  background-size: var(--q-virtual-scroll-item-width, 50px) var(--q-virtual-scroll-item-height, 100%) /* rtl:ignore */;
}
/* Directives */
.q-ripple {
  position: absolute;
  top: 0;
  left: 0 /* rtl:ignore */;
  width: 100%;
  height: 100%;
  color: inherit;
  border-radius: inherit;
  z-index: 0;
  pointer-events: none;
  overflow: hidden;
  contain: strict;
}
.q-ripple__inner {
  position: absolute;
  top: 0;
  left: 0 /* rtl:ignore */;
  opacity: 0;
  color: inherit;
  border-radius: 50%;
  background: currentColor;
  pointer-events: none;
  will-change: transform, opacity;
}
.q-ripple__inner--enter {
  transition: transform 0.225s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-ripple__inner--leave {
  transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
}
.q-morph--invisible,
.q-morph--internal {
  opacity: 0 !important;
  pointer-events: none !important;
  position: fixed !important;
  right: 200vw !important;
  bottom: 200vh !important;
}
/* Plugins */
.q-loading {
  color: #000;
  position: fixed !important;
}
.q-loading__backdrop {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  opacity: 0.5;
  z-index: -1;
  background-color: #000;
  transition: background-color 0.28s;
}
.q-loading__box {
  border-radius: 4px;
  padding: 18px;
  color: #fff;
  max-width: 450px;
}
.q-loading__message {
  margin: 40px 20px 0;
  text-align: center;
}
.q-notifications__list {
  z-index: 9500;
  pointer-events: none;
  left: 0;
  right: 0;
  margin-bottom: 10px;
  position: relative;
}
.q-notifications__list--center {
  top: 0;
  bottom: 0;
}
.q-notifications__list--top {
  top: 0;
}
.q-notifications__list--bottom {
  bottom: 0;
}
body.q-ios-padding .q-notifications__list--center, body.q-ios-padding .q-notifications__list--top {
  top: 20px;
  top: env(safe-area-inset-top);
}
body.q-ios-padding .q-notifications__list--center, body.q-ios-padding .q-notifications__list--bottom {
  bottom: env(safe-area-inset-bottom);
}
.q-notification {
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
  border-radius: 4px;
  pointer-events: all;
  display: inline-flex;
  margin: 10px 10px 0;
  transition: transform 1s, opacity 1s;
  z-index: 9500;
  flex-shrink: 0;
  max-width: 95vw;
  background: #323232;
  color: #fff;
  font-size: 14px;
}
.q-notification__icon {
  font-size: 24px;
  flex: 0 0 1em;
}
.q-notification__icon--additional {
  margin-right: 16px;
}
.q-notification__avatar {
  font-size: 32px;
}
.q-notification__avatar--additional {
  margin-right: 8px;
}
.q-notification__spinner {
  font-size: 32px;
}
.q-notification__spinner--additional {
  margin-right: 8px;
}
.q-notification__message {
  padding: 8px 0;
}
.q-notification__caption {
  font-size: 0.9em;
  opacity: 0.7;
}
.q-notification__actions {
  color: var(--q-primary);
}
.q-notification__badge {
  animation: q-notif-badge 0.42s;
  padding: 4px 8px;
  position: absolute;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2), 0 1px 1px rgba(0, 0, 0, 0.14), 0 2px 1px -1px rgba(0, 0, 0, 0.12);
  background-color: var(--q-negative);
  color: #fff;
  border-radius: 4px;
  font-size: 12px;
  line-height: 12px;
}
.q-notification__badge--top-left, .q-notification__badge--top-right {
  top: -6px;
}
.q-notification__badge--bottom-left, .q-notification__badge--bottom-right {
  bottom: -6px;
}
.q-notification__badge--top-left, .q-notification__badge--bottom-left {
  left: -22px;
}
.q-notification__badge--top-right, .q-notification__badge--bottom-right {
  right: -22px;
}
.q-notification__progress {
  z-index: -1;
  position: absolute;
  height: 3px;
  bottom: 0;
  left: -10px;
  right: -10px;
  animation: q-notif-progress linear;
  background: currentColor;
  opacity: 0.3;
  border-radius: 4px 4px 0 0;
  transform-origin: 0 50%;
  transform: scaleX(0);
}
.q-notification--standard {
  padding: 0 16px;
  min-height: 48px;
}
.q-notification--standard .q-notification__actions {
  padding: 6px 0 6px 8px;
  margin-right: -8px;
}
.q-notification--multi-line {
  min-height: 68px;
  padding: 8px 16px;
}
.q-notification--multi-line .q-notification__badge--top-left, .q-notification--multi-line .q-notification__badge--top-right {
  top: -15px;
}
.q-notification--multi-line .q-notification__badge--bottom-left, .q-notification--multi-line .q-notification__badge--bottom-right {
  bottom: -15px;
}
.q-notification--multi-line .q-notification__progress {
  bottom: -8px;
}
.q-notification--multi-line .q-notification__actions {
  padding: 0;
}
.q-notification--multi-line .q-notification__actions--with-media {
  padding-left: 25px;
}
.q-notification--top-left-enter-from, .q-notification--top-left-leave-to, .q-notification--top-enter-from, .q-notification--top-leave-to, .q-notification--top-right-enter-from, .q-notification--top-right-leave-to {
  opacity: 0;
  transform: translateY(-50px);
  z-index: 9499;
}
.q-notification--left-enter-from, .q-notification--left-leave-to, .q-notification--center-enter-from, .q-notification--center-leave-to, .q-notification--right-enter-from, .q-notification--right-leave-to {
  opacity: 0;
  transform: rotateX(90deg);
  z-index: 9499;
}
.q-notification--bottom-left-enter-from, .q-notification--bottom-left-leave-to, .q-notification--bottom-enter-from, .q-notification--bottom-leave-to, .q-notification--bottom-right-enter-from, .q-notification--bottom-right-leave-to {
  opacity: 0;
  transform: translateY(50px);
  z-index: 9499;
}
.q-notification--top-left-leave-active, .q-notification--top-leave-active, .q-notification--top-right-leave-active, .q-notification--left-leave-active, .q-notification--center-leave-active, .q-notification--right-leave-active, .q-notification--bottom-left-leave-active, .q-notification--bottom-leave-active, .q-notification--bottom-right-leave-active {
  position: absolute;
  z-index: 9499;
  margin-left: 0;
  margin-right: 0;
}
.q-notification--top-leave-active, .q-notification--center-leave-active {
  top: 0;
}
.q-notification--bottom-left-leave-active, .q-notification--bottom-leave-active, .q-notification--bottom-right-leave-active {
  bottom: 0;
}
@media (min-width: 600px) {
  .q-notification {
    max-width: 65vw;
  }
}
@keyframes q-notif-badge {
  15% {
    transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);
  }
  30% {
    transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);
  }
  45% {
    transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);
  }
  60% {
    transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);
  }
  75% {
    transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);
  }
}
@keyframes q-notif-progress {
  0% {
    transform: scaleX(1);
  }
  100% {
    transform: scaleX(0);
  }
}
/* Core */
/* * Animate.css additions
 * * Adapted from: https://github.com/animate-css/animate.css/blob/6828621a01e145119db6194dc9b4d37325b48aa5/source/_base.css
 * */
:root {
  --animate-duration: 0.3s;
  --animate-delay: 0.3s;
  --animate-repeat: 1;
}
.animated {
  animation-duration: var(--animate-duration);
  animation-fill-mode: both;
}
.animated.infinite {
  animation-iteration-count: infinite;
}
.animated.hinge {
  animation-duration: 2s;
}
.animated.repeat-1 {
  animation-iteration-count: var(--animate-repeat);
}
.animated.repeat-2 {
  animation-iteration-count: calc(var(--animate-repeat) * 2);
}
.animated.repeat-3 {
  animation-iteration-count: calc(var(--animate-repeat) * 3);
}
.animated.delay-1s {
  animation-delay: var(--animate-delay);
}
.animated.delay-2s {
  animation-delay: calc(var(--animate-delay) * 2);
}
.animated.delay-3s {
  animation-delay: calc(var(--animate-delay) * 3);
}
.animated.delay-4s {
  animation-delay: calc(var(--animate-delay) * 4);
}
.animated.delay-5s {
  animation-delay: calc(var(--animate-delay) * 5);
}
.animated.faster {
  animation-duration: calc(var(--animate-duration) / 2);
}
.animated.fast {
  animation-duration: calc(var(--animate-duration) * 0.8);
}
.animated.slow {
  animation-duration: calc(var(--animate-duration) * 2);
}
.animated.slower {
  animation-duration: calc(var(--animate-duration) * 3);
}
@media print, (prefers-reduced-motion: reduce) {
  .animated {
    animation-duration: 1ms !important;
    transition-duration: 1ms !important;
    animation-iteration-count: 1 !important;
  }

  .animated[class*=Out] {
    opacity: 0;
  }
}
/* * Quasar animations
 * */
.q-animate--scale {
  animation: q-scale 0.15s;
  animation-timing-function: cubic-bezier(0.25, 0.8, 0.25, 1);
}
@keyframes q-scale {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.04);
  }
  100% {
    transform: scale(1);
  }
}
.q-animate--fade {
  animation: q-fade 0.2s /* rtl:ignore */;
}
@keyframes q-fade {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
:root {
  --q-primary: #1976D2;
  --q-secondary: #26A69A;
  --q-accent: #9C27B0;
  --q-positive: #21BA45;
  --q-negative: #FF5252;
  --q-info: #31CCEC;
  --q-warning: #F2C037;
  --q-dark: #1D1D1D;
  --q-dark-page: #121212;
}
.text-dark {
  color: var(--q-dark) !important;
}
.bg-dark {
  background: var(--q-dark) !important;
}
.text-primary {
  color: var(--q-primary) !important;
}
.bg-primary {
  background: var(--q-primary) !important;
}
.text-secondary {
  color: var(--q-secondary) !important;
}
.bg-secondary {
  background: var(--q-secondary) !important;
}
.text-accent {
  color: var(--q-accent) !important;
}
.bg-accent {
  background: var(--q-accent) !important;
}
.text-positive {
  color: var(--q-positive) !important;
}
.bg-positive {
  background: var(--q-positive) !important;
}
.text-negative {
  color: var(--q-negative) !important;
}
.bg-negative {
  background: var(--q-negative) !important;
}
.text-info {
  color: var(--q-info) !important;
}
.bg-info {
  background: var(--q-info) !important;
}
.text-warning {
  color: var(--q-warning) !important;
}
.bg-warning {
  background: var(--q-warning) !important;
}
.text-white {
  color: #fff !important;
}
.bg-white {
  background: #fff !important;
}
.text-black {
  color: #000 !important;
}
.bg-black {
  background: #000 !important;
}
.text-transparent {
  color: transparent !important;
}
.bg-transparent {
  background: transparent !important;
}
.text-separator {
  color: rgba(0, 0, 0, 0.12) !important;
}
.bg-separator {
  background: rgba(0, 0, 0, 0.12) !important;
}
.text-dark-separator {
  color: rgba(255, 255, 255, 0.28) !important;
}
.bg-dark-separator {
  background: rgba(255, 255, 255, 0.28) !important;
}
.text-red {
  color: #f44336 !important;
}
.text-red-1 {
  color: #ffebee !important;
}
.text-red-2 {
  color: #ffcdd2 !important;
}
.text-red-3 {
  color: #ef9a9a !important;
}
.text-red-4 {
  color: #e57373 !important;
}
.text-red-5 {
  color: #ef5350 !important;
}
.text-red-6 {
  color: #f44336 !important;
}
.text-red-7 {
  color: #e53935 !important;
}
.text-red-8 {
  color: #d32f2f !important;
}
.text-red-9 {
  color: #c62828 !important;
}
.text-red-10 {
  color: #b71c1c !important;
}
.text-red-11 {
  color: #ff8a80 !important;
}
.text-red-12 {
  color: #ff5252 !important;
}
.text-red-13 {
  color: #ff1744 !important;
}
.text-red-14 {
  color: #d50000 !important;
}
.text-pink {
  color: #e91e63 !important;
}
.text-pink-1 {
  color: #fce4ec !important;
}
.text-pink-2 {
  color: #f8bbd0 !important;
}
.text-pink-3 {
  color: #f48fb1 !important;
}
.text-pink-4 {
  color: #f06292 !important;
}
.text-pink-5 {
  color: #ec407a !important;
}
.text-pink-6 {
  color: #e91e63 !important;
}
.text-pink-7 {
  color: #d81b60 !important;
}
.text-pink-8 {
  color: #c2185b !important;
}
.text-pink-9 {
  color: #ad1457 !important;
}
.text-pink-10 {
  color: #880e4f !important;
}
.text-pink-11 {
  color: #ff80ab !important;
}
.text-pink-12 {
  color: #ff4081 !important;
}
.text-pink-13 {
  color: #f50057 !important;
}
.text-pink-14 {
  color: #c51162 !important;
}
.text-purple {
  color: #9c27b0 !important;
}
.text-purple-1 {
  color: #f3e5f5 !important;
}
.text-purple-2 {
  color: #e1bee7 !important;
}
.text-purple-3 {
  color: #ce93d8 !important;
}
.text-purple-4 {
  color: #ba68c8 !important;
}
.text-purple-5 {
  color: #ab47bc !important;
}
.text-purple-6 {
  color: #9c27b0 !important;
}
.text-purple-7 {
  color: #8e24aa !important;
}
.text-purple-8 {
  color: #7b1fa2 !important;
}
.text-purple-9 {
  color: #6a1b9a !important;
}
.text-purple-10 {
  color: #4a148c !important;
}
.text-purple-11 {
  color: #ea80fc !important;
}
.text-purple-12 {
  color: #e040fb !important;
}
.text-purple-13 {
  color: #d500f9 !important;
}
.text-purple-14 {
  color: #aa00ff !important;
}
.text-deep-purple {
  color: #673ab7 !important;
}
.text-deep-purple-1 {
  color: #ede7f6 !important;
}
.text-deep-purple-2 {
  color: #d1c4e9 !important;
}
.text-deep-purple-3 {
  color: #b39ddb !important;
}
.text-deep-purple-4 {
  color: #9575cd !important;
}
.text-deep-purple-5 {
  color: #7e57c2 !important;
}
.text-deep-purple-6 {
  color: #673ab7 !important;
}
.text-deep-purple-7 {
  color: #5e35b1 !important;
}
.text-deep-purple-8 {
  color: #512da8 !important;
}
.text-deep-purple-9 {
  color: #4527a0 !important;
}
.text-deep-purple-10 {
  color: #311b92 !important;
}
.text-deep-purple-11 {
  color: #b388ff !important;
}
.text-deep-purple-12 {
  color: #7c4dff !important;
}
.text-deep-purple-13 {
  color: #651fff !important;
}
.text-deep-purple-14 {
  color: #6200ea !important;
}
.text-indigo {
  color: #3f51b5 !important;
}
.text-indigo-1 {
  color: #e8eaf6 !important;
}
.text-indigo-2 {
  color: #c5cae9 !important;
}
.text-indigo-3 {
  color: #9fa8da !important;
}
.text-indigo-4 {
  color: #7986cb !important;
}
.text-indigo-5 {
  color: #5c6bc0 !important;
}
.text-indigo-6 {
  color: #3f51b5 !important;
}
.text-indigo-7 {
  color: #3949ab !important;
}
.text-indigo-8 {
  color: #303f9f !important;
}
.text-indigo-9 {
  color: #283593 !important;
}
.text-indigo-10 {
  color: #1a237e !important;
}
.text-indigo-11 {
  color: #8c9eff !important;
}
.text-indigo-12 {
  color: #536dfe !important;
}
.text-indigo-13 {
  color: #3d5afe !important;
}
.text-indigo-14 {
  color: #304ffe !important;
}
.text-blue {
  color: #2196f3 !important;
}
.text-blue-1 {
  color: #e3f2fd !important;
}
.text-blue-2 {
  color: #bbdefb !important;
}
.text-blue-3 {
  color: #90caf9 !important;
}
.text-blue-4 {
  color: #64b5f6 !important;
}
.text-blue-5 {
  color: #42a5f5 !important;
}
.text-blue-6 {
  color: #2196f3 !important;
}
.text-blue-7 {
  color: #1e88e5 !important;
}
.text-blue-8 {
  color: #1976d2 !important;
}
.text-blue-9 {
  color: #1565c0 !important;
}
.text-blue-10 {
  color: #0d47a1 !important;
}
.text-blue-11 {
  color: #82b1ff !important;
}
.text-blue-12 {
  color: #448aff !important;
}
.text-blue-13 {
  color: #2979ff !important;
}
.text-blue-14 {
  color: #2962ff !important;
}
.text-light-blue {
  color: #03a9f4 !important;
}
.text-light-blue-1 {
  color: #e1f5fe !important;
}
.text-light-blue-2 {
  color: #b3e5fc !important;
}
.text-light-blue-3 {
  color: #81d4fa !important;
}
.text-light-blue-4 {
  color: #4fc3f7 !important;
}
.text-light-blue-5 {
  color: #29b6f6 !important;
}
.text-light-blue-6 {
  color: #03a9f4 !important;
}
.text-light-blue-7 {
  color: #039be5 !important;
}
.text-light-blue-8 {
  color: #0288d1 !important;
}
.text-light-blue-9 {
  color: #0277bd !important;
}
.text-light-blue-10 {
  color: #01579b !important;
}
.text-light-blue-11 {
  color: #80d8ff !important;
}
.text-light-blue-12 {
  color: #40c4ff !important;
}
.text-light-blue-13 {
  color: #00b0ff !important;
}
.text-light-blue-14 {
  color: #0091ea !important;
}
.text-cyan {
  color: #00bcd4 !important;
}
.text-cyan-1 {
  color: #e0f7fa !important;
}
.text-cyan-2 {
  color: #b2ebf2 !important;
}
.text-cyan-3 {
  color: #80deea !important;
}
.text-cyan-4 {
  color: #4dd0e1 !important;
}
.text-cyan-5 {
  color: #26c6da !important;
}
.text-cyan-6 {
  color: #00bcd4 !important;
}
.text-cyan-7 {
  color: #00acc1 !important;
}
.text-cyan-8 {
  color: #0097a7 !important;
}
.text-cyan-9 {
  color: #00838f !important;
}
.text-cyan-10 {
  color: #006064 !important;
}
.text-cyan-11 {
  color: #84ffff !important;
}
.text-cyan-12 {
  color: #18ffff !important;
}
.text-cyan-13 {
  color: #00e5ff !important;
}
.text-cyan-14 {
  color: #00b8d4 !important;
}
.text-teal {
  color: #009688 !important;
}
.text-teal-1 {
  color: #e0f2f1 !important;
}
.text-teal-2 {
  color: #b2dfdb !important;
}
.text-teal-3 {
  color: #80cbc4 !important;
}
.text-teal-4 {
  color: #4db6ac !important;
}
.text-teal-5 {
  color: #26a69a !important;
}
.text-teal-6 {
  color: #009688 !important;
}
.text-teal-7 {
  color: #00897b !important;
}
.text-teal-8 {
  color: #00796b !important;
}
.text-teal-9 {
  color: #00695c !important;
}
.text-teal-10 {
  color: #004d40 !important;
}
.text-teal-11 {
  color: #a7ffeb !important;
}
.text-teal-12 {
  color: #64ffda !important;
}
.text-teal-13 {
  color: #1de9b6 !important;
}
.text-teal-14 {
  color: #00bfa5 !important;
}
.text-green {
  color: #4caf50 !important;
}
.text-green-1 {
  color: #e8f5e9 !important;
}
.text-green-2 {
  color: #c8e6c9 !important;
}
.text-green-3 {
  color: #a5d6a7 !important;
}
.text-green-4 {
  color: #81c784 !important;
}
.text-green-5 {
  color: #66bb6a !important;
}
.text-green-6 {
  color: #4caf50 !important;
}
.text-green-7 {
  color: #43a047 !important;
}
.text-green-8 {
  color: #388e3c !important;
}
.text-green-9 {
  color: #2e7d32 !important;
}
.text-green-10 {
  color: #1b5e20 !important;
}
.text-green-11 {
  color: #b9f6ca !important;
}
.text-green-12 {
  color: #69f0ae !important;
}
.text-green-13 {
  color: #00e676 !important;
}
.text-green-14 {
  color: #00c853 !important;
}
.text-light-green {
  color: #8bc34a !important;
}
.text-light-green-1 {
  color: #f1f8e9 !important;
}
.text-light-green-2 {
  color: #dcedc8 !important;
}
.text-light-green-3 {
  color: #c5e1a5 !important;
}
.text-light-green-4 {
  color: #aed581 !important;
}
.text-light-green-5 {
  color: #9ccc65 !important;
}
.text-light-green-6 {
  color: #8bc34a !important;
}
.text-light-green-7 {
  color: #7cb342 !important;
}
.text-light-green-8 {
  color: #689f38 !important;
}
.text-light-green-9 {
  color: #558b2f !important;
}
.text-light-green-10 {
  color: #33691e !important;
}
.text-light-green-11 {
  color: #ccff90 !important;
}
.text-light-green-12 {
  color: #b2ff59 !important;
}
.text-light-green-13 {
  color: #76ff03 !important;
}
.text-light-green-14 {
  color: #64dd17 !important;
}
.text-lime {
  color: #cddc39 !important;
}
.text-lime-1 {
  color: #f9fbe7 !important;
}
.text-lime-2 {
  color: #f0f4c3 !important;
}
.text-lime-3 {
  color: #e6ee9c !important;
}
.text-lime-4 {
  color: #dce775 !important;
}
.text-lime-5 {
  color: #d4e157 !important;
}
.text-lime-6 {
  color: #cddc39 !important;
}
.text-lime-7 {
  color: #c0ca33 !important;
}
.text-lime-8 {
  color: #afb42b !important;
}
.text-lime-9 {
  color: #9e9d24 !important;
}
.text-lime-10 {
  color: #827717 !important;
}
.text-lime-11 {
  color: #f4ff81 !important;
}
.text-lime-12 {
  color: #eeff41 !important;
}
.text-lime-13 {
  color: #c6ff00 !important;
}
.text-lime-14 {
  color: #aeea00 !important;
}
.text-yellow {
  color: #ffeb3b !important;
}
.text-yellow-1 {
  color: #fffde7 !important;
}
.text-yellow-2 {
  color: #fff9c4 !important;
}
.text-yellow-3 {
  color: #fff59d !important;
}
.text-yellow-4 {
  color: #fff176 !important;
}
.text-yellow-5 {
  color: #ffee58 !important;
}
.text-yellow-6 {
  color: #ffeb3b !important;
}
.text-yellow-7 {
  color: #fdd835 !important;
}
.text-yellow-8 {
  color: #fbc02d !important;
}
.text-yellow-9 {
  color: #f9a825 !important;
}
.text-yellow-10 {
  color: #f57f17 !important;
}
.text-yellow-11 {
  color: #ffff8d !important;
}
.text-yellow-12 {
  color: #ffff00 !important;
}
.text-yellow-13 {
  color: #ffea00 !important;
}
.text-yellow-14 {
  color: #ffd600 !important;
}
.text-amber {
  color: #ffc107 !important;
}
.text-amber-1 {
  color: #fff8e1 !important;
}
.text-amber-2 {
  color: #ffecb3 !important;
}
.text-amber-3 {
  color: #ffe082 !important;
}
.text-amber-4 {
  color: #ffd54f !important;
}
.text-amber-5 {
  color: #ffca28 !important;
}
.text-amber-6 {
  color: #ffc107 !important;
}
.text-amber-7 {
  color: #ffb300 !important;
}
.text-amber-8 {
  color: #ffa000 !important;
}
.text-amber-9 {
  color: #ff8f00 !important;
}
.text-amber-10 {
  color: #ff6f00 !important;
}
.text-amber-11 {
  color: #ffe57f !important;
}
.text-amber-12 {
  color: #ffd740 !important;
}
.text-amber-13 {
  color: #ffc400 !important;
}
.text-amber-14 {
  color: #ffab00 !important;
}
.text-orange {
  color: #ff9800 !important;
}
.text-orange-1 {
  color: #fff3e0 !important;
}
.text-orange-2 {
  color: #ffe0b2 !important;
}
.text-orange-3 {
  color: #ffcc80 !important;
}
.text-orange-4 {
  color: #ffb74d !important;
}
.text-orange-5 {
  color: #ffa726 !important;
}
.text-orange-6 {
  color: #ff9800 !important;
}
.text-orange-7 {
  color: #fb8c00 !important;
}
.text-orange-8 {
  color: #f57c00 !important;
}
.text-orange-9 {
  color: #ef6c00 !important;
}
.text-orange-10 {
  color: #e65100 !important;
}
.text-orange-11 {
  color: #ffd180 !important;
}
.text-orange-12 {
  color: #ffab40 !important;
}
.text-orange-13 {
  color: #ff9100 !important;
}
.text-orange-14 {
  color: #ff6d00 !important;
}
.text-deep-orange {
  color: #ff5722 !important;
}
.text-deep-orange-1 {
  color: #fbe9e7 !important;
}
.text-deep-orange-2 {
  color: #ffccbc !important;
}
.text-deep-orange-3 {
  color: #ffab91 !important;
}
.text-deep-orange-4 {
  color: #ff8a65 !important;
}
.text-deep-orange-5 {
  color: #ff7043 !important;
}
.text-deep-orange-6 {
  color: #ff5722 !important;
}
.text-deep-orange-7 {
  color: #f4511e !important;
}
.text-deep-orange-8 {
  color: #e64a19 !important;
}
.text-deep-orange-9 {
  color: #d84315 !important;
}
.text-deep-orange-10 {
  color: #bf360c !important;
}
.text-deep-orange-11 {
  color: #ff9e80 !important;
}
.text-deep-orange-12 {
  color: #ff6e40 !important;
}
.text-deep-orange-13 {
  color: #ff3d00 !important;
}
.text-deep-orange-14 {
  color: #dd2c00 !important;
}
.text-brown {
  color: #795548 !important;
}
.text-brown-1 {
  color: #efebe9 !important;
}
.text-brown-2 {
  color: #d7ccc8 !important;
}
.text-brown-3 {
  color: #bcaaa4 !important;
}
.text-brown-4 {
  color: #a1887f !important;
}
.text-brown-5 {
  color: #8d6e63 !important;
}
.text-brown-6 {
  color: #795548 !important;
}
.text-brown-7 {
  color: #6d4c41 !important;
}
.text-brown-8 {
  color: #5d4037 !important;
}
.text-brown-9 {
  color: #4e342e !important;
}
.text-brown-10 {
  color: #3e2723 !important;
}
.text-brown-11 {
  color: #d7ccc8 !important;
}
.text-brown-12 {
  color: #bcaaa4 !important;
}
.text-brown-13 {
  color: #8d6e63 !important;
}
.text-brown-14 {
  color: #5d4037 !important;
}
.text-grey {
  color: #9e9e9e !important;
}
.text-grey-1 {
  color: #fafafa !important;
}
.text-grey-2 {
  color: #f5f5f5 !important;
}
.text-grey-3 {
  color: #eeeeee !important;
}
.text-grey-4 {
  color: #e0e0e0 !important;
}
.text-grey-5 {
  color: #bdbdbd !important;
}
.text-grey-6 {
  color: #9e9e9e !important;
}
.text-grey-7 {
  color: #757575 !important;
}
.text-grey-8 {
  color: #616161 !important;
}
.text-grey-9 {
  color: #424242 !important;
}
.text-grey-10 {
  color: #212121 !important;
}
.text-grey-11 {
  color: #f5f5f5 !important;
}
.text-grey-12 {
  color: #eeeeee !important;
}
.text-grey-13 {
  color: #bdbdbd !important;
}
.text-grey-14 {
  color: #616161 !important;
}
.text-blue-grey {
  color: #607d8b !important;
}
.text-blue-grey-1 {
  color: #eceff1 !important;
}
.text-blue-grey-2 {
  color: #cfd8dc !important;
}
.text-blue-grey-3 {
  color: #b0bec5 !important;
}
.text-blue-grey-4 {
  color: #90a4ae !important;
}
.text-blue-grey-5 {
  color: #78909c !important;
}
.text-blue-grey-6 {
  color: #607d8b !important;
}
.text-blue-grey-7 {
  color: #546e7a !important;
}
.text-blue-grey-8 {
  color: #455a64 !important;
}
.text-blue-grey-9 {
  color: #37474f !important;
}
.text-blue-grey-10 {
  color: #263238 !important;
}
.text-blue-grey-11 {
  color: #cfd8dc !important;
}
.text-blue-grey-12 {
  color: #b0bec5 !important;
}
.text-blue-grey-13 {
  color: #78909c !important;
}
.text-blue-grey-14 {
  color: #455a64 !important;
}
.bg-red {
  background: #f44336 !important;
}
.bg-red-1 {
  background: #ffebee !important;
}
.bg-red-2 {
  background: #ffcdd2 !important;
}
.bg-red-3 {
  background: #ef9a9a !important;
}
.bg-red-4 {
  background: #e57373 !important;
}
.bg-red-5 {
  background: #ef5350 !important;
}
.bg-red-6 {
  background: #f44336 !important;
}
.bg-red-7 {
  background: #e53935 !important;
}
.bg-red-8 {
  background: #d32f2f !important;
}
.bg-red-9 {
  background: #c62828 !important;
}
.bg-red-10 {
  background: #b71c1c !important;
}
.bg-red-11 {
  background: #ff8a80 !important;
}
.bg-red-12 {
  background: #ff5252 !important;
}
.bg-red-13 {
  background: #ff1744 !important;
}
.bg-red-14 {
  background: #d50000 !important;
}
.bg-pink {
  background: #e91e63 !important;
}
.bg-pink-1 {
  background: #fce4ec !important;
}
.bg-pink-2 {
  background: #f8bbd0 !important;
}
.bg-pink-3 {
  background: #f48fb1 !important;
}
.bg-pink-4 {
  background: #f06292 !important;
}
.bg-pink-5 {
  background: #ec407a !important;
}
.bg-pink-6 {
  background: #e91e63 !important;
}
.bg-pink-7 {
  background: #d81b60 !important;
}
.bg-pink-8 {
  background: #c2185b !important;
}
.bg-pink-9 {
  background: #ad1457 !important;
}
.bg-pink-10 {
  background: #880e4f !important;
}
.bg-pink-11 {
  background: #ff80ab !important;
}
.bg-pink-12 {
  background: #ff4081 !important;
}
.bg-pink-13 {
  background: #f50057 !important;
}
.bg-pink-14 {
  background: #c51162 !important;
}
.bg-purple {
  background: #9c27b0 !important;
}
.bg-purple-1 {
  background: #f3e5f5 !important;
}
.bg-purple-2 {
  background: #e1bee7 !important;
}
.bg-purple-3 {
  background: #ce93d8 !important;
}
.bg-purple-4 {
  background: #ba68c8 !important;
}
.bg-purple-5 {
  background: #ab47bc !important;
}
.bg-purple-6 {
  background: #9c27b0 !important;
}
.bg-purple-7 {
  background: #8e24aa !important;
}
.bg-purple-8 {
  background: #7b1fa2 !important;
}
.bg-purple-9 {
  background: #6a1b9a !important;
}
.bg-purple-10 {
  background: #4a148c !important;
}
.bg-purple-11 {
  background: #ea80fc !important;
}
.bg-purple-12 {
  background: #e040fb !important;
}
.bg-purple-13 {
  background: #d500f9 !important;
}
.bg-purple-14 {
  background: #aa00ff !important;
}
.bg-deep-purple {
  background: #673ab7 !important;
}
.bg-deep-purple-1 {
  background: #ede7f6 !important;
}
.bg-deep-purple-2 {
  background: #d1c4e9 !important;
}
.bg-deep-purple-3 {
  background: #b39ddb !important;
}
.bg-deep-purple-4 {
  background: #9575cd !important;
}
.bg-deep-purple-5 {
  background: #7e57c2 !important;
}
.bg-deep-purple-6 {
  background: #673ab7 !important;
}
.bg-deep-purple-7 {
  background: #5e35b1 !important;
}
.bg-deep-purple-8 {
  background: #512da8 !important;
}
.bg-deep-purple-9 {
  background: #4527a0 !important;
}
.bg-deep-purple-10 {
  background: #311b92 !important;
}
.bg-deep-purple-11 {
  background: #b388ff !important;
}
.bg-deep-purple-12 {
  background: #7c4dff !important;
}
.bg-deep-purple-13 {
  background: #651fff !important;
}
.bg-deep-purple-14 {
  background: #6200ea !important;
}
.bg-indigo {
  background: #3f51b5 !important;
}
.bg-indigo-1 {
  background: #e8eaf6 !important;
}
.bg-indigo-2 {
  background: #c5cae9 !important;
}
.bg-indigo-3 {
  background: #9fa8da !important;
}
.bg-indigo-4 {
  background: #7986cb !important;
}
.bg-indigo-5 {
  background: #5c6bc0 !important;
}
.bg-indigo-6 {
  background: #3f51b5 !important;
}
.bg-indigo-7 {
  background: #3949ab !important;
}
.bg-indigo-8 {
  background: #303f9f !important;
}
.bg-indigo-9 {
  background: #283593 !important;
}
.bg-indigo-10 {
  background: #1a237e !important;
}
.bg-indigo-11 {
  background: #8c9eff !important;
}
.bg-indigo-12 {
  background: #536dfe !important;
}
.bg-indigo-13 {
  background: #3d5afe !important;
}
.bg-indigo-14 {
  background: #304ffe !important;
}
.bg-blue {
  background: #2196f3 !important;
}
.bg-blue-1 {
  background: #e3f2fd !important;
}
.bg-blue-2 {
  background: #bbdefb !important;
}
.bg-blue-3 {
  background: #90caf9 !important;
}
.bg-blue-4 {
  background: #64b5f6 !important;
}
.bg-blue-5 {
  background: #42a5f5 !important;
}
.bg-blue-6 {
  background: #2196f3 !important;
}
.bg-blue-7 {
  background: #1e88e5 !important;
}
.bg-blue-8 {
  background: #1976d2 !important;
}
.bg-blue-9 {
  background: #1565c0 !important;
}
.bg-blue-10 {
  background: #0d47a1 !important;
}
.bg-blue-11 {
  background: #82b1ff !important;
}
.bg-blue-12 {
  background: #448aff !important;
}
.bg-blue-13 {
  background: #2979ff !important;
}
.bg-blue-14 {
  background: #2962ff !important;
}
.bg-light-blue {
  background: #03a9f4 !important;
}
.bg-light-blue-1 {
  background: #e1f5fe !important;
}
.bg-light-blue-2 {
  background: #b3e5fc !important;
}
.bg-light-blue-3 {
  background: #81d4fa !important;
}
.bg-light-blue-4 {
  background: #4fc3f7 !important;
}
.bg-light-blue-5 {
  background: #29b6f6 !important;
}
.bg-light-blue-6 {
  background: #03a9f4 !important;
}
.bg-light-blue-7 {
  background: #039be5 !important;
}
.bg-light-blue-8 {
  background: #0288d1 !important;
}
.bg-light-blue-9 {
  background: #0277bd !important;
}
.bg-light-blue-10 {
  background: #01579b !important;
}
.bg-light-blue-11 {
  background: #80d8ff !important;
}
.bg-light-blue-12 {
  background: #40c4ff !important;
}
.bg-light-blue-13 {
  background: #00b0ff !important;
}
.bg-light-blue-14 {
  background: #0091ea !important;
}
.bg-cyan {
  background: #00bcd4 !important;
}
.bg-cyan-1 {
  background: #e0f7fa !important;
}
.bg-cyan-2 {
  background: #b2ebf2 !important;
}
.bg-cyan-3 {
  background: #80deea !important;
}
.bg-cyan-4 {
  background: #4dd0e1 !important;
}
.bg-cyan-5 {
  background: #26c6da !important;
}
.bg-cyan-6 {
  background: #00bcd4 !important;
}
.bg-cyan-7 {
  background: #00acc1 !important;
}
.bg-cyan-8 {
  background: #0097a7 !important;
}
.bg-cyan-9 {
  background: #00838f !important;
}
.bg-cyan-10 {
  background: #006064 !important;
}
.bg-cyan-11 {
  background: #84ffff !important;
}
.bg-cyan-12 {
  background: #18ffff !important;
}
.bg-cyan-13 {
  background: #00e5ff !important;
}
.bg-cyan-14 {
  background: #00b8d4 !important;
}
.bg-teal {
  background: #009688 !important;
}
.bg-teal-1 {
  background: #e0f2f1 !important;
}
.bg-teal-2 {
  background: #b2dfdb !important;
}
.bg-teal-3 {
  background: #80cbc4 !important;
}
.bg-teal-4 {
  background: #4db6ac !important;
}
.bg-teal-5 {
  background: #26a69a !important;
}
.bg-teal-6 {
  background: #009688 !important;
}
.bg-teal-7 {
  background: #00897b !important;
}
.bg-teal-8 {
  background: #00796b !important;
}
.bg-teal-9 {
  background: #00695c !important;
}
.bg-teal-10 {
  background: #004d40 !important;
}
.bg-teal-11 {
  background: #a7ffeb !important;
}
.bg-teal-12 {
  background: #64ffda !important;
}
.bg-teal-13 {
  background: #1de9b6 !important;
}
.bg-teal-14 {
  background: #00bfa5 !important;
}
.bg-green {
  background: #4caf50 !important;
}
.bg-green-1 {
  background: #e8f5e9 !important;
}
.bg-green-2 {
  background: #c8e6c9 !important;
}
.bg-green-3 {
  background: #a5d6a7 !important;
}
.bg-green-4 {
  background: #81c784 !important;
}
.bg-green-5 {
  background: #66bb6a !important;
}
.bg-green-6 {
  background: #4caf50 !important;
}
.bg-green-7 {
  background: #43a047 !important;
}
.bg-green-8 {
  background: #388e3c !important;
}
.bg-green-9 {
  background: #2e7d32 !important;
}
.bg-green-10 {
  background: #1b5e20 !important;
}
.bg-green-11 {
  background: #b9f6ca !important;
}
.bg-green-12 {
  background: #69f0ae !important;
}
.bg-green-13 {
  background: #00e676 !important;
}
.bg-green-14 {
  background: #00c853 !important;
}
.bg-light-green {
  background: #8bc34a !important;
}
.bg-light-green-1 {
  background: #f1f8e9 !important;
}
.bg-light-green-2 {
  background: #dcedc8 !important;
}
.bg-light-green-3 {
  background: #c5e1a5 !important;
}
.bg-light-green-4 {
  background: #aed581 !important;
}
.bg-light-green-5 {
  background: #9ccc65 !important;
}
.bg-light-green-6 {
  background: #8bc34a !important;
}
.bg-light-green-7 {
  background: #7cb342 !important;
}
.bg-light-green-8 {
  background: #689f38 !important;
}
.bg-light-green-9 {
  background: #558b2f !important;
}
.bg-light-green-10 {
  background: #33691e !important;
}
.bg-light-green-11 {
  background: #ccff90 !important;
}
.bg-light-green-12 {
  background: #b2ff59 !important;
}
.bg-light-green-13 {
  background: #76ff03 !important;
}
.bg-light-green-14 {
  background: #64dd17 !important;
}
.bg-lime {
  background: #cddc39 !important;
}
.bg-lime-1 {
  background: #f9fbe7 !important;
}
.bg-lime-2 {
  background: #f0f4c3 !important;
}
.bg-lime-3 {
  background: #e6ee9c !important;
}
.bg-lime-4 {
  background: #dce775 !important;
}
.bg-lime-5 {
  background: #d4e157 !important;
}
.bg-lime-6 {
  background: #cddc39 !important;
}
.bg-lime-7 {
  background: #c0ca33 !important;
}
.bg-lime-8 {
  background: #afb42b !important;
}
.bg-lime-9 {
  background: #9e9d24 !important;
}
.bg-lime-10 {
  background: #827717 !important;
}
.bg-lime-11 {
  background: #f4ff81 !important;
}
.bg-lime-12 {
  background: #eeff41 !important;
}
.bg-lime-13 {
  background: #c6ff00 !important;
}
.bg-lime-14 {
  background: #aeea00 !important;
}
.bg-yellow {
  background: #ffeb3b !important;
}
.bg-yellow-1 {
  background: #fffde7 !important;
}
.bg-yellow-2 {
  background: #fff9c4 !important;
}
.bg-yellow-3 {
  background: #fff59d !important;
}
.bg-yellow-4 {
  background: #fff176 !important;
}
.bg-yellow-5 {
  background: #ffee58 !important;
}
.bg-yellow-6 {
  background: #ffeb3b !important;
}
.bg-yellow-7 {
  background: #fdd835 !important;
}
.bg-yellow-8 {
  background: #fbc02d !important;
}
.bg-yellow-9 {
  background: #f9a825 !important;
}
.bg-yellow-10 {
  background: #f57f17 !important;
}
.bg-yellow-11 {
  background: #ffff8d !important;
}
.bg-yellow-12 {
  background: #ffff00 !important;
}
.bg-yellow-13 {
  background: #ffea00 !important;
}
.bg-yellow-14 {
  background: #ffd600 !important;
}
.bg-amber {
  background: #ffc107 !important;
}
.bg-amber-1 {
  background: #fff8e1 !important;
}
.bg-amber-2 {
  background: #ffecb3 !important;
}
.bg-amber-3 {
  background: #ffe082 !important;
}
.bg-amber-4 {
  background: #ffd54f !important;
}
.bg-amber-5 {
  background: #ffca28 !important;
}
.bg-amber-6 {
  background: #ffc107 !important;
}
.bg-amber-7 {
  background: #ffb300 !important;
}
.bg-amber-8 {
  background: #ffa000 !important;
}
.bg-amber-9 {
  background: #ff8f00 !important;
}
.bg-amber-10 {
  background: #ff6f00 !important;
}
.bg-amber-11 {
  background: #ffe57f !important;
}
.bg-amber-12 {
  background: #ffd740 !important;
}
.bg-amber-13 {
  background: #ffc400 !important;
}
.bg-amber-14 {
  background: #ffab00 !important;
}
.bg-orange {
  background: #ff9800 !important;
}
.bg-orange-1 {
  background: #fff3e0 !important;
}
.bg-orange-2 {
  background: #ffe0b2 !important;
}
.bg-orange-3 {
  background: #ffcc80 !important;
}
.bg-orange-4 {
  background: #ffb74d !important;
}
.bg-orange-5 {
  background: #ffa726 !important;
}
.bg-orange-6 {
  background: #ff9800 !important;
}
.bg-orange-7 {
  background: #fb8c00 !important;
}
.bg-orange-8 {
  background: #f57c00 !important;
}
.bg-orange-9 {
  background: #ef6c00 !important;
}
.bg-orange-10 {
  background: #e65100 !important;
}
.bg-orange-11 {
  background: #ffd180 !important;
}
.bg-orange-12 {
  background: #ffab40 !important;
}
.bg-orange-13 {
  background: #ff9100 !important;
}
.bg-orange-14 {
  background: #ff6d00 !important;
}
.bg-deep-orange {
  background: #ff5722 !important;
}
.bg-deep-orange-1 {
  background: #fbe9e7 !important;
}
.bg-deep-orange-2 {
  background: #ffccbc !important;
}
.bg-deep-orange-3 {
  background: #ffab91 !important;
}
.bg-deep-orange-4 {
  background: #ff8a65 !important;
}
.bg-deep-orange-5 {
  background: #ff7043 !important;
}
.bg-deep-orange-6 {
  background: #ff5722 !important;
}
.bg-deep-orange-7 {
  background: #f4511e !important;
}
.bg-deep-orange-8 {
  background: #e64a19 !important;
}
.bg-deep-orange-9 {
  background: #d84315 !important;
}
.bg-deep-orange-10 {
  background: #bf360c !important;
}
.bg-deep-orange-11 {
  background: #ff9e80 !important;
}
.bg-deep-orange-12 {
  background: #ff6e40 !important;
}
.bg-deep-orange-13 {
  background: #ff3d00 !important;
}
.bg-deep-orange-14 {
  background: #dd2c00 !important;
}
.bg-brown {
  background: #795548 !important;
}
.bg-brown-1 {
  background: #efebe9 !important;
}
.bg-brown-2 {
  background: #d7ccc8 !important;
}
.bg-brown-3 {
  background: #bcaaa4 !important;
}
.bg-brown-4 {
  background: #a1887f !important;
}
.bg-brown-5 {
  background: #8d6e63 !important;
}
.bg-brown-6 {
  background: #795548 !important;
}
.bg-brown-7 {
  background: #6d4c41 !important;
}
.bg-brown-8 {
  background: #5d4037 !important;
}
.bg-brown-9 {
  background: #4e342e !important;
}
.bg-brown-10 {
  background: #3e2723 !important;
}
.bg-brown-11 {
  background: #d7ccc8 !important;
}
.bg-brown-12 {
  background: #bcaaa4 !important;
}
.bg-brown-13 {
  background: #8d6e63 !important;
}
.bg-brown-14 {
  background: #5d4037 !important;
}
.bg-grey {
  background: #9e9e9e !important;
}
.bg-grey-1 {
  background: #fafafa !important;
}
.bg-grey-2 {
  background: #f5f5f5 !important;
}
.bg-grey-3 {
  background: #eeeeee !important;
}
.bg-grey-4 {
  background: #e0e0e0 !important;
}
.bg-grey-5 {
  background: #bdbdbd !important;
}
.bg-grey-6 {
  background: #9e9e9e !important;
}
.bg-grey-7 {
  background: #757575 !important;
}
.bg-grey-8 {
  background: #616161 !important;
}
.bg-grey-9 {
  background: #424242 !important;
}
.bg-grey-10 {
  background: #212121 !important;
}
.bg-grey-11 {
  background: #f5f5f5 !important;
}
.bg-grey-12 {
  background: #eeeeee !important;
}
.bg-grey-13 {
  background: #bdbdbd !important;
}
.bg-grey-14 {
  background: #616161 !important;
}
.bg-blue-grey {
  background: #607d8b !important;
}
.bg-blue-grey-1 {
  background: #eceff1 !important;
}
.bg-blue-grey-2 {
  background: #cfd8dc !important;
}
.bg-blue-grey-3 {
  background: #b0bec5 !important;
}
.bg-blue-grey-4 {
  background: #90a4ae !important;
}
.bg-blue-grey-5 {
  background: #78909c !important;
}
.bg-blue-grey-6 {
  background: #607d8b !important;
}
.bg-blue-grey-7 {
  background: #546e7a !important;
}
.bg-blue-grey-8 {
  background: #455a64 !important;
}
.bg-blue-grey-9 {
  background: #37474f !important;
}
.bg-blue-grey-10 {
  background: #263238 !important;
}
.bg-blue-grey-11 {
  background: #cfd8dc !important;
}
.bg-blue-grey-12 {
  background: #b0bec5 !important;
}
.bg-blue-grey-13 {
  background: #78909c !important;
}
.bg-blue-grey-14 {
  background: #455a64 !important;
}
.shadow-transition {
  transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1) !important;
}
.shadow-1 {
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2), 0 1px 1px rgba(0, 0, 0, 0.14), 0 2px 1px -1px rgba(0, 0, 0, 0.12);
}
.shadow-up-1 {
  box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.2), 0 -1px 1px rgba(0, 0, 0, 0.14), 0 -2px 1px -1px rgba(0, 0, 0, 0.12);
}
.shadow-2 {
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);
}
.shadow-up-2 {
  box-shadow: 0 -1px 5px rgba(0, 0, 0, 0.2), 0 -2px 2px rgba(0, 0, 0, 0.14), 0 -3px 1px -2px rgba(0, 0, 0, 0.12);
}
.shadow-3 {
  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.2), 0 3px 4px rgba(0, 0, 0, 0.14), 0 3px 3px -2px rgba(0, 0, 0, 0.12);
}
.shadow-up-3 {
  box-shadow: 0 -1px 8px rgba(0, 0, 0, 0.2), 0 -3px 4px rgba(0, 0, 0, 0.14), 0 -3px 3px -2px rgba(0, 0, 0, 0.12);
}
.shadow-4 {
  box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px rgba(0, 0, 0, 0.14), 0 1px 10px rgba(0, 0, 0, 0.12);
}
.shadow-up-4 {
  box-shadow: 0 -2px 4px -1px rgba(0, 0, 0, 0.2), 0 -4px 5px rgba(0, 0, 0, 0.14), 0 -1px 10px rgba(0, 0, 0, 0.12);
}
.shadow-5 {
  box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 5px 8px rgba(0, 0, 0, 0.14), 0 1px 14px rgba(0, 0, 0, 0.12);
}
.shadow-up-5 {
  box-shadow: 0 -3px 5px -1px rgba(0, 0, 0, 0.2), 0 -5px 8px rgba(0, 0, 0, 0.14), 0 -1px 14px rgba(0, 0, 0, 0.12);
}
.shadow-6 {
  box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px rgba(0, 0, 0, 0.14), 0 1px 18px rgba(0, 0, 0, 0.12);
}
.shadow-up-6 {
  box-shadow: 0 -3px 5px -1px rgba(0, 0, 0, 0.2), 0 -6px 10px rgba(0, 0, 0, 0.14), 0 -1px 18px rgba(0, 0, 0, 0.12);
}
.shadow-7 {
  box-shadow: 0 4px 5px -2px rgba(0, 0, 0, 0.2), 0 7px 10px 1px rgba(0, 0, 0, 0.14), 0 2px 16px 1px rgba(0, 0, 0, 0.12);
}
.shadow-up-7 {
  box-shadow: 0 -4px 5px -2px rgba(0, 0, 0, 0.2), 0 -7px 10px 1px rgba(0, 0, 0, 0.14), 0 -2px 16px 1px rgba(0, 0, 0, 0.12);
}
.shadow-8 {
  box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);
}
.shadow-up-8 {
  box-shadow: 0 -5px 5px -3px rgba(0, 0, 0, 0.2), 0 -8px 10px 1px rgba(0, 0, 0, 0.14), 0 -3px 14px 2px rgba(0, 0, 0, 0.12);
}
.shadow-9 {
  box-shadow: 0 5px 6px -3px rgba(0, 0, 0, 0.2), 0 9px 12px 1px rgba(0, 0, 0, 0.14), 0 3px 16px 2px rgba(0, 0, 0, 0.12);
}
.shadow-up-9 {
  box-shadow: 0 -5px 6px -3px rgba(0, 0, 0, 0.2), 0 -9px 12px 1px rgba(0, 0, 0, 0.14), 0 -3px 16px 2px rgba(0, 0, 0, 0.12);
}
.shadow-10 {
  box-shadow: 0 6px 6px -3px rgba(0, 0, 0, 0.2), 0 10px 14px 1px rgba(0, 0, 0, 0.14), 0 4px 18px 3px rgba(0, 0, 0, 0.12);
}
.shadow-up-10 {
  box-shadow: 0 -6px 6px -3px rgba(0, 0, 0, 0.2), 0 -10px 14px 1px rgba(0, 0, 0, 0.14), 0 -4px 18px 3px rgba(0, 0, 0, 0.12);
}
.shadow-11 {
  box-shadow: 0 6px 7px -4px rgba(0, 0, 0, 0.2), 0 11px 15px 1px rgba(0, 0, 0, 0.14), 0 4px 20px 3px rgba(0, 0, 0, 0.12);
}
.shadow-up-11 {
  box-shadow: 0 -6px 7px -4px rgba(0, 0, 0, 0.2), 0 -11px 15px 1px rgba(0, 0, 0, 0.14), 0 -4px 20px 3px rgba(0, 0, 0, 0.12);
}
.shadow-12 {
  box-shadow: 0 7px 8px -4px rgba(0, 0, 0, 0.2), 0 12px 17px 2px rgba(0, 0, 0, 0.14), 0 5px 22px 4px rgba(0, 0, 0, 0.12);
}
.shadow-up-12 {
  box-shadow: 0 -7px 8px -4px rgba(0, 0, 0, 0.2), 0 -12px 17px 2px rgba(0, 0, 0, 0.14), 0 -5px 22px 4px rgba(0, 0, 0, 0.12);
}
.shadow-13 {
  box-shadow: 0 7px 8px -4px rgba(0, 0, 0, 0.2), 0 13px 19px 2px rgba(0, 0, 0, 0.14), 0 5px 24px 4px rgba(0, 0, 0, 0.12);
}
.shadow-up-13 {
  box-shadow: 0 -7px 8px -4px rgba(0, 0, 0, 0.2), 0 -13px 19px 2px rgba(0, 0, 0, 0.14), 0 -5px 24px 4px rgba(0, 0, 0, 0.12);
}
.shadow-14 {
  box-shadow: 0 7px 9px -4px rgba(0, 0, 0, 0.2), 0 14px 21px 2px rgba(0, 0, 0, 0.14), 0 5px 26px 4px rgba(0, 0, 0, 0.12);
}
.shadow-up-14 {
  box-shadow: 0 -7px 9px -4px rgba(0, 0, 0, 0.2), 0 -14px 21px 2px rgba(0, 0, 0, 0.14), 0 -5px 26px 4px rgba(0, 0, 0, 0.12);
}
.shadow-15 {
  box-shadow: 0 8px 9px -5px rgba(0, 0, 0, 0.2), 0 15px 22px 2px rgba(0, 0, 0, 0.14), 0 6px 28px 5px rgba(0, 0, 0, 0.12);
}
.shadow-up-15 {
  box-shadow: 0 -8px 9px -5px rgba(0, 0, 0, 0.2), 0 -15px 22px 2px rgba(0, 0, 0, 0.14), 0 -6px 28px 5px rgba(0, 0, 0, 0.12);
}
.shadow-16 {
  box-shadow: 0 8px 10px -5px rgba(0, 0, 0, 0.2), 0 16px 24px 2px rgba(0, 0, 0, 0.14), 0 6px 30px 5px rgba(0, 0, 0, 0.12);
}
.shadow-up-16 {
  box-shadow: 0 -8px 10px -5px rgba(0, 0, 0, 0.2), 0 -16px 24px 2px rgba(0, 0, 0, 0.14), 0 -6px 30px 5px rgba(0, 0, 0, 0.12);
}
.shadow-17 {
  box-shadow: 0 8px 11px -5px rgba(0, 0, 0, 0.2), 0 17px 26px 2px rgba(0, 0, 0, 0.14), 0 6px 32px 5px rgba(0, 0, 0, 0.12);
}
.shadow-up-17 {
  box-shadow: 0 -8px 11px -5px rgba(0, 0, 0, 0.2), 0 -17px 26px 2px rgba(0, 0, 0, 0.14), 0 -6px 32px 5px rgba(0, 0, 0, 0.12);
}
.shadow-18 {
  box-shadow: 0 9px 11px -5px rgba(0, 0, 0, 0.2), 0 18px 28px 2px rgba(0, 0, 0, 0.14), 0 7px 34px 6px rgba(0, 0, 0, 0.12);
}
.shadow-up-18 {
  box-shadow: 0 -9px 11px -5px rgba(0, 0, 0, 0.2), 0 -18px 28px 2px rgba(0, 0, 0, 0.14), 0 -7px 34px 6px rgba(0, 0, 0, 0.12);
}
.shadow-19 {
  box-shadow: 0 9px 12px -6px rgba(0, 0, 0, 0.2), 0 19px 29px 2px rgba(0, 0, 0, 0.14), 0 7px 36px 6px rgba(0, 0, 0, 0.12);
}
.shadow-up-19 {
  box-shadow: 0 -9px 12px -6px rgba(0, 0, 0, 0.2), 0 -19px 29px 2px rgba(0, 0, 0, 0.14), 0 -7px 36px 6px rgba(0, 0, 0, 0.12);
}
.shadow-20 {
  box-shadow: 0 10px 13px -6px rgba(0, 0, 0, 0.2), 0 20px 31px 3px rgba(0, 0, 0, 0.14), 0 8px 38px 7px rgba(0, 0, 0, 0.12);
}
.shadow-up-20 {
  box-shadow: 0 -10px 13px -6px rgba(0, 0, 0, 0.2), 0 -20px 31px 3px rgba(0, 0, 0, 0.14), 0 -8px 38px 7px rgba(0, 0, 0, 0.12);
}
.shadow-21 {
  box-shadow: 0 10px 13px -6px rgba(0, 0, 0, 0.2), 0 21px 33px 3px rgba(0, 0, 0, 0.14), 0 8px 40px 7px rgba(0, 0, 0, 0.12);
}
.shadow-up-21 {
  box-shadow: 0 -10px 13px -6px rgba(0, 0, 0, 0.2), 0 -21px 33px 3px rgba(0, 0, 0, 0.14), 0 -8px 40px 7px rgba(0, 0, 0, 0.12);
}
.shadow-22 {
  box-shadow: 0 10px 14px -6px rgba(0, 0, 0, 0.2), 0 22px 35px 3px rgba(0, 0, 0, 0.14), 0 8px 42px 7px rgba(0, 0, 0, 0.12);
}
.shadow-up-22 {
  box-shadow: 0 -10px 14px -6px rgba(0, 0, 0, 0.2), 0 -22px 35px 3px rgba(0, 0, 0, 0.14), 0 -8px 42px 7px rgba(0, 0, 0, 0.12);
}
.shadow-23 {
  box-shadow: 0 11px 14px -7px rgba(0, 0, 0, 0.2), 0 23px 36px 3px rgba(0, 0, 0, 0.14), 0 9px 44px 8px rgba(0, 0, 0, 0.12);
}
.shadow-up-23 {
  box-shadow: 0 -11px 14px -7px rgba(0, 0, 0, 0.2), 0 -23px 36px 3px rgba(0, 0, 0, 0.14), 0 -9px 44px 8px rgba(0, 0, 0, 0.12);
}
.shadow-24 {
  box-shadow: 0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12);
}
.shadow-up-24 {
  box-shadow: 0 -11px 15px -7px rgba(0, 0, 0, 0.2), 0 -24px 38px 3px rgba(0, 0, 0, 0.14), 0 -9px 46px 8px rgba(0, 0, 0, 0.12);
}
.no-shadow, .shadow-0 {
  box-shadow: none !important;
}
.inset-shadow {
  box-shadow: 0 7px 9px -7px rgba(0, 0, 0, 0.7) inset !important;
}
.inset-shadow-down {
  box-shadow: 0 -7px 9px -7px rgba(0, 0, 0, 0.7) inset !important;
}
.z-marginals {
  z-index: 2000;
}
.z-notify {
  z-index: 9500;
}
.z-fullscreen {
  z-index: 6000;
}
.z-inherit {
  z-index: inherit !important;
}
.row, .column, .flex {
  display: flex;
  flex-wrap: wrap;
}
.row.inline, .column.inline, .flex.inline {
  display: inline-flex;
}
.row.reverse {
  flex-direction: row-reverse;
}
.column {
  flex-direction: column;
}
.column.reverse {
  flex-direction: column-reverse;
}
.wrap {
  flex-wrap: wrap;
}
.no-wrap {
  flex-wrap: nowrap;
}
.reverse-wrap {
  flex-wrap: wrap-reverse;
}
.order-first {
  order: -10000;
}
.order-last {
  order: 10000;
}
.order-none {
  order: 0;
}
.justify-start {
  justify-content: flex-start;
}
.justify-end {
  justify-content: flex-end;
}
.justify-center, .flex-center {
  justify-content: center;
}
.justify-between {
  justify-content: space-between;
}
.justify-around {
  justify-content: space-around;
}
.justify-evenly {
  justify-content: space-evenly;
}
.items-start {
  align-items: flex-start;
}
.items-end {
  align-items: flex-end;
}
.items-center, .flex-center {
  align-items: center;
}
.items-baseline {
  align-items: baseline;
}
.items-stretch {
  align-items: stretch;
}
.content-start {
  align-content: flex-start;
}
.content-end {
  align-content: flex-end;
}
.content-center {
  align-content: center;
}
.content-stretch {
  align-content: stretch;
}
.content-between {
  align-content: space-between;
}
.content-around {
  align-content: space-around;
}
.self-start {
  align-self: flex-start;
}
.self-end {
  align-self: flex-end;
}
.self-center {
  align-self: center;
}
.self-baseline {
  align-self: baseline;
}
.self-stretch {
  align-self: stretch;
}
.q-gutter-x-none, .q-gutter-none {
  margin-left: 0;
}
.q-gutter-x-none > *, .q-gutter-none > * {
  margin-left: 0;
}
.q-gutter-y-none, .q-gutter-none {
  margin-top: 0;
}
.q-gutter-y-none > *, .q-gutter-none > * {
  margin-top: 0;
}
.q-col-gutter-x-none, .q-col-gutter-none {
  margin-left: 0;
}
.q-col-gutter-x-none > *, .q-col-gutter-none > * {
  padding-left: 0;
}
.q-col-gutter-y-none, .q-col-gutter-none {
  margin-top: 0;
}
.q-col-gutter-y-none > *, .q-col-gutter-none > * {
  padding-top: 0;
}
.q-gutter-x-xs, .q-gutter-xs {
  margin-left: -4px;
}
.q-gutter-x-xs > *, .q-gutter-xs > * {
  margin-left: 4px;
}
.q-gutter-y-xs, .q-gutter-xs {
  margin-top: -4px;
}
.q-gutter-y-xs > *, .q-gutter-xs > * {
  margin-top: 4px;
}
.q-col-gutter-x-xs, .q-col-gutter-xs {
  margin-left: -4px;
}
.q-col-gutter-x-xs > *, .q-col-gutter-xs > * {
  padding-left: 4px;
}
.q-col-gutter-y-xs, .q-col-gutter-xs {
  margin-top: -4px;
}
.q-col-gutter-y-xs > *, .q-col-gutter-xs > * {
  padding-top: 4px;
}
.q-gutter-x-sm, .q-gutter-sm {
  margin-left: -8px;
}
.q-gutter-x-sm > *, .q-gutter-sm > * {
  margin-left: 8px;
}
.q-gutter-y-sm, .q-gutter-sm {
  margin-top: -8px;
}
.q-gutter-y-sm > *, .q-gutter-sm > * {
  margin-top: 8px;
}
.q-col-gutter-x-sm, .q-col-gutter-sm {
  margin-left: -8px;
}
.q-col-gutter-x-sm > *, .q-col-gutter-sm > * {
  padding-left: 8px;
}
.q-col-gutter-y-sm, .q-col-gutter-sm {
  margin-top: -8px;
}
.q-col-gutter-y-sm > *, .q-col-gutter-sm > * {
  padding-top: 8px;
}
.q-gutter-x-md, .q-gutter-md {
  margin-left: -16px;
}
.q-gutter-x-md > *, .q-gutter-md > * {
  margin-left: 16px;
}
.q-gutter-y-md, .q-gutter-md {
  margin-top: -16px;
}
.q-gutter-y-md > *, .q-gutter-md > * {
  margin-top: 16px;
}
.q-col-gutter-x-md, .q-col-gutter-md {
  margin-left: -16px;
}
.q-col-gutter-x-md > *, .q-col-gutter-md > * {
  padding-left: 16px;
}
.q-col-gutter-y-md, .q-col-gutter-md {
  margin-top: -16px;
}
.q-col-gutter-y-md > *, .q-col-gutter-md > * {
  padding-top: 16px;
}
.q-gutter-x-lg, .q-gutter-lg {
  margin-left: -24px;
}
.q-gutter-x-lg > *, .q-gutter-lg > * {
  margin-left: 24px;
}
.q-gutter-y-lg, .q-gutter-lg {
  margin-top: -24px;
}
.q-gutter-y-lg > *, .q-gutter-lg > * {
  margin-top: 24px;
}
.q-col-gutter-x-lg, .q-col-gutter-lg {
  margin-left: -24px;
}
.q-col-gutter-x-lg > *, .q-col-gutter-lg > * {
  padding-left: 24px;
}
.q-col-gutter-y-lg, .q-col-gutter-lg {
  margin-top: -24px;
}
.q-col-gutter-y-lg > *, .q-col-gutter-lg > * {
  padding-top: 24px;
}
.q-gutter-x-xl, .q-gutter-xl {
  margin-left: -48px;
}
.q-gutter-x-xl > *, .q-gutter-xl > * {
  margin-left: 48px;
}
.q-gutter-y-xl, .q-gutter-xl {
  margin-top: -48px;
}
.q-gutter-y-xl > *, .q-gutter-xl > * {
  margin-top: 48px;
}
.q-col-gutter-x-xl, .q-col-gutter-xl {
  margin-left: -48px;
}
.q-col-gutter-x-xl > *, .q-col-gutter-xl > * {
  padding-left: 48px;
}
.q-col-gutter-y-xl, .q-col-gutter-xl {
  margin-top: -48px;
}
.q-col-gutter-y-xl > *, .q-col-gutter-xl > * {
  padding-top: 48px;
}
@media (min-width: 0) {
  .row > .col, .flex > .col, .row > .col-auto, .flex > .col-auto, .row > .col-grow, .flex > .col-grow, .row > .col-shrink, .flex > .col-shrink, .row > .col-xs, .flex > .col-xs, .row > .col-xs-auto, .row > .col-12, .row > .col-xs-12, .row > .col-11, .row > .col-xs-11, .row > .col-10, .row > .col-xs-10, .row > .col-9, .row > .col-xs-9, .row > .col-8, .row > .col-xs-8, .row > .col-7, .row > .col-xs-7, .row > .col-6, .row > .col-xs-6, .row > .col-5, .row > .col-xs-5, .row > .col-4, .row > .col-xs-4, .row > .col-3, .row > .col-xs-3, .row > .col-2, .row > .col-xs-2, .row > .col-1, .row > .col-xs-1, .row > .col-0, .row > .col-xs-0, .flex > .col-xs-auto, .flex > .col-12, .flex > .col-xs-12, .flex > .col-11, .flex > .col-xs-11, .flex > .col-10, .flex > .col-xs-10, .flex > .col-9, .flex > .col-xs-9, .flex > .col-8, .flex > .col-xs-8, .flex > .col-7, .flex > .col-xs-7, .flex > .col-6, .flex > .col-xs-6, .flex > .col-5, .flex > .col-xs-5, .flex > .col-4, .flex > .col-xs-4, .flex > .col-3, .flex > .col-xs-3, .flex > .col-2, .flex > .col-xs-2, .flex > .col-1, .flex > .col-xs-1, .flex > .col-0, .flex > .col-xs-0, .row > .col-xs-grow, .flex > .col-xs-grow, .row > .col-xs-shrink, .flex > .col-xs-shrink {
    width: auto;
    min-width: 0;
    max-width: 100%;
  }
  .column > .col, .flex > .col, .column > .col-auto, .flex > .col-auto, .column > .col-grow, .flex > .col-grow, .column > .col-shrink, .flex > .col-shrink, .column > .col-xs, .flex > .col-xs, .column > .col-xs-auto, .column > .col-12, .column > .col-xs-12, .column > .col-11, .column > .col-xs-11, .column > .col-10, .column > .col-xs-10, .column > .col-9, .column > .col-xs-9, .column > .col-8, .column > .col-xs-8, .column > .col-7, .column > .col-xs-7, .column > .col-6, .column > .col-xs-6, .column > .col-5, .column > .col-xs-5, .column > .col-4, .column > .col-xs-4, .column > .col-3, .column > .col-xs-3, .column > .col-2, .column > .col-xs-2, .column > .col-1, .column > .col-xs-1, .column > .col-0, .column > .col-xs-0, .flex > .col-xs-auto, .flex > .col-12, .flex > .col-xs-12, .flex > .col-11, .flex > .col-xs-11, .flex > .col-10, .flex > .col-xs-10, .flex > .col-9, .flex > .col-xs-9, .flex > .col-8, .flex > .col-xs-8, .flex > .col-7, .flex > .col-xs-7, .flex > .col-6, .flex > .col-xs-6, .flex > .col-5, .flex > .col-xs-5, .flex > .col-4, .flex > .col-xs-4, .flex > .col-3, .flex > .col-xs-3, .flex > .col-2, .flex > .col-xs-2, .flex > .col-1, .flex > .col-xs-1, .flex > .col-0, .flex > .col-xs-0, .column > .col-xs-grow, .flex > .col-xs-grow, .column > .col-xs-shrink, .flex > .col-xs-shrink {
    height: auto;
    min-height: 0;
    max-height: 100%;
  }
  .col, .col-xs {
    flex: 10000 1 0%;
  }
  .col-auto, .col-xs-auto, .col-12, .col-xs-12, .col-11, .col-xs-11, .col-10, .col-xs-10, .col-9, .col-xs-9, .col-8, .col-xs-8, .col-7, .col-xs-7, .col-6, .col-xs-6, .col-5, .col-xs-5, .col-4, .col-xs-4, .col-3, .col-xs-3, .col-2, .col-xs-2, .col-1, .col-xs-1, .col-0, .col-xs-0 {
    flex: 0 0 auto;
  }
  .col-grow, .col-xs-grow {
    flex: 1 0 auto;
  }
  .col-shrink, .col-xs-shrink {
    flex: 0 1 auto;
  }

  .row > .col-0, .row > .col-xs-0 {
    height: auto;
    width: 0%;
  }
  .row > .offset-0, .row > .offset-xs-0 {
    margin-left: 0%;
  }

  .column > .col-0, .column > .col-xs-0 {
    height: 0%;
    width: auto;
  }

  .row > .col-1, .row > .col-xs-1 {
    height: auto;
    width: 8.3333%;
  }
  .row > .offset-1, .row > .offset-xs-1 {
    margin-left: 8.3333%;
  }

  .column > .col-1, .column > .col-xs-1 {
    height: 8.3333%;
    width: auto;
  }

  .row > .col-2, .row > .col-xs-2 {
    height: auto;
    width: 16.6667%;
  }
  .row > .offset-2, .row > .offset-xs-2 {
    margin-left: 16.6667%;
  }

  .column > .col-2, .column > .col-xs-2 {
    height: 16.6667%;
    width: auto;
  }

  .row > .col-3, .row > .col-xs-3 {
    height: auto;
    width: 25%;
  }
  .row > .offset-3, .row > .offset-xs-3 {
    margin-left: 25%;
  }

  .column > .col-3, .column > .col-xs-3 {
    height: 25%;
    width: auto;
  }

  .row > .col-4, .row > .col-xs-4 {
    height: auto;
    width: 33.3333%;
  }
  .row > .offset-4, .row > .offset-xs-4 {
    margin-left: 33.3333%;
  }

  .column > .col-4, .column > .col-xs-4 {
    height: 33.3333%;
    width: auto;
  }

  .row > .col-5, .row > .col-xs-5 {
    height: auto;
    width: 41.6667%;
  }
  .row > .offset-5, .row > .offset-xs-5 {
    margin-left: 41.6667%;
  }

  .column > .col-5, .column > .col-xs-5 {
    height: 41.6667%;
    width: auto;
  }

  .row > .col-6, .row > .col-xs-6 {
    height: auto;
    width: 50%;
  }
  .row > .offset-6, .row > .offset-xs-6 {
    margin-left: 50%;
  }

  .column > .col-6, .column > .col-xs-6 {
    height: 50%;
    width: auto;
  }

  .row > .col-7, .row > .col-xs-7 {
    height: auto;
    width: 58.3333%;
  }
  .row > .offset-7, .row > .offset-xs-7 {
    margin-left: 58.3333%;
  }

  .column > .col-7, .column > .col-xs-7 {
    height: 58.3333%;
    width: auto;
  }

  .row > .col-8, .row > .col-xs-8 {
    height: auto;
    width: 66.6667%;
  }
  .row > .offset-8, .row > .offset-xs-8 {
    margin-left: 66.6667%;
  }

  .column > .col-8, .column > .col-xs-8 {
    height: 66.6667%;
    width: auto;
  }

  .row > .col-9, .row > .col-xs-9 {
    height: auto;
    width: 75%;
  }
  .row > .offset-9, .row > .offset-xs-9 {
    margin-left: 75%;
  }

  .column > .col-9, .column > .col-xs-9 {
    height: 75%;
    width: auto;
  }

  .row > .col-10, .row > .col-xs-10 {
    height: auto;
    width: 83.3333%;
  }
  .row > .offset-10, .row > .offset-xs-10 {
    margin-left: 83.3333%;
  }

  .column > .col-10, .column > .col-xs-10 {
    height: 83.3333%;
    width: auto;
  }

  .row > .col-11, .row > .col-xs-11 {
    height: auto;
    width: 91.6667%;
  }
  .row > .offset-11, .row > .offset-xs-11 {
    margin-left: 91.6667%;
  }

  .column > .col-11, .column > .col-xs-11 {
    height: 91.6667%;
    width: auto;
  }

  .row > .col-12, .row > .col-xs-12 {
    height: auto;
    width: 100%;
  }
  .row > .offset-12, .row > .offset-xs-12 {
    margin-left: 100%;
  }

  .column > .col-12, .column > .col-xs-12 {
    height: 100%;
    width: auto;
  }

  .row > .col-all {
    height: auto;
    flex: 0 0 100%;
  }
}
@media (min-width: 600px) {
  .row > .col-sm, .flex > .col-sm, .row > .col-sm-auto, .row > .col-sm-12, .row > .col-sm-11, .row > .col-sm-10, .row > .col-sm-9, .row > .col-sm-8, .row > .col-sm-7, .row > .col-sm-6, .row > .col-sm-5, .row > .col-sm-4, .row > .col-sm-3, .row > .col-sm-2, .row > .col-sm-1, .row > .col-sm-0, .flex > .col-sm-auto, .flex > .col-sm-12, .flex > .col-sm-11, .flex > .col-sm-10, .flex > .col-sm-9, .flex > .col-sm-8, .flex > .col-sm-7, .flex > .col-sm-6, .flex > .col-sm-5, .flex > .col-sm-4, .flex > .col-sm-3, .flex > .col-sm-2, .flex > .col-sm-1, .flex > .col-sm-0, .row > .col-sm-grow, .flex > .col-sm-grow, .row > .col-sm-shrink, .flex > .col-sm-shrink {
    width: auto;
    min-width: 0;
    max-width: 100%;
  }
  .column > .col-sm, .flex > .col-sm, .column > .col-sm-auto, .column > .col-sm-12, .column > .col-sm-11, .column > .col-sm-10, .column > .col-sm-9, .column > .col-sm-8, .column > .col-sm-7, .column > .col-sm-6, .column > .col-sm-5, .column > .col-sm-4, .column > .col-sm-3, .column > .col-sm-2, .column > .col-sm-1, .column > .col-sm-0, .flex > .col-sm-auto, .flex > .col-sm-12, .flex > .col-sm-11, .flex > .col-sm-10, .flex > .col-sm-9, .flex > .col-sm-8, .flex > .col-sm-7, .flex > .col-sm-6, .flex > .col-sm-5, .flex > .col-sm-4, .flex > .col-sm-3, .flex > .col-sm-2, .flex > .col-sm-1, .flex > .col-sm-0, .column > .col-sm-grow, .flex > .col-sm-grow, .column > .col-sm-shrink, .flex > .col-sm-shrink {
    height: auto;
    min-height: 0;
    max-height: 100%;
  }
  .col-sm {
    flex: 10000 1 0%;
  }
  .col-sm-auto, .col-sm-12, .col-sm-11, .col-sm-10, .col-sm-9, .col-sm-8, .col-sm-7, .col-sm-6, .col-sm-5, .col-sm-4, .col-sm-3, .col-sm-2, .col-sm-1, .col-sm-0 {
    flex: 0 0 auto;
  }
  .col-sm-grow {
    flex: 1 0 auto;
  }
  .col-sm-shrink {
    flex: 0 1 auto;
  }

  .row > .col-sm-0 {
    height: auto;
    width: 0%;
  }
  .row > .offset-sm-0 {
    margin-left: 0%;
  }

  .column > .col-sm-0 {
    height: 0%;
    width: auto;
  }

  .row > .col-sm-1 {
    height: auto;
    width: 8.3333%;
  }
  .row > .offset-sm-1 {
    margin-left: 8.3333%;
  }

  .column > .col-sm-1 {
    height: 8.3333%;
    width: auto;
  }

  .row > .col-sm-2 {
    height: auto;
    width: 16.6667%;
  }
  .row > .offset-sm-2 {
    margin-left: 16.6667%;
  }

  .column > .col-sm-2 {
    height: 16.6667%;
    width: auto;
  }

  .row > .col-sm-3 {
    height: auto;
    width: 25%;
  }
  .row > .offset-sm-3 {
    margin-left: 25%;
  }

  .column > .col-sm-3 {
    height: 25%;
    width: auto;
  }

  .row > .col-sm-4 {
    height: auto;
    width: 33.3333%;
  }
  .row > .offset-sm-4 {
    margin-left: 33.3333%;
  }

  .column > .col-sm-4 {
    height: 33.3333%;
    width: auto;
  }

  .row > .col-sm-5 {
    height: auto;
    width: 41.6667%;
  }
  .row > .offset-sm-5 {
    margin-left: 41.6667%;
  }

  .column > .col-sm-5 {
    height: 41.6667%;
    width: auto;
  }

  .row > .col-sm-6 {
    height: auto;
    width: 50%;
  }
  .row > .offset-sm-6 {
    margin-left: 50%;
  }

  .column > .col-sm-6 {
    height: 50%;
    width: auto;
  }

  .row > .col-sm-7 {
    height: auto;
    width: 58.3333%;
  }
  .row > .offset-sm-7 {
    margin-left: 58.3333%;
  }

  .column > .col-sm-7 {
    height: 58.3333%;
    width: auto;
  }

  .row > .col-sm-8 {
    height: auto;
    width: 66.6667%;
  }
  .row > .offset-sm-8 {
    margin-left: 66.6667%;
  }

  .column > .col-sm-8 {
    height: 66.6667%;
    width: auto;
  }

  .row > .col-sm-9 {
    height: auto;
    width: 75%;
  }
  .row > .offset-sm-9 {
    margin-left: 75%;
  }

  .column > .col-sm-9 {
    height: 75%;
    width: auto;
  }

  .row > .col-sm-10 {
    height: auto;
    width: 83.3333%;
  }
  .row > .offset-sm-10 {
    margin-left: 83.3333%;
  }

  .column > .col-sm-10 {
    height: 83.3333%;
    width: auto;
  }

  .row > .col-sm-11 {
    height: auto;
    width: 91.6667%;
  }
  .row > .offset-sm-11 {
    margin-left: 91.6667%;
  }

  .column > .col-sm-11 {
    height: 91.6667%;
    width: auto;
  }

  .row > .col-sm-12 {
    height: auto;
    width: 100%;
  }
  .row > .offset-sm-12 {
    margin-left: 100%;
  }

  .column > .col-sm-12 {
    height: 100%;
    width: auto;
  }
}
@media (min-width: 1024px) {
  .row > .col-md, .flex > .col-md, .row > .col-md-auto, .row > .col-md-12, .row > .col-md-11, .row > .col-md-10, .row > .col-md-9, .row > .col-md-8, .row > .col-md-7, .row > .col-md-6, .row > .col-md-5, .row > .col-md-4, .row > .col-md-3, .row > .col-md-2, .row > .col-md-1, .row > .col-md-0, .flex > .col-md-auto, .flex > .col-md-12, .flex > .col-md-11, .flex > .col-md-10, .flex > .col-md-9, .flex > .col-md-8, .flex > .col-md-7, .flex > .col-md-6, .flex > .col-md-5, .flex > .col-md-4, .flex > .col-md-3, .flex > .col-md-2, .flex > .col-md-1, .flex > .col-md-0, .row > .col-md-grow, .flex > .col-md-grow, .row > .col-md-shrink, .flex > .col-md-shrink {
    width: auto;
    min-width: 0;
    max-width: 100%;
  }
  .column > .col-md, .flex > .col-md, .column > .col-md-auto, .column > .col-md-12, .column > .col-md-11, .column > .col-md-10, .column > .col-md-9, .column > .col-md-8, .column > .col-md-7, .column > .col-md-6, .column > .col-md-5, .column > .col-md-4, .column > .col-md-3, .column > .col-md-2, .column > .col-md-1, .column > .col-md-0, .flex > .col-md-auto, .flex > .col-md-12, .flex > .col-md-11, .flex > .col-md-10, .flex > .col-md-9, .flex > .col-md-8, .flex > .col-md-7, .flex > .col-md-6, .flex > .col-md-5, .flex > .col-md-4, .flex > .col-md-3, .flex > .col-md-2, .flex > .col-md-1, .flex > .col-md-0, .column > .col-md-grow, .flex > .col-md-grow, .column > .col-md-shrink, .flex > .col-md-shrink {
    height: auto;
    min-height: 0;
    max-height: 100%;
  }
  .col-md {
    flex: 10000 1 0%;
  }
  .col-md-auto, .col-md-12, .col-md-11, .col-md-10, .col-md-9, .col-md-8, .col-md-7, .col-md-6, .col-md-5, .col-md-4, .col-md-3, .col-md-2, .col-md-1, .col-md-0 {
    flex: 0 0 auto;
  }
  .col-md-grow {
    flex: 1 0 auto;
  }
  .col-md-shrink {
    flex: 0 1 auto;
  }

  .row > .col-md-0 {
    height: auto;
    width: 0%;
  }
  .row > .offset-md-0 {
    margin-left: 0%;
  }

  .column > .col-md-0 {
    height: 0%;
    width: auto;
  }

  .row > .col-md-1 {
    height: auto;
    width: 8.3333%;
  }
  .row > .offset-md-1 {
    margin-left: 8.3333%;
  }

  .column > .col-md-1 {
    height: 8.3333%;
    width: auto;
  }

  .row > .col-md-2 {
    height: auto;
    width: 16.6667%;
  }
  .row > .offset-md-2 {
    margin-left: 16.6667%;
  }

  .column > .col-md-2 {
    height: 16.6667%;
    width: auto;
  }

  .row > .col-md-3 {
    height: auto;
    width: 25%;
  }
  .row > .offset-md-3 {
    margin-left: 25%;
  }

  .column > .col-md-3 {
    height: 25%;
    width: auto;
  }

  .row > .col-md-4 {
    height: auto;
    width: 33.3333%;
  }
  .row > .offset-md-4 {
    margin-left: 33.3333%;
  }

  .column > .col-md-4 {
    height: 33.3333%;
    width: auto;
  }

  .row > .col-md-5 {
    height: auto;
    width: 41.6667%;
  }
  .row > .offset-md-5 {
    margin-left: 41.6667%;
  }

  .column > .col-md-5 {
    height: 41.6667%;
    width: auto;
  }

  .row > .col-md-6 {
    height: auto;
    width: 50%;
  }
  .row > .offset-md-6 {
    margin-left: 50%;
  }

  .column > .col-md-6 {
    height: 50%;
    width: auto;
  }

  .row > .col-md-7 {
    height: auto;
    width: 58.3333%;
  }
  .row > .offset-md-7 {
    margin-left: 58.3333%;
  }

  .column > .col-md-7 {
    height: 58.3333%;
    width: auto;
  }

  .row > .col-md-8 {
    height: auto;
    width: 66.6667%;
  }
  .row > .offset-md-8 {
    margin-left: 66.6667%;
  }

  .column > .col-md-8 {
    height: 66.6667%;
    width: auto;
  }

  .row > .col-md-9 {
    height: auto;
    width: 75%;
  }
  .row > .offset-md-9 {
    margin-left: 75%;
  }

  .column > .col-md-9 {
    height: 75%;
    width: auto;
  }

  .row > .col-md-10 {
    height: auto;
    width: 83.3333%;
  }
  .row > .offset-md-10 {
    margin-left: 83.3333%;
  }

  .column > .col-md-10 {
    height: 83.3333%;
    width: auto;
  }

  .row > .col-md-11 {
    height: auto;
    width: 91.6667%;
  }
  .row > .offset-md-11 {
    margin-left: 91.6667%;
  }

  .column > .col-md-11 {
    height: 91.6667%;
    width: auto;
  }

  .row > .col-md-12 {
    height: auto;
    width: 100%;
  }
  .row > .offset-md-12 {
    margin-left: 100%;
  }

  .column > .col-md-12 {
    height: 100%;
    width: auto;
  }
}
@media (min-width: 1440px) {
  .row > .col-lg, .flex > .col-lg, .row > .col-lg-auto, .row > .col-lg-12, .row > .col-lg-11, .row > .col-lg-10, .row > .col-lg-9, .row > .col-lg-8, .row > .col-lg-7, .row > .col-lg-6, .row > .col-lg-5, .row > .col-lg-4, .row > .col-lg-3, .row > .col-lg-2, .row > .col-lg-1, .row > .col-lg-0, .flex > .col-lg-auto, .flex > .col-lg-12, .flex > .col-lg-11, .flex > .col-lg-10, .flex > .col-lg-9, .flex > .col-lg-8, .flex > .col-lg-7, .flex > .col-lg-6, .flex > .col-lg-5, .flex > .col-lg-4, .flex > .col-lg-3, .flex > .col-lg-2, .flex > .col-lg-1, .flex > .col-lg-0, .row > .col-lg-grow, .flex > .col-lg-grow, .row > .col-lg-shrink, .flex > .col-lg-shrink {
    width: auto;
    min-width: 0;
    max-width: 100%;
  }
  .column > .col-lg, .flex > .col-lg, .column > .col-lg-auto, .column > .col-lg-12, .column > .col-lg-11, .column > .col-lg-10, .column > .col-lg-9, .column > .col-lg-8, .column > .col-lg-7, .column > .col-lg-6, .column > .col-lg-5, .column > .col-lg-4, .column > .col-lg-3, .column > .col-lg-2, .column > .col-lg-1, .column > .col-lg-0, .flex > .col-lg-auto, .flex > .col-lg-12, .flex > .col-lg-11, .flex > .col-lg-10, .flex > .col-lg-9, .flex > .col-lg-8, .flex > .col-lg-7, .flex > .col-lg-6, .flex > .col-lg-5, .flex > .col-lg-4, .flex > .col-lg-3, .flex > .col-lg-2, .flex > .col-lg-1, .flex > .col-lg-0, .column > .col-lg-grow, .flex > .col-lg-grow, .column > .col-lg-shrink, .flex > .col-lg-shrink {
    height: auto;
    min-height: 0;
    max-height: 100%;
  }
  .col-lg {
    flex: 10000 1 0%;
  }
  .col-lg-auto, .col-lg-12, .col-lg-11, .col-lg-10, .col-lg-9, .col-lg-8, .col-lg-7, .col-lg-6, .col-lg-5, .col-lg-4, .col-lg-3, .col-lg-2, .col-lg-1, .col-lg-0 {
    flex: 0 0 auto;
  }
  .col-lg-grow {
    flex: 1 0 auto;
  }
  .col-lg-shrink {
    flex: 0 1 auto;
  }

  .row > .col-lg-0 {
    height: auto;
    width: 0%;
  }
  .row > .offset-lg-0 {
    margin-left: 0%;
  }

  .column > .col-lg-0 {
    height: 0%;
    width: auto;
  }

  .row > .col-lg-1 {
    height: auto;
    width: 8.3333%;
  }
  .row > .offset-lg-1 {
    margin-left: 8.3333%;
  }

  .column > .col-lg-1 {
    height: 8.3333%;
    width: auto;
  }

  .row > .col-lg-2 {
    height: auto;
    width: 16.6667%;
  }
  .row > .offset-lg-2 {
    margin-left: 16.6667%;
  }

  .column > .col-lg-2 {
    height: 16.6667%;
    width: auto;
  }

  .row > .col-lg-3 {
    height: auto;
    width: 25%;
  }
  .row > .offset-lg-3 {
    margin-left: 25%;
  }

  .column > .col-lg-3 {
    height: 25%;
    width: auto;
  }

  .row > .col-lg-4 {
    height: auto;
    width: 33.3333%;
  }
  .row > .offset-lg-4 {
    margin-left: 33.3333%;
  }

  .column > .col-lg-4 {
    height: 33.3333%;
    width: auto;
  }

  .row > .col-lg-5 {
    height: auto;
    width: 41.6667%;
  }
  .row > .offset-lg-5 {
    margin-left: 41.6667%;
  }

  .column > .col-lg-5 {
    height: 41.6667%;
    width: auto;
  }

  .row > .col-lg-6 {
    height: auto;
    width: 50%;
  }
  .row > .offset-lg-6 {
    margin-left: 50%;
  }

  .column > .col-lg-6 {
    height: 50%;
    width: auto;
  }

  .row > .col-lg-7 {
    height: auto;
    width: 58.3333%;
  }
  .row > .offset-lg-7 {
    margin-left: 58.3333%;
  }

  .column > .col-lg-7 {
    height: 58.3333%;
    width: auto;
  }

  .row > .col-lg-8 {
    height: auto;
    width: 66.6667%;
  }
  .row > .offset-lg-8 {
    margin-left: 66.6667%;
  }

  .column > .col-lg-8 {
    height: 66.6667%;
    width: auto;
  }

  .row > .col-lg-9 {
    height: auto;
    width: 75%;
  }
  .row > .offset-lg-9 {
    margin-left: 75%;
  }

  .column > .col-lg-9 {
    height: 75%;
    width: auto;
  }

  .row > .col-lg-10 {
    height: auto;
    width: 83.3333%;
  }
  .row > .offset-lg-10 {
    margin-left: 83.3333%;
  }

  .column > .col-lg-10 {
    height: 83.3333%;
    width: auto;
  }

  .row > .col-lg-11 {
    height: auto;
    width: 91.6667%;
  }
  .row > .offset-lg-11 {
    margin-left: 91.6667%;
  }

  .column > .col-lg-11 {
    height: 91.6667%;
    width: auto;
  }

  .row > .col-lg-12 {
    height: auto;
    width: 100%;
  }
  .row > .offset-lg-12 {
    margin-left: 100%;
  }

  .column > .col-lg-12 {
    height: 100%;
    width: auto;
  }
}
@media (min-width: 1920px) {
  .row > .col-xl, .flex > .col-xl, .row > .col-xl-auto, .row > .col-xl-12, .row > .col-xl-11, .row > .col-xl-10, .row > .col-xl-9, .row > .col-xl-8, .row > .col-xl-7, .row > .col-xl-6, .row > .col-xl-5, .row > .col-xl-4, .row > .col-xl-3, .row > .col-xl-2, .row > .col-xl-1, .row > .col-xl-0, .flex > .col-xl-auto, .flex > .col-xl-12, .flex > .col-xl-11, .flex > .col-xl-10, .flex > .col-xl-9, .flex > .col-xl-8, .flex > .col-xl-7, .flex > .col-xl-6, .flex > .col-xl-5, .flex > .col-xl-4, .flex > .col-xl-3, .flex > .col-xl-2, .flex > .col-xl-1, .flex > .col-xl-0, .row > .col-xl-grow, .flex > .col-xl-grow, .row > .col-xl-shrink, .flex > .col-xl-shrink {
    width: auto;
    min-width: 0;
    max-width: 100%;
  }
  .column > .col-xl, .flex > .col-xl, .column > .col-xl-auto, .column > .col-xl-12, .column > .col-xl-11, .column > .col-xl-10, .column > .col-xl-9, .column > .col-xl-8, .column > .col-xl-7, .column > .col-xl-6, .column > .col-xl-5, .column > .col-xl-4, .column > .col-xl-3, .column > .col-xl-2, .column > .col-xl-1, .column > .col-xl-0, .flex > .col-xl-auto, .flex > .col-xl-12, .flex > .col-xl-11, .flex > .col-xl-10, .flex > .col-xl-9, .flex > .col-xl-8, .flex > .col-xl-7, .flex > .col-xl-6, .flex > .col-xl-5, .flex > .col-xl-4, .flex > .col-xl-3, .flex > .col-xl-2, .flex > .col-xl-1, .flex > .col-xl-0, .column > .col-xl-grow, .flex > .col-xl-grow, .column > .col-xl-shrink, .flex > .col-xl-shrink {
    height: auto;
    min-height: 0;
    max-height: 100%;
  }
  .col-xl {
    flex: 10000 1 0%;
  }
  .col-xl-auto, .col-xl-12, .col-xl-11, .col-xl-10, .col-xl-9, .col-xl-8, .col-xl-7, .col-xl-6, .col-xl-5, .col-xl-4, .col-xl-3, .col-xl-2, .col-xl-1, .col-xl-0 {
    flex: 0 0 auto;
  }
  .col-xl-grow {
    flex: 1 0 auto;
  }
  .col-xl-shrink {
    flex: 0 1 auto;
  }

  .row > .col-xl-0 {
    height: auto;
    width: 0%;
  }
  .row > .offset-xl-0 {
    margin-left: 0%;
  }

  .column > .col-xl-0 {
    height: 0%;
    width: auto;
  }

  .row > .col-xl-1 {
    height: auto;
    width: 8.3333%;
  }
  .row > .offset-xl-1 {
    margin-left: 8.3333%;
  }

  .column > .col-xl-1 {
    height: 8.3333%;
    width: auto;
  }

  .row > .col-xl-2 {
    height: auto;
    width: 16.6667%;
  }
  .row > .offset-xl-2 {
    margin-left: 16.6667%;
  }

  .column > .col-xl-2 {
    height: 16.6667%;
    width: auto;
  }

  .row > .col-xl-3 {
    height: auto;
    width: 25%;
  }
  .row > .offset-xl-3 {
    margin-left: 25%;
  }

  .column > .col-xl-3 {
    height: 25%;
    width: auto;
  }

  .row > .col-xl-4 {
    height: auto;
    width: 33.3333%;
  }
  .row > .offset-xl-4 {
    margin-left: 33.3333%;
  }

  .column > .col-xl-4 {
    height: 33.3333%;
    width: auto;
  }

  .row > .col-xl-5 {
    height: auto;
    width: 41.6667%;
  }
  .row > .offset-xl-5 {
    margin-left: 41.6667%;
  }

  .column > .col-xl-5 {
    height: 41.6667%;
    width: auto;
  }

  .row > .col-xl-6 {
    height: auto;
    width: 50%;
  }
  .row > .offset-xl-6 {
    margin-left: 50%;
  }

  .column > .col-xl-6 {
    height: 50%;
    width: auto;
  }

  .row > .col-xl-7 {
    height: auto;
    width: 58.3333%;
  }
  .row > .offset-xl-7 {
    margin-left: 58.3333%;
  }

  .column > .col-xl-7 {
    height: 58.3333%;
    width: auto;
  }

  .row > .col-xl-8 {
    height: auto;
    width: 66.6667%;
  }
  .row > .offset-xl-8 {
    margin-left: 66.6667%;
  }

  .column > .col-xl-8 {
    height: 66.6667%;
    width: auto;
  }

  .row > .col-xl-9 {
    height: auto;
    width: 75%;
  }
  .row > .offset-xl-9 {
    margin-left: 75%;
  }

  .column > .col-xl-9 {
    height: 75%;
    width: auto;
  }

  .row > .col-xl-10 {
    height: auto;
    width: 83.3333%;
  }
  .row > .offset-xl-10 {
    margin-left: 83.3333%;
  }

  .column > .col-xl-10 {
    height: 83.3333%;
    width: auto;
  }

  .row > .col-xl-11 {
    height: auto;
    width: 91.6667%;
  }
  .row > .offset-xl-11 {
    margin-left: 91.6667%;
  }

  .column > .col-xl-11 {
    height: 91.6667%;
    width: auto;
  }

  .row > .col-xl-12 {
    height: auto;
    width: 100%;
  }
  .row > .offset-xl-12 {
    margin-left: 100%;
  }

  .column > .col-xl-12 {
    height: 100%;
    width: auto;
  }
}
.rounded-borders {
  border-radius: 4px;
}
.border-radius-inherit {
  border-radius: inherit;
}
.no-transition {
  transition: none !important;
}
.transition-0 {
  transition: 0s !important;
}
.glossy {
  background-image: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.12) 51%, rgba(0, 0, 0, 0.04)) !important;
}
.q-placeholder::-webkit-input-placeholder {
  color: inherit;
  opacity: 0.7;
}
.q-placeholder::-moz-placeholder {
  color: inherit;
  opacity: 0.7;
}
.q-placeholder:-ms-input-placeholder {
  color: inherit !important;
  opacity: 0.7 !important;
}
.q-placeholder::-ms-input-placeholder {
  color: inherit;
  opacity: 0.7;
}
.q-placeholder::placeholder {
  color: inherit;
  opacity: 0.7;
}
/* body */
.q-body--fullscreen-mixin, .q-body--prevent-scroll {
  position: fixed !important;
}
.q-body--force-scrollbar-x {
  overflow-x: scroll;
}
.q-body--force-scrollbar-y {
  overflow-y: scroll;
}
.q-no-input-spinner {
  -moz-appearance: textfield !important;
}
.q-no-input-spinner::-webkit-outer-spin-button, .q-no-input-spinner::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.q-link {
  outline: 0;
  text-decoration: none;
}
.q-link--focusable:focus-visible {
  text-decoration: underline dashed currentColor 1px;
}
body.electron .q-electron-drag {
  -webkit-user-select: none;
  -webkit-app-region: drag;
}
body.electron .q-electron-drag .q-btn-item, body.electron .q-electron-drag--exception {
  -webkit-app-region: no-drag;
}
img.responsive {
  max-width: 100%;
  height: auto;
}
.non-selectable {
  user-select: none !important;
}
.scroll {
  overflow: auto;
}
.scroll, .scroll-x, .scroll-y {
  -webkit-overflow-scrolling: touch;
  will-change: scroll-position;
}
.scroll-x {
  overflow-x: auto;
}
.scroll-y {
  overflow-y: auto;
}
.no-scroll {
  overflow: hidden !important;
}
.no-pointer-events,
.no-pointer-events--children,
.no-pointer-events--children * {
  pointer-events: none !important;
}
.all-pointer-events {
  pointer-events: all !important;
}
.cursor-pointer {
  cursor: pointer !important;
}
.cursor-not-allowed {
  cursor: not-allowed !important;
}
.cursor-inherit {
  cursor: inherit !important;
}
.cursor-none {
  cursor: none !important;
}
[aria-busy=true] {
  cursor: progress;
}
[aria-controls] {
  cursor: pointer;
}
[aria-disabled] {
  cursor: default;
}
.rotate-45 {
  transform: rotate(45deg) /* rtl:ignore */;
}
.rotate-90 {
  transform: rotate(90deg) /* rtl:ignore */;
}
.rotate-135 {
  transform: rotate(135deg) /* rtl:ignore */;
}
.rotate-180 {
  transform: rotate(180deg) /* rtl:ignore */;
}
.rotate-225 {
  transform: rotate(225deg) /* rtl:ignore */;
}
.rotate-270 {
  transform: rotate(270deg) /* rtl:ignore */;
}
.rotate-315 {
  transform: rotate(315deg) /* rtl:ignore */;
}
.flip-horizontal {
  transform: scaleX(-1);
}
.flip-vertical {
  transform: scaleY(-1);
}
.float-left {
  float: left;
}
.float-right {
  float: right;
}
.relative-position {
  position: relative;
}
.fixed,
.fixed-full,
.fullscreen,
.fixed-center,
.fixed-bottom,
.fixed-left,
.fixed-right,
.fixed-top,
.fixed-top-left,
.fixed-top-right,
.fixed-bottom-left,
.fixed-bottom-right {
  position: fixed;
}
.absolute,
.absolute-full,
.absolute-center,
.absolute-bottom,
.absolute-left,
.absolute-right,
.absolute-top,
.absolute-top-left,
.absolute-top-right,
.absolute-bottom-left,
.absolute-bottom-right {
  position: absolute;
}
.fixed-top, .absolute-top {
  top: 0;
  left: 0;
  right: 0;
}
.fixed-right, .absolute-right {
  top: 0;
  right: 0;
  bottom: 0;
}
.fixed-bottom, .absolute-bottom {
  right: 0;
  bottom: 0;
  left: 0;
}
.fixed-left, .absolute-left {
  top: 0;
  bottom: 0;
  left: 0;
}
.fixed-top-left, .absolute-top-left {
  top: 0;
  left: 0;
}
.fixed-top-right, .absolute-top-right {
  top: 0;
  right: 0;
}
.fixed-bottom-left, .absolute-bottom-left {
  bottom: 0;
  left: 0;
}
.fixed-bottom-right, .absolute-bottom-right {
  bottom: 0;
  right: 0;
}
.fullscreen {
  z-index: 6000;
  border-radius: 0 !important;
  max-width: 100vw;
  max-height: 100vh;
}
body.q-ios-padding .fullscreen {
  padding-top: 20px !important;
  padding-top: env(safe-area-inset-top) !important;
  padding-bottom: env(safe-area-inset-bottom) !important;
}
.absolute-full, .fullscreen, .fixed-full {
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.fixed-center, .absolute-center {
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
.vertical-top {
  vertical-align: top !important;
}
.vertical-middle {
  vertical-align: middle !important;
}
.vertical-bottom {
  vertical-align: bottom !important;
}
.on-left {
  margin-right: 12px;
}
.on-right {
  margin-left: 12px;
}
/* internal: */
.q-position-engine {
  margin-top: var(--q-pe-top, 0) !important;
  margin-left: var(--q-pe-left, 0) !important;
  will-change: auto;
  visibility: collapse;
}
:root {
  --q-size-xs: 0;
  --q-size-sm: 600px;
  --q-size-md: 1024px;
  --q-size-lg: 1440px;
  --q-size-xl: 1920px;
}
.fit {
  width: 100% !important;
  height: 100% !important;
}
.full-height {
  height: 100% !important;
}
.full-width {
  width: 100% !important;
  margin-left: 0 !important;
  margin-right: 0 !important;
}
.window-height {
  margin-top: 0 !important;
  margin-bottom: 0 !important;
  height: 100vh !important;
}
.window-width {
  margin-left: 0 !important;
  margin-right: 0 !important;
  width: 100vw !important;
}
.block {
  display: block !important;
}
.inline-block {
  display: inline-block !important;
}
.q-pa-none {
  padding: 0 0;
}
.q-pl-none {
  padding-left: 0;
}
.q-pr-none {
  padding-right: 0;
}
.q-pt-none {
  padding-top: 0;
}
.q-pb-none {
  padding-bottom: 0;
}
.q-px-none {
  padding-left: 0;
  padding-right: 0;
}
.q-py-none {
  padding-top: 0;
  padding-bottom: 0;
}
.q-ma-none {
  margin: 0 0;
}
.q-ml-none {
  margin-left: 0;
}
.q-mr-none {
  margin-right: 0;
}
.q-mt-none {
  margin-top: 0;
}
.q-mb-none {
  margin-bottom: 0;
}
.q-mx-none {
  margin-left: 0;
  margin-right: 0;
}
.q-my-none {
  margin-top: 0;
  margin-bottom: 0;
}
.q-pa-xs {
  padding: 4px 4px;
}
.q-pl-xs {
  padding-left: 4px;
}
.q-pr-xs {
  padding-right: 4px;
}
.q-pt-xs {
  padding-top: 4px;
}
.q-pb-xs {
  padding-bottom: 4px;
}
.q-px-xs {
  padding-left: 4px;
  padding-right: 4px;
}
.q-py-xs {
  padding-top: 4px;
  padding-bottom: 4px;
}
.q-ma-xs {
  margin: 4px 4px;
}
.q-ml-xs {
  margin-left: 4px;
}
.q-mr-xs {
  margin-right: 4px;
}
.q-mt-xs {
  margin-top: 4px;
}
.q-mb-xs {
  margin-bottom: 4px;
}
.q-mx-xs {
  margin-left: 4px;
  margin-right: 4px;
}
.q-my-xs {
  margin-top: 4px;
  margin-bottom: 4px;
}
.q-pa-sm {
  padding: 8px 8px;
}
.q-pl-sm {
  padding-left: 8px;
}
.q-pr-sm {
  padding-right: 8px;
}
.q-pt-sm {
  padding-top: 8px;
}
.q-pb-sm {
  padding-bottom: 8px;
}
.q-px-sm {
  padding-left: 8px;
  padding-right: 8px;
}
.q-py-sm {
  padding-top: 8px;
  padding-bottom: 8px;
}
.q-ma-sm {
  margin: 8px 8px;
}
.q-ml-sm {
  margin-left: 8px;
}
.q-mr-sm {
  margin-right: 8px;
}
.q-mt-sm {
  margin-top: 8px;
}
.q-mb-sm {
  margin-bottom: 8px;
}
.q-mx-sm {
  margin-left: 8px;
  margin-right: 8px;
}
.q-my-sm {
  margin-top: 8px;
  margin-bottom: 8px;
}
.q-pa-md {
  padding: 16px 16px;
}
.q-pl-md {
  padding-left: 16px;
}
.q-pr-md {
  padding-right: 16px;
}
.q-pt-md {
  padding-top: 16px;
}
.q-pb-md {
  padding-bottom: 16px;
}
.q-px-md {
  padding-left: 16px;
  padding-right: 16px;
}
.q-py-md {
  padding-top: 16px;
  padding-bottom: 16px;
}
.q-ma-md {
  margin: 16px 16px;
}
.q-ml-md {
  margin-left: 16px;
}
.q-mr-md {
  margin-right: 16px;
}
.q-mt-md {
  margin-top: 16px;
}
.q-mb-md {
  margin-bottom: 16px;
}
.q-mx-md {
  margin-left: 16px;
  margin-right: 16px;
}
.q-my-md {
  margin-top: 16px;
  margin-bottom: 16px;
}
.q-pa-lg {
  padding: 24px 24px;
}
.q-pl-lg {
  padding-left: 24px;
}
.q-pr-lg {
  padding-right: 24px;
}
.q-pt-lg {
  padding-top: 24px;
}
.q-pb-lg {
  padding-bottom: 24px;
}
.q-px-lg {
  padding-left: 24px;
  padding-right: 24px;
}
.q-py-lg {
  padding-top: 24px;
  padding-bottom: 24px;
}
.q-ma-lg {
  margin: 24px 24px;
}
.q-ml-lg {
  margin-left: 24px;
}
.q-mr-lg {
  margin-right: 24px;
}
.q-mt-lg {
  margin-top: 24px;
}
.q-mb-lg {
  margin-bottom: 24px;
}
.q-mx-lg {
  margin-left: 24px;
  margin-right: 24px;
}
.q-my-lg {
  margin-top: 24px;
  margin-bottom: 24px;
}
.q-pa-xl {
  padding: 48px 48px;
}
.q-pl-xl {
  padding-left: 48px;
}
.q-pr-xl {
  padding-right: 48px;
}
.q-pt-xl {
  padding-top: 48px;
}
.q-pb-xl {
  padding-bottom: 48px;
}
.q-px-xl {
  padding-left: 48px;
  padding-right: 48px;
}
.q-py-xl {
  padding-top: 48px;
  padding-bottom: 48px;
}
.q-ma-xl {
  margin: 48px 48px;
}
.q-ml-xl {
  margin-left: 48px;
}
.q-mr-xl {
  margin-right: 48px;
}
.q-mt-xl {
  margin-top: 48px;
}
.q-mb-xl {
  margin-bottom: 48px;
}
.q-mx-xl {
  margin-left: 48px;
  margin-right: 48px;
}
.q-my-xl {
  margin-top: 48px;
  margin-bottom: 48px;
}
.q-mt-auto, .q-my-auto {
  margin-top: auto;
}
.q-ml-auto {
  margin-left: auto;
}
.q-mb-auto, .q-my-auto {
  margin-bottom: auto;
}
.q-mr-auto {
  margin-right: auto;
}
.q-mx-auto {
  margin-left: auto;
  margin-right: auto;
}
.q-touch {
  user-select: none;
  user-drag: none;
  -khtml-user-drag: none;
  -webkit-user-drag: none;
}
.q-touch-x {
  touch-action: pan-x;
}
.q-touch-y {
  touch-action: pan-y;
}
:root {
  --q-transition-duration: .3s;
}
.q-transition--slide-right-enter-active, .q-transition--slide-right-leave-active, .q-transition--slide-left-enter-active, .q-transition--slide-left-leave-active, .q-transition--slide-up-enter-active, .q-transition--slide-up-leave-active, .q-transition--slide-down-enter-active, .q-transition--slide-down-leave-active, .q-transition--jump-right-enter-active, .q-transition--jump-right-leave-active, .q-transition--jump-left-enter-active, .q-transition--jump-left-leave-active, .q-transition--jump-up-enter-active, .q-transition--jump-up-leave-active, .q-transition--jump-down-enter-active, .q-transition--jump-down-leave-active, .q-transition--fade-enter-active, .q-transition--fade-leave-active, .q-transition--scale-enter-active, .q-transition--scale-leave-active, .q-transition--rotate-enter-active, .q-transition--rotate-leave-active, .q-transition--flip-enter-active, .q-transition--flip-leave-active {
  --q-transition-duration: .3s;
  --q-transition-easing: cubic-bezier(0.215,0.61,0.355,1);
}
.q-transition--slide-right-leave-active, .q-transition--slide-left-leave-active, .q-transition--slide-up-leave-active, .q-transition--slide-down-leave-active, .q-transition--jump-right-leave-active, .q-transition--jump-left-leave-active, .q-transition--jump-up-leave-active, .q-transition--jump-down-leave-active, .q-transition--fade-leave-active, .q-transition--scale-leave-active, .q-transition--rotate-leave-active, .q-transition--flip-leave-active {
  position: absolute;
}
.q-transition--slide-right-enter-active, .q-transition--slide-right-leave-active, .q-transition--slide-left-enter-active, .q-transition--slide-left-leave-active, .q-transition--slide-up-enter-active, .q-transition--slide-up-leave-active, .q-transition--slide-down-enter-active, .q-transition--slide-down-leave-active {
  transition: transform var(--q-transition-duration) var(--q-transition-easing);
}
.q-transition--slide-right-enter-from {
  transform: translate3d(-100%, 0, 0);
}
.q-transition--slide-right-leave-to {
  transform: translate3d(100%, 0, 0);
}
.q-transition--slide-left-enter-from {
  transform: translate3d(100%, 0, 0);
}
.q-transition--slide-left-leave-to {
  transform: translate3d(-100%, 0, 0);
}
.q-transition--slide-up-enter-from {
  transform: translate3d(0, 100%, 0);
}
.q-transition--slide-up-leave-to {
  transform: translate3d(0, -100%, 0);
}
.q-transition--slide-down-enter-from {
  transform: translate3d(0, -100%, 0);
}
.q-transition--slide-down-leave-to {
  transform: translate3d(0, 100%, 0);
}
.q-transition--jump-right-enter-active, .q-transition--jump-right-leave-active, .q-transition--jump-left-enter-active, .q-transition--jump-left-leave-active, .q-transition--jump-up-enter-active, .q-transition--jump-up-leave-active, .q-transition--jump-down-enter-active, .q-transition--jump-down-leave-active {
  transition: opacity var(--q-transition-duration), transform var(--q-transition-duration);
}
.q-transition--jump-right-enter-from, .q-transition--jump-right-leave-to, .q-transition--jump-left-enter-from, .q-transition--jump-left-leave-to, .q-transition--jump-up-enter-from, .q-transition--jump-up-leave-to, .q-transition--jump-down-enter-from, .q-transition--jump-down-leave-to {
  opacity: 0;
}
.q-transition--jump-right-enter-from {
  transform: translate3d(-15px, 0, 0);
}
.q-transition--jump-right-leave-to {
  transform: translate3d(15px, 0, 0);
}
.q-transition--jump-left-enter-from {
  transform: translate3d(15px, 0, 0);
}
.q-transition--jump-left-leave-to {
  transform: translateX(-15px);
}
.q-transition--jump-up-enter-from {
  transform: translate3d(0, 15px, 0);
}
.q-transition--jump-up-leave-to {
  transform: translate3d(0, -15px, 0);
}
.q-transition--jump-down-enter-from {
  transform: translate3d(0, -15px, 0);
}
.q-transition--jump-down-leave-to {
  transform: translate3d(0, 15px, 0);
}
.q-transition--fade-enter-active, .q-transition--fade-leave-active {
  transition: opacity var(--q-transition-duration) ease-out;
}
.q-transition--fade-enter-from, .q-transition--fade-leave-to {
  opacity: 0;
}
.q-transition--scale-enter-active, .q-transition--scale-leave-active {
  transition: opacity var(--q-transition-duration), transform var(--q-transition-duration) var(--q-transition-easing);
}
.q-transition--scale-enter-from, .q-transition--scale-leave-to {
  opacity: 0;
  transform: scale3d(0, 0, 1);
}
.q-transition--rotate-enter-active, .q-transition--rotate-leave-active {
  transition: opacity var(--q-transition-duration), transform var(--q-transition-duration) var(--q-transition-easing);
  transform-style: preserve-3d;
}
.q-transition--rotate-enter-from, .q-transition--rotate-leave-to {
  opacity: 0;
  transform: scale3d(0, 0, 1) rotate3d(0, 0, 1, 90deg);
}
.q-transition--flip-right-enter-active, .q-transition--flip-right-leave-active, .q-transition--flip-left-enter-active, .q-transition--flip-left-leave-active, .q-transition--flip-up-enter-active, .q-transition--flip-up-leave-active, .q-transition--flip-down-enter-active, .q-transition--flip-down-leave-active {
  transition: transform var(--q-transition-duration);
  backface-visibility: hidden;
}
.q-transition--flip-right-enter-to, .q-transition--flip-right-leave-from, .q-transition--flip-left-enter-to, .q-transition--flip-left-leave-from, .q-transition--flip-up-enter-to, .q-transition--flip-up-leave-from, .q-transition--flip-down-enter-to, .q-transition--flip-down-leave-from {
  transform: perspective(400px) rotate3d(1, 1, 0, 0deg);
}
.q-transition--flip-right-enter-from {
  transform: perspective(400px) rotate3d(0, 1, 0, -180deg);
}
.q-transition--flip-right-leave-to {
  transform: perspective(400px) rotate3d(0, 1, 0, 180deg);
}
.q-transition--flip-left-enter-from {
  transform: perspective(400px) rotate3d(0, 1, 0, 180deg);
}
.q-transition--flip-left-leave-to {
  transform: perspective(400px) rotate3d(0, 1, 0, -180deg);
}
.q-transition--flip-up-enter-from {
  transform: perspective(400px) rotate3d(1, 0, 0, -180deg);
}
.q-transition--flip-up-leave-to {
  transform: perspective(400px) rotate3d(1, 0, 0, 180deg);
}
.q-transition--flip-down-enter-from {
  transform: perspective(400px) rotate3d(1, 0, 0, 180deg);
}
.q-transition--flip-down-leave-to {
  transform: perspective(400px) rotate3d(1, 0, 0, -180deg);
}
body {
  min-width: 100px;
  min-height: 100%;
  font-family: "Roboto", "-apple-system", "Helvetica Neue", Helvetica, Arial, sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-smoothing: antialiased;
  line-height: 1.5;
  font-size: 14px;
}
p {
  margin: 0 0 16px;
}
.text-h1 {
  font-size: 6rem;
  font-weight: 300;
  line-height: 6rem;
  letter-spacing: -0.01562em;
}
.text-h2 {
  font-size: 3.75rem;
  font-weight: 300;
  line-height: 3.75rem;
  letter-spacing: -0.00833em;
}
.text-h3 {
  font-size: 3rem;
  font-weight: 400;
  line-height: 3.125rem;
  letter-spacing: normal;
}
.text-h4 {
  font-size: 2.125rem;
  font-weight: 400;
  line-height: 2.5rem;
  letter-spacing: 0.00735em;
}
.text-h5 {
  font-size: 1.5rem;
  font-weight: 400;
  line-height: 2rem;
  letter-spacing: normal;
}
.text-h6 {
  font-size: 1.25rem;
  font-weight: 500;
  line-height: 2rem;
  letter-spacing: 0.0125em;
}
.text-subtitle1 {
  font-size: 1rem;
  font-weight: 400;
  line-height: 1.75rem;
  letter-spacing: 0.00937em;
}
.text-subtitle2 {
  font-size: 0.875rem;
  font-weight: 500;
  line-height: 1.375rem;
  letter-spacing: 0.00714em;
}
.text-body1 {
  font-size: 1rem;
  font-weight: 400;
  line-height: 1.5rem;
  letter-spacing: 0.03125em;
}
.text-body2 {
  font-size: 0.875rem;
  font-weight: 400;
  line-height: 1.25rem;
  letter-spacing: 0.01786em;
}
.text-overline {
  font-size: 0.75rem;
  font-weight: 500;
  line-height: 2rem;
  letter-spacing: 0.16667em;
}
.text-caption {
  font-size: 0.75rem;
  font-weight: 400;
  line-height: 1.25rem;
  letter-spacing: 0.03333em;
}
.text-uppercase {
  text-transform: uppercase;
}
.text-lowercase {
  text-transform: lowercase;
}
.text-capitalize {
  text-transform: capitalize;
}
.text-center {
  text-align: center;
}
.text-left {
  text-align: left;
}
.text-right {
  text-align: right;
}
.text-justify {
  text-align: justify;
  hyphens: auto;
}
.text-italic {
  font-style: italic;
}
.text-bold {
  font-weight: bold;
}
.text-no-wrap {
  white-space: nowrap;
}
.text-strike {
  text-decoration: line-through;
}
.text-weight-thin {
  font-weight: 100;
}
.text-weight-light {
  font-weight: 300;
}
.text-weight-regular {
  font-weight: 400;
}
.text-weight-medium {
  font-weight: 500;
}
.text-weight-bold {
  font-weight: 700;
}
.text-weight-bolder {
  font-weight: 900;
}
small {
  font-size: 80%;
}
big {
  font-size: 170%;
}
sub {
  bottom: -0.25em;
}
sup {
  top: -0.5em;
}
.no-margin {
  margin: 0 !important;
}
.no-padding {
  padding: 0 !important;
}
.no-border {
  border: 0 !important;
}
.no-border-radius {
  border-radius: 0 !important;
}
.no-box-shadow {
  box-shadow: none !important;
}
.no-outline {
  outline: 0 !important;
}
.ellipsis {
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}
.ellipsis-2-lines, .ellipsis-3-lines {
  overflow: hidden;
  display: -webkit-box;
  -webkit-box-orient: vertical;
}
.ellipsis-2-lines {
  -webkit-line-clamp: 2;
}
.ellipsis-3-lines {
  -webkit-line-clamp: 3;
}
.readonly {
  cursor: default !important;
}
.disabled, .disabled *, [disabled], [disabled] * {
  outline: 0 !important;
  cursor: not-allowed !important;
}
.disabled, [disabled] {
  opacity: 0.6 !important;
}
.hidden {
  display: none !important;
}
.invisible {
  visibility: hidden !important;
}
.transparent {
  background: transparent !important;
}
.overflow-auto {
  overflow: auto !important;
}
.overflow-hidden {
  overflow: hidden !important;
}
.overflow-hidden-y {
  overflow-y: hidden !important;
}
.hide-scrollbar {
  scrollbar-width: none;
  -ms-overflow-style: none;
}
.hide-scrollbar::-webkit-scrollbar {
  width: 0;
  height: 0;
  display: none;
}
.dimmed:after, .light-dimmed:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0 /* rtl:ignore */;
  bottom: 0;
  left: 0 /* rtl:ignore */;
}
.dimmed:after {
  background: rgba(0, 0, 0, 0.4) !important;
}
.light-dimmed:after {
  background: rgba(255, 255, 255, 0.6) !important;
}
.z-top {
  z-index: 7000 !important;
}
.z-max {
  z-index: 9998 !important;
}
body:not(.desktop) .desktop-only,
body.desktop .desktop-hide {
  display: none !important;
}
body:not(.mobile) .mobile-only,
body.mobile .mobile-hide {
  display: none !important;
}
body:not(.native-mobile) .native-mobile-only,
body.native-mobile .native-mobile-hide {
  display: none !important;
}
body:not(.cordova) .cordova-only,
body.cordova .cordova-hide {
  display: none !important;
}
body:not(.capacitor) .capacitor-only,
body.capacitor .capacitor-hide {
  display: none !important;
}
body:not(.electron) .electron-only,
body.electron .electron-hide {
  display: none !important;
}
body:not(.touch) .touch-only,
body.touch .touch-hide {
  display: none !important;
}
body:not(.within-iframe) .within-iframe-only,
body.within-iframe .within-iframe-hide {
  display: none !important;
}
body:not(.platform-ios) .platform-ios-only,
body.platform-ios .platform-ios-hide {
  display: none !important;
}
body:not(.platform-android) .platform-android-only,
body.platform-android .platform-android-hide {
  display: none !important;
}
@media all and (orientation: portrait) {
  .orientation-landscape {
    display: none !important;
  }
}
@media all and (orientation: landscape) {
  .orientation-portrait {
    display: none !important;
  }
}
@media screen {
  .print-only {
    display: none !important;
  }
}
@media print {
  .print-hide {
    display: none !important;
  }
}
@media (max-width: 599.98px) {
  .xs-hide, .gt-xs, .sm, .gt-sm, .md, .gt-md, .lg, .gt-lg, .xl {
    display: none !important;
  }
}
@media (min-width: 600px) and (max-width: 1023.98px) {
  .sm-hide, .xs, .lt-sm, .gt-sm, .md, .gt-md, .lg, .gt-lg, .xl {
    display: none !important;
  }
}
@media (min-width: 1024px) and (max-width: 1439.98px) {
  .md-hide, .xs, .lt-sm, .sm, .lt-md, .gt-md, .lg, .gt-lg, .xl {
    display: none !important;
  }
}
@media (min-width: 1440px) and (max-width: 1919.98px) {
  .lg-hide, .xs, .lt-sm, .sm, .lt-md, .md, .lt-lg, .gt-lg, .xl {
    display: none !important;
  }
}
@media (min-width: 1920px) {
  .xl-hide, .xs, .lt-sm, .sm, .lt-md, .md, .lt-lg, .lg, .lt-xl {
    display: none !important;
  }
}
.q-focus-helper, .q-focusable, .q-manual-focusable, .q-hoverable {
  outline: 0;
}
body.desktop .q-focus-helper {
  position: absolute;
  top: 0;
  left: 0 /* rtl:ignore */;
  width: 100%;
  height: 100%;
  pointer-events: none;
  border-radius: inherit;
  opacity: 0;
  transition: background-color 0.3s cubic-bezier(0.25, 0.8, 0.5, 1), opacity 0.4s cubic-bezier(0.25, 0.8, 0.5, 1);
}
body.desktop .q-focus-helper:before, body.desktop .q-focus-helper:after {
  content: "";
  position: absolute;
  top: 0;
  left: 0 /* rtl:ignore */;
  width: 100%;
  height: 100%;
  opacity: 0;
  border-radius: inherit;
  transition: background-color 0.3s cubic-bezier(0.25, 0.8, 0.5, 1), opacity 0.6s cubic-bezier(0.25, 0.8, 0.5, 1);
}
body.desktop .q-focus-helper:before {
  background: #000;
}
body.desktop .q-focus-helper:after {
  background: #fff;
}
body.desktop .q-focus-helper--rounded {
  border-radius: 4px;
}
body.desktop .q-focus-helper--round {
  border-radius: 50%;
}
body.desktop .q-focusable:focus > .q-focus-helper, body.desktop .q-manual-focusable--focused > .q-focus-helper, body.desktop .q-hoverable:hover > .q-focus-helper {
  background: currentColor;
  opacity: 0.15;
}
body.desktop .q-focusable:focus > .q-focus-helper:before, body.desktop .q-manual-focusable--focused > .q-focus-helper:before, body.desktop .q-hoverable:hover > .q-focus-helper:before {
  opacity: 0.1;
}
body.desktop .q-focusable:focus > .q-focus-helper:after, body.desktop .q-manual-focusable--focused > .q-focus-helper:after, body.desktop .q-hoverable:hover > .q-focus-helper:after {
  opacity: 0.4;
}
body.desktop .q-focusable:focus > .q-focus-helper, body.desktop .q-manual-focusable--focused > .q-focus-helper {
  opacity: 0.22;
}
body.body--dark {
  color: #fff;
  background: var(--q-dark-page);
}
.q-dark {
  color: #fff;
  background: var(--q-dark);
}.row[data-v-35e1c28d] {
  margin: 0;
}
.col[data-v-35e1c28d], .col-auto[data-v-35e1c28d] {
  padding: 0;
}
.row + .row[data-v-35e1c28d] {
  margin: 0;
}
[data-v-35e1c28d] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-35e1c28d] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-35e1c28d] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-35e1c28d] .q-space {
  width: auto;
}
[data-v-35e1c28d] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-35e1c28d] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-35e1c28d] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-35e1c28d] .col {
  padding: 0;
}
[data-v-35e1c28d] .row + .row {
  margin: 0;
}
.bg-dark[data-v-35e1c28d] {
  background: unset;
}
[data-v-35e1c28d] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-35e1c28d] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-35e1c28d] .hidden {
  display: none !important;
}
[data-v-35e1c28d] .q-field__append {
  width: auto;
}
[data-v-35e1c28d] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-35e1c28d] .col {
    flex: 10000 1 0;
}
}.row[data-v-e7c9ff7c] {
  margin: 0;
}
.col[data-v-e7c9ff7c], .col-auto[data-v-e7c9ff7c] {
  padding: 0;
}
.row + .row[data-v-e7c9ff7c] {
  margin: 0;
}
[data-v-e7c9ff7c] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-e7c9ff7c] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-e7c9ff7c] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-e7c9ff7c] .q-space {
  width: auto;
}
[data-v-e7c9ff7c] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-e7c9ff7c] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-e7c9ff7c] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-e7c9ff7c] .col {
  padding: 0;
}
[data-v-e7c9ff7c] .row + .row {
  margin: 0;
}
.bg-dark[data-v-e7c9ff7c] {
  background: unset;
}
[data-v-e7c9ff7c] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-e7c9ff7c] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-e7c9ff7c] .hidden {
  display: none !important;
}
[data-v-e7c9ff7c] .q-field__append {
  width: auto;
}
[data-v-e7c9ff7c] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-e7c9ff7c] .col {
    flex: 10000 1 0;
}
}
.provider-handle[data-v-e7c9ff7c] {
  cursor: move;
}
.ghost[data-v-e7c9ff7c] {
  opacity: 0.5;
  background: #1D1D1D;
  border: 1px dashed #ccc;
}
.drag[data-v-e7c9ff7c] {
  background: #1D1D1D;
  max-height: 82px;
  overflow: hidden;
}.row[data-v-bc55357c] {
  margin: 0;
}
.col[data-v-bc55357c], .col-auto[data-v-bc55357c] {
  padding: 0;
}
.row + .row[data-v-bc55357c] {
  margin: 0;
}
[data-v-bc55357c] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-bc55357c] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-bc55357c] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-bc55357c] .q-space {
  width: auto;
}
[data-v-bc55357c] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-bc55357c] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-bc55357c] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-bc55357c] .col {
  padding: 0;
}
[data-v-bc55357c] .row + .row {
  margin: 0;
}
.bg-dark[data-v-bc55357c] {
  background: unset;
}
[data-v-bc55357c] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-bc55357c] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-bc55357c] .hidden {
  display: none !important;
}
[data-v-bc55357c] .q-field__append {
  width: auto;
}
[data-v-bc55357c] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-bc55357c] .col {
    flex: 10000 1 0;
}
}.row[data-v-900556a4] {
  margin: 0;
}
.col[data-v-900556a4], .col-auto[data-v-900556a4] {
  padding: 0;
}
.row + .row[data-v-900556a4] {
  margin: 0;
}
[data-v-900556a4] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-900556a4] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-900556a4] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-900556a4] .q-space {
  width: auto;
}
[data-v-900556a4] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-900556a4] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-900556a4] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-900556a4] .col {
  padding: 0;
}
[data-v-900556a4] .row + .row {
  margin: 0;
}
.bg-dark[data-v-900556a4] {
  background: unset;
}
[data-v-900556a4] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-900556a4] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-900556a4] .hidden {
  display: none !important;
}
[data-v-900556a4] .q-field__append {
  width: auto;
}
[data-v-900556a4] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-900556a4] .col {
    flex: 10000 1 0;
}
}.row[data-v-a40fbadc] {
  margin: 0;
}
.col[data-v-a40fbadc], .col-auto[data-v-a40fbadc] {
  padding: 0;
}
.row + .row[data-v-a40fbadc] {
  margin: 0;
}
[data-v-a40fbadc] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-a40fbadc] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-a40fbadc] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-a40fbadc] .q-space {
  width: auto;
}
[data-v-a40fbadc] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-a40fbadc] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-a40fbadc] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-a40fbadc] .col {
  padding: 0;
}
[data-v-a40fbadc] .row + .row {
  margin: 0;
}
.bg-dark[data-v-a40fbadc] {
  background: unset;
}
[data-v-a40fbadc] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-a40fbadc] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-a40fbadc] .hidden {
  display: none !important;
}
[data-v-a40fbadc] .q-field__append {
  width: auto;
}
[data-v-a40fbadc] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-a40fbadc] .col {
    flex: 10000 1 0;
}
}.row[data-v-4ca1e240] {
  margin: 0;
}
.col[data-v-4ca1e240], .col-auto[data-v-4ca1e240] {
  padding: 0;
}
.row + .row[data-v-4ca1e240] {
  margin: 0;
}
[data-v-4ca1e240] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-4ca1e240] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-4ca1e240] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-4ca1e240] .q-space {
  width: auto;
}
[data-v-4ca1e240] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-4ca1e240] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-4ca1e240] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-4ca1e240] .col {
  padding: 0;
}
[data-v-4ca1e240] .row + .row {
  margin: 0;
}
.bg-dark[data-v-4ca1e240] {
  background: unset;
}
[data-v-4ca1e240] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-4ca1e240] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-4ca1e240] .hidden {
  display: none !important;
}
[data-v-4ca1e240] .q-field__append {
  width: auto;
}
[data-v-4ca1e240] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-4ca1e240] .col {
    flex: 10000 1 0;
}
}.row[data-v-b23b5d99] {
  margin: 0;
}
.col[data-v-b23b5d99], .col-auto[data-v-b23b5d99] {
  padding: 0;
}
.row + .row[data-v-b23b5d99] {
  margin: 0;
}
[data-v-b23b5d99] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-b23b5d99] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-b23b5d99] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-b23b5d99] .q-space {
  width: auto;
}
[data-v-b23b5d99] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-b23b5d99] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-b23b5d99] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-b23b5d99] .col {
  padding: 0;
}
[data-v-b23b5d99] .row + .row {
  margin: 0;
}
.bg-dark[data-v-b23b5d99] {
  background: unset;
}
[data-v-b23b5d99] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-b23b5d99] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-b23b5d99] .hidden {
  display: none !important;
}
[data-v-b23b5d99] .q-field__append {
  width: auto;
}
[data-v-b23b5d99] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-b23b5d99] .col {
    flex: 10000 1 0;
}
}
[data-v-b23b5d99] .row > * {
  width: auto;
  padding: 0;
}.identify-card[data-v-3428dc69] {
  max-width: var(--cbfd8272);
  width: var(--cbfd8272);
  border: 3px solid transparent;
  background-color: #121212;
}
.identify-card[data-v-3428dc69]:hover {
  border: 3px solid #FEC000;
}
.item-border[data-v-3428dc69] {
  border: 3px solid #FEC000;
}.row[data-v-7f445e97] {
  margin: 0;
}
.col[data-v-7f445e97], .col-auto[data-v-7f445e97] {
  padding: 0;
}
.row + .row[data-v-7f445e97] {
  margin: 0;
}
[data-v-7f445e97] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-7f445e97] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-7f445e97] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-7f445e97] .q-space {
  width: auto;
}
[data-v-7f445e97] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-7f445e97] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-7f445e97] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-7f445e97] .col {
  padding: 0;
}
[data-v-7f445e97] .row + .row {
  margin: 0;
}
.bg-dark[data-v-7f445e97] {
  background: unset;
}
[data-v-7f445e97] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-7f445e97] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-7f445e97] .hidden {
  display: none !important;
}
[data-v-7f445e97] .q-field__append {
  width: auto;
}
[data-v-7f445e97] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-7f445e97] .col {
    flex: 10000 1 0;
}
}.row[data-v-9f33b495] {
  margin: 0;
}
.col[data-v-9f33b495], .col-auto[data-v-9f33b495] {
  padding: 0;
}
.row + .row[data-v-9f33b495] {
  margin: 0;
}
[data-v-9f33b495] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-9f33b495] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-9f33b495] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-9f33b495] .q-space {
  width: auto;
}
[data-v-9f33b495] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-9f33b495] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-9f33b495] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-9f33b495] .col {
  padding: 0;
}
[data-v-9f33b495] .row + .row {
  margin: 0;
}
.bg-dark[data-v-9f33b495] {
  background: unset;
}
[data-v-9f33b495] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-9f33b495] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-9f33b495] .hidden {
  display: none !important;
}
[data-v-9f33b495] .q-field__append {
  width: auto;
}
[data-v-9f33b495] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-9f33b495] .col {
    flex: 10000 1 0;
}
}.row[data-v-e95f9e5e] {
  margin: 0;
}
.col[data-v-e95f9e5e], .col-auto[data-v-e95f9e5e] {
  padding: 0;
}
.row + .row[data-v-e95f9e5e] {
  margin: 0;
}
[data-v-e95f9e5e] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-e95f9e5e] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-e95f9e5e] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-e95f9e5e] .q-space {
  width: auto;
}
[data-v-e95f9e5e] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-e95f9e5e] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-e95f9e5e] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-e95f9e5e] .col {
  padding: 0;
}
[data-v-e95f9e5e] .row + .row {
  margin: 0;
}
.bg-dark[data-v-e95f9e5e] {
  background: unset;
}
[data-v-e95f9e5e] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-e95f9e5e] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-e95f9e5e] .hidden {
  display: none !important;
}
[data-v-e95f9e5e] .q-field__append {
  width: auto;
}
[data-v-e95f9e5e] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-e95f9e5e] .col {
    flex: 10000 1 0;
}
}.row[data-v-2de3bff8] {
  margin: 0;
}
.col[data-v-2de3bff8], .col-auto[data-v-2de3bff8] {
  padding: 0;
}
.row + .row[data-v-2de3bff8] {
  margin: 0;
}
[data-v-2de3bff8] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-2de3bff8] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-2de3bff8] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-2de3bff8] .q-space {
  width: auto;
}
[data-v-2de3bff8] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-2de3bff8] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-2de3bff8] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-2de3bff8] .col {
  padding: 0;
}
[data-v-2de3bff8] .row + .row {
  margin: 0;
}
.bg-dark[data-v-2de3bff8] {
  background: unset;
}
[data-v-2de3bff8] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-2de3bff8] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-2de3bff8] .hidden {
  display: none !important;
}
[data-v-2de3bff8] .q-field__append {
  width: auto;
}
[data-v-2de3bff8] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-2de3bff8] .col {
    flex: 10000 1 0;
}
}.row[data-v-d80e76e9] {
  margin: 0;
}
.col[data-v-d80e76e9], .col-auto[data-v-d80e76e9] {
  padding: 0;
}
.row + .row[data-v-d80e76e9] {
  margin: 0;
}
[data-v-d80e76e9] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-d80e76e9] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-d80e76e9] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-d80e76e9] .q-space {
  width: auto;
}
[data-v-d80e76e9] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-d80e76e9] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-d80e76e9] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-d80e76e9] .col {
  padding: 0;
}
[data-v-d80e76e9] .row + .row {
  margin: 0;
}
.bg-dark[data-v-d80e76e9] {
  background: unset;
}
[data-v-d80e76e9] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-d80e76e9] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-d80e76e9] .hidden {
  display: none !important;
}
[data-v-d80e76e9] .q-field__append {
  width: auto;
}
[data-v-d80e76e9] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-d80e76e9] .col {
    flex: 10000 1 0;
}
}.row[data-v-5c09e4ef] {
  margin: 0;
}
.col[data-v-5c09e4ef], .col-auto[data-v-5c09e4ef] {
  padding: 0;
}
.row + .row[data-v-5c09e4ef] {
  margin: 0;
}
[data-v-5c09e4ef] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-5c09e4ef] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-5c09e4ef] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-5c09e4ef] .q-space {
  width: auto;
}
[data-v-5c09e4ef] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-5c09e4ef] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-5c09e4ef] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-5c09e4ef] .col {
  padding: 0;
}
[data-v-5c09e4ef] .row + .row {
  margin: 0;
}
.bg-dark[data-v-5c09e4ef] {
  background: unset;
}
[data-v-5c09e4ef] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-5c09e4ef] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-5c09e4ef] .hidden {
  display: none !important;
}
[data-v-5c09e4ef] .q-field__append {
  width: auto;
}
[data-v-5c09e4ef] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-5c09e4ef] .col {
    flex: 10000 1 0;
}
}.row[data-v-2d61344c] {
  margin: 0;
}
.col[data-v-2d61344c], .col-auto[data-v-2d61344c] {
  padding: 0;
}
.row + .row[data-v-2d61344c] {
  margin: 0;
}
[data-v-2d61344c] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-2d61344c] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-2d61344c] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-2d61344c] .q-space {
  width: auto;
}
[data-v-2d61344c] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-2d61344c] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-2d61344c] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-2d61344c] .col {
  padding: 0;
}
[data-v-2d61344c] .row + .row {
  margin: 0;
}
.bg-dark[data-v-2d61344c] {
  background: unset;
}
[data-v-2d61344c] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-2d61344c] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-2d61344c] .hidden {
  display: none !important;
}
[data-v-2d61344c] .q-field__append {
  width: auto;
}
[data-v-2d61344c] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-2d61344c] .col {
    flex: 10000 1 0;
}
}.settings-button[data-v-2c371c7b]:hover {
  border: 2px solid white;
  border-radius: 20%;
}
.settings-button[data-v-2c371c7b] {
  border: 2px solid transparent;
  border-radius: 20%;
  padding: 6px 12px 6px 12px;
}.row[data-v-7068b1fc] {
  margin: 0;
}
.col[data-v-7068b1fc], .col-auto[data-v-7068b1fc] {
  padding: 0;
}
.row + .row[data-v-7068b1fc] {
  margin: 0;
}
[data-v-7068b1fc] .q-checkbox>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-7068b1fc] .q-tab__content>* {
  flex-shrink: unset;
}
[data-v-7068b1fc] .q-tabs>* {
  width: auto;
  padding-right: unset;
  padding-left: unset;
}
[data-v-7068b1fc] .q-space {
  width: auto;
}
[data-v-7068b1fc] .q-splitter {
  padding-right: unset;
  padding-left: unset;
}
[data-v-7068b1fc] .q-splitter>* {
  width: 1px;
  padding-right: unset;
  padding-left: unset;
}
[data-v-7068b1fc] .row {
  margin: 0;
  --bs-gutter-x: unset;
  --bs-gutter-y: unset;
}
[data-v-7068b1fc] .col {
  padding: 0;
}
[data-v-7068b1fc] .row + .row {
  margin: 0;
}
.bg-dark[data-v-7068b1fc] {
  background: unset;
}
[data-v-7068b1fc] input:not([type=range]) {
  background-color: unset;
  border-color: unset;
}
[data-v-7068b1fc] input:not([type=range]):focus {
  border-color: unset;
  background-color: unset;
  box-shadow: unset;
}
[data-v-7068b1fc] .hidden {
  display: none !important;
}
[data-v-7068b1fc] .q-field__append {
  width: auto;
}
[data-v-7068b1fc] .q-chip {
  width: auto;
}
@media (min-width: 0) {
[data-v-7068b1fc] .col {
    flex: 10000 1 0;
}
}.bg-dark {
  background: var(--bs-body-bg) !important;
}
.bg-primary {
  --bs-bg-opacity: 1;
  background-color: rgba(var(--bs-primary-rgb), var(--bs-bg-opacity)) !important;
}
body {
  font-size: unset;
}
.hidden {
  display: unset !important;
}
.q-item.row {
  margin: 0;
}`)),document.head.appendChild(n)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
function normalizeStyle(value2) {
  if (isArray$1(value2)) {
    const res = {};
    for (let i = 0; i < value2.length; i++) {
      const item = value2[i];
      const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$2(value2)) {
    return value2;
  } else if (isObject$2(value2)) {
    return value2;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value2) {
  let res = "";
  if (isString$2(value2)) {
    res = value2;
  } else if (isArray$1(value2)) {
    for (let i = 0; i < value2.length; i++) {
      const normalized = normalizeClass(value2[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value2)) {
    for (const name in value2) {
      if (value2[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value2) {
  return !!value2 || value2 === "";
}
const toDisplayString = (val) => {
  return isString$2(val) ? val : val == null ? "" : isArray$1(val) || isObject$2(val) && (val.toString === objectToString || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$2(val) && !isArray$1(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$2 = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$2 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$2(val) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value2) => objectToString.call(value2);
const toRawType = (value2) => {
  return toTypeString(value2).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value2, oldValue) => !Object.is(value2, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value2) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value: value2
  });
};
const toNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this.active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target2, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target2);
    if (!depsMap) {
      targetMap.set(target2, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger$1(target2, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target2);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$1(target2)) {
    const newLength = toNumber(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$1(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$1(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$1(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target2, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target2)) {
      return target2;
    }
    const targetIsArray = isArray$1(target2);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target2, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target2, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target2, key, value2, receiver) {
    let oldValue = target2[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value2)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value2) && !isReadonly(value2)) {
        oldValue = toRaw(oldValue);
        value2 = toRaw(value2);
      }
      if (!isArray$1(target2) && isRef(oldValue) && !isRef(value2)) {
        oldValue.value = value2;
        return true;
      }
    }
    const hadKey = isArray$1(target2) && isIntegerKey(key) ? Number(key) < target2.length : hasOwn(target2, key);
    const result = Reflect.set(target2, key, value2, receiver);
    if (target2 === toRaw(receiver)) {
      if (!hadKey) {
        trigger$1(target2, "add", key, value2);
      } else if (hasChanged(value2, oldValue)) {
        trigger$1(target2, "set", key, value2);
      }
    }
    return result;
  };
}
function deleteProperty(target2, key) {
  const hadKey = hasOwn(target2, key);
  target2[key];
  const result = Reflect.deleteProperty(target2, key);
  if (result && hadKey) {
    trigger$1(target2, "delete", key, void 0);
  }
  return result;
}
function has(target2, key) {
  const result = Reflect.has(target2, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target2, "has", key);
  }
  return result;
}
function ownKeys$1(target2) {
  track(target2, "iterate", isArray$1(target2) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target2);
}
const mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys: ownKeys$1
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target2, key) {
    return true;
  },
  deleteProperty(target2, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$2({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const toShallow = (value2) => value2;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target2, key, isReadonly2 = false, isShallow2 = false) {
  target2 = target2["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target2.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target2.get(rawKey));
  } else if (target2 !== rawTarget) {
    target2.get(key);
  }
}
function has$1(key, isReadonly2 = false) {
  const target2 = this["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target2.has(key) : target2.has(key) || target2.has(rawKey);
}
function size$1(target2, isReadonly2 = false) {
  target2 = target2["__v_raw"];
  !isReadonly2 && track(toRaw(target2), "iterate", ITERATE_KEY);
  return Reflect.get(target2, "size", target2);
}
function add(value2) {
  value2 = toRaw(value2);
  const target2 = toRaw(this);
  const proto = getProto(target2);
  const hadKey = proto.has.call(target2, value2);
  if (!hadKey) {
    target2.add(value2);
    trigger$1(target2, "add", value2, value2);
  }
  return this;
}
function set$1(key, value2) {
  value2 = toRaw(value2);
  const target2 = toRaw(this);
  const { has: has2, get: get2 } = getProto(target2);
  let hadKey = has2.call(target2, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target2, key);
  }
  const oldValue = get2.call(target2, key);
  target2.set(key, value2);
  if (!hadKey) {
    trigger$1(target2, "add", key, value2);
  } else if (hasChanged(value2, oldValue)) {
    trigger$1(target2, "set", key, value2);
  }
  return this;
}
function deleteEntry(key) {
  const target2 = toRaw(this);
  const { has: has2, get: get2 } = getProto(target2);
  let hadKey = has2.call(target2, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target2, key);
  }
  get2 ? get2.call(target2, key) : void 0;
  const result = target2.delete(key);
  if (hadKey) {
    trigger$1(target2, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target2 = toRaw(this);
  const hadItems = target2.size !== 0;
  const result = target2.clear();
  if (hadItems) {
    trigger$1(target2, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach2(callback, thisArg) {
    const observed = this;
    const target2 = observed["__v_raw"];
    const rawTarget = toRaw(target2);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target2.forEach((value2, key) => {
      return callback.call(thisArg, wrap(value2), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target2 = this["__v_raw"];
    const rawTarget = toRaw(target2);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target2[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value: value2, done } = innerIterator.next();
        return done ? { value: value2, done } : {
          value: isPair ? [wrap(value2[0]), wrap(value2[1])] : wrap(value2),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size$1(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size$1(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target2, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target2;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target2 ? instrumentations : target2, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value2) {
  return value2["__v_skip"] || !Object.isExtensible(value2) ? 0 : targetTypeMap(toRawType(value2));
}
function reactive(target2) {
  if (isReadonly(target2)) {
    return target2;
  }
  return createReactiveObject(target2, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target2) {
  return createReactiveObject(target2, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target2) {
  return createReactiveObject(target2, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target2, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target2)) {
    return target2;
  }
  if (target2["__v_raw"] && !(isReadonly2 && target2["__v_isReactive"])) {
    return target2;
  }
  const existingProxy = proxyMap.get(target2);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target2);
  if (targetType === 0) {
    return target2;
  }
  const proxy = new Proxy(target2, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target2, proxy);
  return proxy;
}
function isReactive(value2) {
  if (isReadonly(value2)) {
    return isReactive(value2["__v_raw"]);
  }
  return !!(value2 && value2["__v_isReactive"]);
}
function isReadonly(value2) {
  return !!(value2 && value2["__v_isReadonly"]);
}
function isShallow(value2) {
  return !!(value2 && value2["__v_isShallow"]);
}
function isProxy(value2) {
  return isReactive(value2) || isReadonly(value2);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value2) {
  def(value2, "__v_skip", true);
  return value2;
}
const toReactive = (value2) => isObject$2(value2) ? reactive(value2) : value2;
const toReadonly = (value2) => isObject$2(value2) ? readonly(value2) : value2;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value2) {
  return createRef(value2, false);
}
function shallowRef(value2) {
  return createRef(value2, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value2, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value2 : toRaw(value2);
    this._value = __v_isShallow ? value2 : toReactive(value2);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target2, key, receiver) => unref(Reflect.get(target2, key, receiver)),
  set: (target2, key, value2, receiver) => {
    const oldValue = target2[key];
    if (isRef(oldValue) && !isRef(value2)) {
      oldValue.value = value2;
      return true;
    } else {
      return Reflect.set(target2, key, value2, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray$1(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
var _a$1;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a$1] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a$1 = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$2(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args) {
  return;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$2(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError$1(err, type, contextVNode, throwInDev);
}
function logError$1(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue$1 = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue$1.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue$1[middle]);
    middleJobId < id2 ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue$1.length || !queue$1.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue$1.push(job);
    } else {
      queue$1.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue$1.indexOf(job);
  if (i > flushIndex) {
    queue$1.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$1(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue$1.length; i++) {
    const cb = queue$1[i];
    if (cb && cb.pre) {
      queue$1.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  queue$1.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue$1.length; flushIndex++) {
      const job = queue$1[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue$1.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue$1.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit$1(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a) => isString$2(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(toNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$2(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$1(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$2(normalized, raw);
  }
  if (isObject$2(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(render2.length > 1 ? render2(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit
      } : { attrs, slots, emit }) : render2(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits2 = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits2);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits2, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits2);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$1(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key, value2) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value2;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function watchPostEffect(effect, options) {
  return doWatch(effect, null, { flush: "post" });
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$2(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction$2(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value2, options) {
  const publicThis = this.proxy;
  const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$2(value2)) {
    cb = value2;
  } else {
    cb = value2.handler;
    options = value2;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value2, seen) {
  if (!isObject$2(value2) || value2["__v_skip"]) {
    return value2;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value2)) {
    return value2;
  }
  seen.add(value2);
  if (isRef(value2)) {
    traverse(value2.value, seen);
  } else if (isArray$1(value2)) {
    for (let i = 0; i < value2.length; i++) {
      traverse(value2[i], seen);
    }
  } else if (isSet(value2) || isMap(value2)) {
    value2.forEach((v2) => {
      traverse(v2, seen);
    });
  } else if (isPlainObject$2(value2)) {
    for (const key in value2) {
      traverse(value2[key], seen);
    }
  }
  return value2;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c of children) {
          if (c.type !== Comment) {
            child = c;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$1(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction$2(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter2) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter2 || !filter2(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || cached.type !== current.type) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches$1(include, name));
        exclude && pruneCache((name) => !matches$1(exclude, name));
      },
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      const { include, exclude, max } = props;
      if (include && (!name || !matches$1(include, name)) || exclude && name && matches$1(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches$1(pattern, name) {
  if (isArray$1(pattern)) {
    return pattern.some((p2) => matches$1(p2, name));
  } else if (isString$2(pattern)) {
    return pattern.split(",").includes(name);
  } else if (pattern.test) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target2) {
  registerKeepAliveHook(hook, "a", target2);
}
function onDeactivated(hook, target2) {
  registerKeepAliveHook(hook, "da", target2);
}
function registerKeepAliveHook(hook, type, target2 = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target2;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target2);
  if (target2) {
    let current = target2.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target2, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target2, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target2);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target2 = currentInstance, prepend = false) {
  if (target2) {
    const hooks = target2[type] || (target2[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target2.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target2);
      const res = callWithAsyncErrorHandling(hook, target2, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target2 = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target2);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target2 = currentInstance) {
  injectHook("ec", hook, target2);
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value2, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$2(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value2);
      }
      bindings.push({
        dir,
        instance,
        value: value2,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const COMPONENTS = "components";
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString$2(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component, false);
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray$1(source) || isString$2(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$2(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray$1(slot)) {
      for (let j2 = 0; j2 < slot.length; j2++) {
        slots[slot[j2].name] = slot[j2].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res)
          res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, {
    key: props.key || validSlotContent && validSlotContent.key || `_${name}`
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend$2(/* @__PURE__ */ Object.create(null), {
  $: (i) => i,
  $el: (i) => i.vnode.el,
  $data: (i) => i.data,
  $props: (i) => i.props,
  $attrs: (i) => i.attrs,
  $slots: (i) => i.slots,
  $refs: (i) => i.refs,
  $parent: (i) => getPublicInstance(i.parent),
  $root: (i) => getPublicInstance(i.root),
  $emit: (i) => i.emit,
  $options: (i) => resolveMergedOptions(i),
  $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
  $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
  $watch: (i) => instanceWatch.bind(i)
});
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value2) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value2;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value2;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value2;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target2, key, descriptor) {
    if (descriptor.get != null) {
      target2._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target2, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target2, key, descriptor);
  }
};
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components: components2,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v2) => c.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$1(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$1(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components2)
    instance.components = components2;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$1(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$2(raw)) {
    const handler = ctx[raw];
    if (isFunction$2(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$2(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$2(raw)) {
    if (isArray$1(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$2(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$2(isFunction$2(to) ? to.call(this, this) : to, isFunction$2(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$1(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$2(extend$2(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend$2(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value2 = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value2 !== attrs[key]) {
              attrs[key] = value2;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value2, instance, false);
          }
        } else {
          if (value2 !== attrs[key]) {
            attrs[key] = value2;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger$1(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value2 = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value2;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value2;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value2 !== attrs[key]) {
          attrs[key] = value2;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value2, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value2 === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value2 = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value2 = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value2 = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value2 = false;
      } else if (opt[1] && (value2 === "" || value2 === hyphenate(key))) {
        value2 = true;
      }
    }
  }
  return value2;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$2(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$1(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$2(opt) ? { type: opt } : Object.assign({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$2(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$1(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$2(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value2) => isArray$1(value2) ? value2.map(normalizeVNode) : [normalizeVNode(value2)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value2 = rawSlots[key];
    if (isFunction$2(value2)) {
      slots[key] = normalizeSlot(key, value2, ctx);
    } else if (value2 != null) {
      const normalized = normalizeSlotValue(value2);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$2(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$3 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$2(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$3++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$2(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction$2(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value2) {
        context.provides[key] = value2;
        return app2;
      }
    };
    return app2;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$1(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value2 = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$2(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$2(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value2, refs]);
  } else {
    const _isString = isString$2(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$1(existing) && remove(existing, refValue);
          } else {
            if (!isArray$1(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value2;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value2;
          }
        } else if (_isRef) {
          ref2.value = value2;
          if (rawRef.k)
            refs[rawRef.k] = value2;
        } else
          ;
      };
      if (value2) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target2 = getGlobalThis();
  target2.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement2(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement2 = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          hostParentNode(prevTree.el),
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update2),
      instance.scope
    );
    const update2 = instance.update = () => effect.run();
    update2.id = instance.uid;
    toggleRecurse(instance, true);
    update2();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved2 = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex2;
        if (prevChild.key != null) {
          newIndex2 = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex2 = j2;
              break;
            }
          }
        }
        if (newIndex2 === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex2 - s2] = i + 1;
          if (newIndex2 >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex2;
          } else {
            moved2 = true;
          }
          patch(prevChild, c2[newIndex2], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved2 ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved2) {
          if (j2 < 0 || i !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update: update2, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update2) {
      update2.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({ effect, update: update2 }, allowed) {
  effect.allowRecurse = update2.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$1(ch1) && isArray$1(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j2, u, v2, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i] = j2;
        result.push(i);
        continue;
      }
      u = 0;
      v2 = result.length - 1;
      while (u < v2) {
        c = u + v2 >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v2 = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v2 = result[u - 1];
  while (u-- > 0) {
    result[u] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target2) => typeof SVGElement !== "undefined" && target2 instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$2(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target2 = select(targetSelector);
      return target2;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target2 = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target2) {
        insert(targetAnchor, target2);
        isSVG = isSVG || isTargetSVG(target2);
      }
      const mount2 = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount2(container, mainAnchor);
      } else if (target2) {
        mount2(target2, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target2 = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target2;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target2);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target2, targetAnchor, internals, 1);
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target: target2, props } = vnode;
    if (target2) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target2 = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target2) {
    const targetNode = target2._lpa || target2.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target2._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(targetNode, vnode, target2, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value2) {
  isBlockTreeEnabled += value2;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value2) {
  return value2 ? value2.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$2(ref2) || isRef(ref2) || isFunction$2(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$2(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$2(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style)) {
      if (isProxy(style) && !isArray$1(style)) {
        style = extend$2({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$2(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$2({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$1(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$1(child)) {
    return createVNode(
      Fragment,
      null,
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$1(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$1$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$2(extend$2({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target2, key) {
      track(instance, "get", "$attrs");
      return target2[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target2, key) {
        if (key in target2) {
          return target2[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target2, key) {
        return key in target2 || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value2) {
  return isFunction$2(value2) && "__vccOpts" in value2;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$2(propsOrChildren) && !isArray$1(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol(``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
const version$1 = "3.2.45";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is2, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value2, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value2 = (value2 ? [value2, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value2 == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value2);
  } else {
    el.className = value2;
  }
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$2(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
    if (prev && !isString$2(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$1(val)) {
    val.forEach((v2) => setStyle(style, name, v2));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value2, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value2 == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value2);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value2 == null || isBoolean2 && !includeBooleanAttr(value2)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value2);
    }
  }
}
function patchDOMProp(el, key, value2, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value2 == null ? "" : value2;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value2;
    const newValue = value2 == null ? "" : value2;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value2 == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value2 === "" || value2 == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value2 = includeBooleanAttr(value2);
    } else if (value2 == null && type === "string") {
      value2 = "";
      needRemove = true;
    } else if (type === "number") {
      value2 = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value2;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value2) {
  if (isArray$1(value2)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value2.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value2;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value2, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction$2(value2)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$2(value2)) {
    return false;
  }
  return key in el;
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  };
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
    }
  }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$2({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray$1(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$2(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$2(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id2 = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id2 === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$2({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el._moveCb = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone2 = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
  clone2.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event);
    }
  };
};
const vShow = {
  beforeMount(el, { value: value2 }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value2) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value2);
    }
  },
  mounted(el, { value: value2 }, { transition }) {
    if (transition && value2) {
      transition.enter(el);
    }
  },
  updated(el, { value: value2, oldValue }, { transition }) {
    if (!value2 === !oldValue)
      return;
    if (transition) {
      if (value2) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value2);
    }
  },
  beforeUnmount(el, { value: value2 }) {
    setDisplay(el, value2);
  }
};
function setDisplay(el, value2) {
  el.style.display = value2 ? el._vod : "none";
}
const rendererOptions = /* @__PURE__ */ extend$2({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount: mount2 } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount2(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString$2(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var isVue2 = false;
/*!
  * pinia v2.0.27
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const piniaSymbol = Symbol();
function isPlainObject$1(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app2) {
      setActivePinia(pinia);
      {
        pinia._a = app2;
        app2.provide(piniaSymbol, pinia);
        app2.config.globalProperties.$pinia = pinia;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia;
}
const noop$3 = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop$3) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
function mergeReactiveObjects(target2, patchToApply) {
  if (target2 instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value2, key) => target2.set(key, value2));
  }
  if (target2 instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target2.add, target2);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target2[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target2.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target2[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target2[key] = subPatch;
    }
  }
  return target2;
}
const skipHydrateSymbol = Symbol();
function shouldHydrate(obj) {
  return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id2, options, pinia, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia.state.value[id2];
  let store;
  function setup() {
    if (!initialState && true) {
      {
        pinia.state.value[id2] = state ? state() : {};
      }
    }
    const localState = toRefs(pinia.state.value[id2]);
    return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id2);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id2, setup, options, pinia, hot, true);
  store.$reset = function $reset() {
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign($state, newState);
    });
  };
  return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign({ actions: {} }, options);
  const $subscribeOptions = {
    deep: true
  };
  let isListening;
  let isSyncListening;
  let subscriptions = markRaw([]);
  let actionSubscriptions = markRaw([]);
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    {
      pinia.state.value[$id] = {};
    }
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = noop$3;
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  function wrapAction(name, action) {
    return function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name,
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value2) => {
          triggerSubscriptions(afterCallbackList, value2);
          return value2;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const partialStore = {
    _p: pinia,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(partialStore);
  pinia._s.set($id, store);
  const setupStore = pinia._e.run(() => {
    scope = effectScope();
    return scope.run(() => setup());
  });
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = wrapAction(key, prop);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else
      ;
  }
  {
    assign(store, setupStore);
    assign(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign($state, state);
      });
    }
  });
  pinia._p.forEach((extender) => {
    {
      assign(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup, setupOptions) {
  let id2;
  let options;
  const isSetupStore = typeof setup === "function";
  if (typeof idOrOptions === "string") {
    id2 = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  } else {
    options = idOrOptions;
    id2 = idOrOptions.id;
  }
  function useStore(pinia, hot) {
    const currentInstance2 = getCurrentInstance();
    pinia = pinia || currentInstance2 && inject(piniaSymbol);
    if (pinia)
      setActivePinia(pinia);
    pinia = activePinia;
    if (!pinia._s.has(id2)) {
      if (isSetupStore) {
        createSetupStore(id2, setup, options, pinia);
      } else {
        createOptionsStore(id2, options, pinia);
      }
    }
    const store = pinia._s.get(id2);
    return store;
  }
  useStore.$id = id2;
  return useStore;
}
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$1 = typeOfTest("string");
const isFunction$1 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction$1(val.pipe);
const isFormData = (thing) => {
  const pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction$1(thing.toString) && thing.toString() === pattern);
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global$1 = typeof self === "undefined" ? typeof global === "undefined" ? globalThis : global : self;
const isContextDefined = (context) => !isUndefined(context) && context !== _global$1;
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend$1 = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction$1(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str)) !== null) {
    arr.push(matches2);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[_-\s]([a-z\d])(\w*)/g,
    function replacer2(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value2 = obj[name];
    if (!isFunction$1(value2))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value2) => {
      obj[value2] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$2 = () => {
};
const toFiniteNumber = (value2, defaultValue) => {
  value2 = +value2;
  return Number.isFinite(value2) ? value2 : defaultValue;
};
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target2 = isArray(source) ? [] : {};
        forEach(source, (value2, key) => {
          const reducedValue = visit(value2, i + 1);
          !isUndefined(reducedValue) && (target2[key] = reducedValue);
        });
        stack[i] = void 0;
        return target2;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean,
  isObject: isObject$1,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend: extend$1,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$2,
  toFiniteNumber,
  findKey,
  global: _global$1,
  isContextDefined,
  toJSONObject
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var browser = typeof self == "object" ? self.FormData : window.FormData;
const FormData$2 = browser;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key) {
  return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function isSpecCompliant(thing) {
  return thing && utils.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
}
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData$2 || FormData)();
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option2, source) {
    return !utils.isUndefined(source[option2]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && isSpecCompliant(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value2) {
    if (value2 === null)
      return "";
    if (utils.isDate(value2)) {
      return value2.toISOString();
    }
    if (!useBlob && utils.isBlob(value2)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value2) || utils.isTypedArray(value2)) {
      return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
    }
    return value2;
  }
  function defaultVisitor(value2, key, path) {
    let arr = value2;
    if (value2 && !path && typeof value2 === "object") {
      if (utils.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value2 = JSON.stringify(value2);
      } else if (utils.isArray(value2) && isFlatArray(value2) || (utils.isFileList(value2) || utils.endsWith(key, "[]") && (arr = utils.toArray(value2)))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value2)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value2));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value2, path) {
    if (utils.isUndefined(value2))
      return;
    if (stack.indexOf(value2) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value2);
    utils.forEach(value2, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value2) {
  this._pairs.push([name, value2]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value2) {
    return encoder.call(this, value2, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = FormData;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value2, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value2)) {
        this.append(key, value2.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value2, target2, index2) {
    let name = path[index2++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils.isArray(target2) ? target2.length : name;
    if (isLast) {
      if (utils.hasOwnProp(target2, name)) {
        target2[name] = [target2[name], value2];
      } else {
        target2[name] = value2;
      }
      return !isNumericKey;
    }
    if (!target2[name] || !utils.isObject(target2[name])) {
      target2[name] = [];
    }
    const result = buildPath(path, value2, target2[name], index2);
    if (result && utils.isArray(target2[name])) {
      target2[name] = arrayToObject(target2[name]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name, value2) => {
      buildPath(parsePropPath(name), value2, obj, 0);
    });
    return obj;
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults$2 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data);
    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults$2.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$2.headers[method] = {};
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$2.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
const defaults$3 = defaults$2;
const ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value2) {
  if (value2 === false || value2 == null) {
    return value2;
  }
  return utils.isArray(value2) ? value2.map(normalizeValue) : String(value2);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
function isValidHeaderName(str) {
  return /^[-_a-zA-Z]+$/.test(str.trim());
}
function matchHeaderValue(context, value2, header, filter2) {
  if (utils.isFunction(filter2)) {
    return filter2.call(this, value2, header);
  }
  if (!utils.isString(value2))
    return;
  if (utils.isString(filter2)) {
    return value2.indexOf(filter2) !== -1;
  }
  if (utils.isRegExp(filter2)) {
    return filter2.test(value2);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      if (key) {
        const value2 = this[key];
        if (!parser) {
          return value2;
        }
        if (parser === true) {
          return parseTokens(value2);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value2, key);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value2);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear() {
    return Object.keys(this).forEach(this.delete.bind(this));
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value2, header) => {
      const key = utils.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value2);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value2);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(this, (value2, header) => {
      value2 != null && value2 !== false && (obj[header] = asStrings && utils.isArray(value2) ? value2.join(", ") : value2);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value2]) => header + ": " + value2).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target2) => computed2.set(target2));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$3;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value2) {
  return !!(value2 && value2.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
const httpAdapter = null;
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.isStandardBrowserEnv ? function standardBrowserEnv() {
  return {
    write: function write(name, value2, expires, path, domain, secure) {
      const cookie = [];
      cookie.push(name + "=" + encodeURIComponent(value2));
      if (utils.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove2(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write() {
    },
    read: function read() {
      return null;
    },
    remove: function remove2() {
    }
  };
}();
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? function standardBrowserEnv2() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement("a");
  let originURL;
  function resolveURL(url) {
    let href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false);
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value2) {
        resolve2(value2);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError2() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn, value2) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value: value2 });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value: value2 });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$3.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target2, source, caseless) {
    if (utils.isPlainObject(target2) && utils.isPlainObject(source)) {
      return utils.merge.call({ caseless }, target2, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.2.1";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value2, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value2, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value2 = options[opt];
      const result = value2 === void 0 || validator2(value2, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer !== void 0) {
      validator.assertOptions(paramsSerializer, {
        encode: validators.function,
        serialize: validators.function
      }, true);
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );
    contextHeaders && utils.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$3);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.default = axios;
const axios$1 = axios;
var _a;
const isClient = typeof window !== "undefined";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const noop$1 = () => {
};
isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function resolveUnref(r) {
  return typeof r === "function" ? r() : unref(r);
}
function createFilterWrapper(filter2, fn) {
  function wrapper(...args) {
    filter2(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}
function identity(arg) {
  return arg;
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target2 = {};
  for (var prop in source)
    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
        target2[prop] = source[prop];
    }
  return target2;
};
function watchWithFilter(source, cb, options = {}) {
  const _a2 = options, {
    eventFilter = bypassFilter
  } = _a2, watchOptions = __objRest$5(_a2, [
    "eventFilter"
  ]);
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value2) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
var __objRest$1 = (source, exclude) => {
  var target2 = {};
  for (var prop in source)
    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
        target2[prop] = source[prop];
    }
  return target2;
};
function watchPausable(source, cb, options = {}) {
  const _a2 = options, {
    eventFilter: filter2
  } = _a2, watchOptions = __objRest$1(_a2, [
    "eventFilter"
  ]);
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
  const stop2 = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {
    eventFilter
  }));
  return { stop: stop2, pause, resume, isActive };
}
function unrefElement(elRef) {
  var _a2;
  const plain = resolveUnref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow = isClient ? window : void 0;
isClient ? window.document : void 0;
isClient ? window.navigator : void 0;
isClient ? window.location : void 0;
function useEventListener(...args) {
  let target2;
  let events;
  let listeners;
  let options;
  if (isString(args[0]) || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target2 = defaultWindow;
  } else {
    [target2, events, listeners, options] = args;
  }
  if (!target2)
    return noop$1;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const stopWatch = watch(() => unrefElement(target2), (el) => {
    cleanup();
    if (!el)
      return;
    cleanups.push(...events.flatMap((event) => {
      return listeners.map((listener) => register(el, event, listener));
    }));
  }, { immediate: true, flush: "post" });
  const stop2 = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop2);
  return stop2;
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
const handlers$2 = _global[globalKey];
function getSSRHandler(key, fallback) {
  return handlers$2[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
var __defProp$j = Object.defineProperty;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key, value2) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$j = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$l.call(b, prop))
      __defNormalProp$j(a, prop, b[prop]);
  if (__getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(b)) {
      if (__propIsEnum$l.call(b, prop))
        __defNormalProp$j(a, prop, b[prop]);
    }
  return a;
};
const StorageSerializers = {
  boolean: {
    read: (v2) => v2 === "true",
    write: (v2) => String(v2)
  },
  object: {
    read: (v2) => JSON.parse(v2),
    write: (v2) => JSON.stringify(v2)
  },
  number: {
    read: (v2) => Number.parseFloat(v2),
    write: (v2) => String(v2)
  },
  any: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  string: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  map: {
    read: (v2) => new Map(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  },
  set: {
    read: (v2) => new Set(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2))
  },
  date: {
    read: (v2) => new Date(v2),
    write: (v2) => v2.toISOString()
  }
};
function useStorage(key, defaults2, storage, options = {}) {
  var _a2;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  const data = (shallow ? shallowRef : ref)(defaults2);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a22;
        return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage)
    return data;
  const rawInit = resolveUnref(defaults2);
  const type = guessSerializerType(rawInit);
  const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(data, () => write(data.value), { flush, deep, eventFilter });
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", update2);
  update2();
  return data;
  function write(v2) {
    try {
      if (v2 == null)
        storage.removeItem(key);
      else
        storage.setItem(key, serializer.write(v2));
    } catch (e) {
      onError(e);
    }
  }
  function read(event) {
    pauseWatch();
    try {
      const rawValue = event ? event.newValue : storage.getItem(key);
      if (rawValue == null) {
        if (writeDefaults && rawInit !== null)
          storage.setItem(key, serializer.write(rawInit));
        return rawInit;
      } else if (!event && mergeDefaults) {
        const value2 = serializer.read(rawValue);
        if (isFunction(mergeDefaults))
          return mergeDefaults(value2, rawInit);
        else if (type === "object" && !Array.isArray(value2))
          return __spreadValues$j(__spreadValues$j({}, rawInit), value2);
        return value2;
      } else if (typeof rawValue !== "string") {
        return rawValue;
      } else {
        return serializer.read(rawValue);
      }
    } catch (e) {
      onError(e);
    } finally {
      resumeWatch();
    }
  }
  function update2(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key === null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== key)
      return;
    data.value = read(event);
  }
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
__spreadValues({
  linear: identity
}, _TransitionPresets);
const useSettingsStore = defineStore("settings", () => {
  const komfUrl = useStorage("komf-url", "http://localhost:8085");
  const mediaServer = ref();
  return { komfUrl, mediaServer };
});
class KomfMetadataService {
  constructor(http2) {
    __publicField(this, "http");
    __publicField(this, "settings", useSettingsStore());
    this.http = http2;
  }
  async searchSeries(seriesName, libraryId, seriesId) {
    try {
      return (await this.http.get(`${this.settings.komfUrl}/${this.settings.mediaServer}/search`, {
        params: { name: seriesName, libraryId, seriesId },
        paramsSerializer: { indexes: null }
      })).data;
    } catch (e) {
      let msg = "Failed to retrieve search results";
      if (axios$1.isAxiosError(e)) {
        msg += `: ${e.message}`;
      }
      throw new Error(msg);
    }
  }
  async identifySeries(request) {
    try {
      await this.http.post(`${this.settings.komfUrl}/${this.settings.mediaServer}/identify`, request);
    } catch (e) {
      let msg = "Failed to identify series";
      if (axios$1.isAxiosError(e)) {
        msg += `: ${e.message}`;
      }
      throw new Error(msg);
    }
  }
  async matchLibrary(libraryId) {
    var _a2;
    try {
      await this.http.post(
        `${this.settings.komfUrl}/${this.settings.mediaServer}/match/library/${libraryId}`
      );
    } catch (e) {
      let msg = "Failed to match library";
      if (axios$1.isAxiosError(e)) {
        if (((_a2 = e.response) == null ? void 0 : _a2.status) == 409)
          msg += ": Scan is already in progress";
        else
          msg += `: ${e.message}`;
      }
      throw new Error(msg);
    }
  }
  async matchSeries(libraryId, seriesId) {
    try {
      await this.http.post(
        `${this.settings.komfUrl}/${this.settings.mediaServer}/match/library/${libraryId}/series/${seriesId}`
      );
    } catch (e) {
      let msg = "Failed to match series";
      if (axios$1.isAxiosError(e)) {
        msg += `: ${e.message}`;
      }
      throw new Error(msg);
    }
  }
  async resetSeries(libraryId, seriesId) {
    try {
      await this.http.post(
        `${this.settings.komfUrl}/${this.settings.mediaServer}/reset/library/${libraryId}/series/${seriesId}`
      );
    } catch (e) {
      let msg = "Failed to reset series";
      if (axios$1.isAxiosError(e)) {
        msg += `: ${e.message}`;
      }
      throw new Error(msg);
    }
  }
  async resetLibrary(libraryId) {
    try {
      await this.http.post(
        `${this.settings.komfUrl}/${this.settings.mediaServer}/reset/library/${libraryId}`
      );
    } catch (e) {
      let msg = "Failed to reset library";
      if (axios$1.isAxiosError(e)) {
        msg += `: ${e.message}`;
      }
      throw new Error(msg);
    }
  }
  async checkConnection(url) {
    let data;
    try {
      data = (await this.http.get(`${url}/${this.settings.mediaServer}/providers`)).data;
    } catch (e) {
      let msg = "Connection Failed";
      if (axios$1.isAxiosError(e)) {
        msg = e.message;
      }
      throw new Error(msg);
    }
    if (!Array.isArray(data)) {
      throw new Error("Connection Failed");
    }
  }
}
const httpKey = Symbol();
const komfMetadataKey = Symbol();
const komfConfigKey = Symbol();
function injectProp(target2, propName, get2, set2) {
  Object.defineProperty(target2, propName, {
    get: get2,
    set: set2,
    enumerable: true
  });
  return target2;
}
const isRuntimeSsrPreHydration = ref(
  false
);
let iosCorrection;
function getMatch(userAgent2, platformMatch) {
  const match = /(edg|edge|edga|edgios)\/([\w.]+)/.exec(userAgent2) || /(opr)[\/]([\w.]+)/.exec(userAgent2) || /(vivaldi)[\/]([\w.]+)/.exec(userAgent2) || /(chrome|crios)[\/]([\w.]+)/.exec(userAgent2) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent2) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent2) || /(firefox|fxios)[\/]([\w.]+)/.exec(userAgent2) || /(webkit)[\/]([\w.]+)/.exec(userAgent2) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(userAgent2) || [];
  return {
    browser: match[5] || match[3] || match[1] || "",
    version: match[2] || match[4] || "0",
    versionNumber: match[4] || match[2] || "0",
    platform: platformMatch[0] || ""
  };
}
function getPlatformMatch(userAgent2) {
  return /(ipad)/.exec(userAgent2) || /(ipod)/.exec(userAgent2) || /(windows phone)/.exec(userAgent2) || /(iphone)/.exec(userAgent2) || /(kindle)/.exec(userAgent2) || /(silk)/.exec(userAgent2) || /(android)/.exec(userAgent2) || /(win)/.exec(userAgent2) || /(mac)/.exec(userAgent2) || /(linux)/.exec(userAgent2) || /(cros)/.exec(userAgent2) || /(playbook)/.exec(userAgent2) || /(bb)/.exec(userAgent2) || /(blackberry)/.exec(userAgent2) || [];
}
const hasTouch = "ontouchstart" in window || window.navigator.maxTouchPoints > 0;
function applyIosCorrection(is2) {
  iosCorrection = { is: { ...is2 } };
  delete is2.mac;
  delete is2.desktop;
  const platform2 = Math.min(window.innerHeight, window.innerWidth) > 414 ? "ipad" : "iphone";
  Object.assign(is2, {
    mobile: true,
    ios: true,
    platform: platform2,
    [platform2]: true
  });
}
function getPlatform(UA) {
  const userAgent2 = UA.toLowerCase(), platformMatch = getPlatformMatch(userAgent2), matched = getMatch(userAgent2, platformMatch), browser2 = {};
  if (matched.browser) {
    browser2[matched.browser] = true;
    browser2.version = matched.version;
    browser2.versionNumber = parseInt(matched.versionNumber, 10);
  }
  if (matched.platform) {
    browser2[matched.platform] = true;
  }
  const knownMobiles = browser2.android || browser2.ios || browser2.bb || browser2.blackberry || browser2.ipad || browser2.iphone || browser2.ipod || browser2.kindle || browser2.playbook || browser2.silk || browser2["windows phone"];
  if (knownMobiles === true || userAgent2.indexOf("mobile") > -1) {
    browser2.mobile = true;
    if (browser2.edga || browser2.edgios) {
      browser2.edge = true;
      matched.browser = "edge";
    } else if (browser2.crios) {
      browser2.chrome = true;
      matched.browser = "chrome";
    } else if (browser2.fxios) {
      browser2.firefox = true;
      matched.browser = "firefox";
    }
  } else {
    browser2.desktop = true;
  }
  if (browser2.ipod || browser2.ipad || browser2.iphone) {
    browser2.ios = true;
  }
  if (browser2["windows phone"]) {
    browser2.winphone = true;
    delete browser2["windows phone"];
  }
  if (browser2.chrome || browser2.opr || browser2.safari || browser2.vivaldi || browser2.mobile === true && browser2.ios !== true && knownMobiles !== true) {
    browser2.webkit = true;
  }
  if (browser2.edg) {
    matched.browser = "edgechromium";
    browser2.edgeChromium = true;
  }
  if (browser2.safari && browser2.blackberry || browser2.bb) {
    matched.browser = "blackberry";
    browser2.blackberry = true;
  }
  if (browser2.safari && browser2.playbook) {
    matched.browser = "playbook";
    browser2.playbook = true;
  }
  if (browser2.opr) {
    matched.browser = "opera";
    browser2.opera = true;
  }
  if (browser2.safari && browser2.android) {
    matched.browser = "android";
    browser2.android = true;
  }
  if (browser2.safari && browser2.kindle) {
    matched.browser = "kindle";
    browser2.kindle = true;
  }
  if (browser2.safari && browser2.silk) {
    matched.browser = "silk";
    browser2.silk = true;
  }
  if (browser2.vivaldi) {
    matched.browser = "vivaldi";
    browser2.vivaldi = true;
  }
  browser2.name = matched.browser;
  browser2.platform = matched.platform;
  {
    if (userAgent2.indexOf("electron") > -1) {
      browser2.electron = true;
    } else if (document.location.href.indexOf("-extension://") > -1) {
      browser2.bex = true;
    } else {
      if (window.Capacitor !== void 0) {
        browser2.capacitor = true;
        browser2.nativeMobile = true;
        browser2.nativeMobileWrapper = "capacitor";
      } else if (window._cordovaNative !== void 0 || window.cordova !== void 0) {
        browser2.cordova = true;
        browser2.nativeMobile = true;
        browser2.nativeMobileWrapper = "cordova";
      }
      if (hasTouch === true && browser2.mac === true && (browser2.desktop === true && browser2.safari === true || browser2.nativeMobile === true && browser2.android !== true && browser2.ios !== true && browser2.ipad !== true)) {
        applyIosCorrection(browser2);
      }
    }
  }
  return browser2;
}
const userAgent$1 = navigator.userAgent || navigator.vendor || window.opera;
const ssrClient = {
  has: {
    touch: false,
    webStorage: false
  },
  within: { iframe: false }
};
const client = {
  userAgent: userAgent$1,
  is: getPlatform(userAgent$1),
  has: {
    touch: hasTouch
  },
  within: {
    iframe: window.self !== window.top
  }
};
const Platform = {
  install(opts) {
    const { $q } = opts;
    if (isRuntimeSsrPreHydration.value === true) {
      opts.onSSRHydrated.push(() => {
        isRuntimeSsrPreHydration.value = false;
        Object.assign($q.platform, client);
        iosCorrection = void 0;
      });
      $q.platform = reactive(this);
    } else {
      $q.platform = this;
    }
  }
};
{
  let hasWebStorage;
  injectProp(client.has, "webStorage", () => {
    if (hasWebStorage !== void 0) {
      return hasWebStorage;
    }
    try {
      if (window.localStorage) {
        hasWebStorage = true;
        return true;
      }
    } catch (e) {
    }
    hasWebStorage = false;
    return false;
  });
  client.is.ios === true && window.navigator.vendor.toLowerCase().indexOf("apple") === -1;
  if (isRuntimeSsrPreHydration.value === true) {
    Object.assign(Platform, client, iosCorrection, ssrClient);
  } else {
    Object.assign(Platform, client);
  }
}
const listenOpts = {
  hasPassive: false,
  passiveCapture: true,
  notPassiveCapture: true
};
try {
  const opts = Object.defineProperty({}, "passive", {
    get() {
      Object.assign(listenOpts, {
        hasPassive: true,
        passive: { passive: true },
        notPassive: { passive: false },
        passiveCapture: { passive: true, capture: true },
        notPassiveCapture: { passive: false, capture: true }
      });
    }
  });
  window.addEventListener("qtest", null, opts);
  window.removeEventListener("qtest", null, opts);
} catch (e) {
}
function noop() {
}
function leftClick(e) {
  return e.button === 0;
}
function position(e) {
  if (e.touches && e.touches[0]) {
    e = e.touches[0];
  } else if (e.changedTouches && e.changedTouches[0]) {
    e = e.changedTouches[0];
  } else if (e.targetTouches && e.targetTouches[0]) {
    e = e.targetTouches[0];
  }
  return {
    top: e.clientY,
    left: e.clientX
  };
}
function getEventPath(e) {
  if (e.path) {
    return e.path;
  }
  if (e.composedPath) {
    return e.composedPath();
  }
  const path = [];
  let el = e.target;
  while (el) {
    path.push(el);
    if (el.tagName === "HTML") {
      path.push(document);
      path.push(window);
      return path;
    }
    el = el.parentElement;
  }
}
function stop(e) {
  e.stopPropagation();
}
function prevent(e) {
  e.cancelable !== false && e.preventDefault();
}
function stopAndPrevent(e) {
  e.cancelable !== false && e.preventDefault();
  e.stopPropagation();
}
function preventDraggable(el, status) {
  if (el === void 0 || status === true && el.__dragPrevented === true) {
    return;
  }
  const fn = status === true ? (el2) => {
    el2.__dragPrevented = true;
    el2.addEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
  } : (el2) => {
    delete el2.__dragPrevented;
    el2.removeEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
  };
  el.querySelectorAll("a, img").forEach(fn);
}
function addEvt(ctx, targetName, events) {
  const name = `__q_${targetName}_evt`;
  ctx[name] = ctx[name] !== void 0 ? ctx[name].concat(events) : events;
  events.forEach((evt) => {
    evt[0].addEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
  });
}
function cleanEvt(ctx, targetName) {
  const name = `__q_${targetName}_evt`;
  if (ctx[name] !== void 0) {
    ctx[name].forEach((evt) => {
      evt[0].removeEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
    });
    ctx[name] = void 0;
  }
}
const getTrue = () => true;
function filterInvalidPath(path) {
  return typeof path === "string" && path !== "" && path !== "/" && path !== "#/";
}
function normalizeExitPath(path) {
  path.startsWith("#") === true && (path = path.substring(1));
  path.startsWith("/") === false && (path = "/" + path);
  path.endsWith("/") === true && (path = path.substring(0, path.length - 1));
  return "#" + path;
}
function getShouldExitFn(cfg) {
  if (cfg.backButtonExit === false) {
    return () => false;
  }
  if (cfg.backButtonExit === "*") {
    return getTrue;
  }
  const exitPaths = ["#/"];
  Array.isArray(cfg.backButtonExit) === true && exitPaths.push(
    ...cfg.backButtonExit.filter(filterInvalidPath).map(normalizeExitPath)
  );
  return () => exitPaths.includes(window.location.hash);
}
const History = {
  __history: [],
  add: noop,
  remove: noop,
  install({ $q }) {
    if (this.__installed === true) {
      return;
    }
    const { cordova, capacitor } = client.is;
    if (cordova !== true && capacitor !== true) {
      return;
    }
    const qConf = $q.config[cordova === true ? "cordova" : "capacitor"];
    if (qConf !== void 0 && qConf.backButton === false) {
      return;
    }
    if (capacitor === true && (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0)) {
      return;
    }
    this.add = (entry) => {
      if (entry.condition === void 0) {
        entry.condition = getTrue;
      }
      this.__history.push(entry);
    };
    this.remove = (entry) => {
      const index2 = this.__history.indexOf(entry);
      if (index2 >= 0) {
        this.__history.splice(index2, 1);
      }
    };
    const shouldExit = getShouldExitFn(
      Object.assign(
        { backButtonExit: true },
        qConf
      )
    );
    const backHandler = () => {
      if (this.__history.length) {
        const entry = this.__history[this.__history.length - 1];
        if (entry.condition() === true) {
          this.__history.pop();
          entry.handler();
        }
      } else if (shouldExit() === true) {
        navigator.app.exitApp();
      } else {
        window.history.back();
      }
    };
    if (cordova === true) {
      document.addEventListener("deviceready", () => {
        document.addEventListener("backbutton", backHandler, false);
      });
    } else {
      window.Capacitor.Plugins.App.addListener("backButton", backHandler);
    }
  }
};
function useHistory(showing, hide, hideOnRouteChange) {
  let historyEntry;
  function removeFromHistory() {
    if (historyEntry !== void 0) {
      History.remove(historyEntry);
      historyEntry = void 0;
    }
  }
  onBeforeUnmount(() => {
    showing.value === true && removeFromHistory();
  });
  return {
    removeFromHistory,
    addToHistory() {
      historyEntry = {
        condition: () => hideOnRouteChange.value === true,
        handler: hide
      };
      History.add(historyEntry);
    }
  };
}
function getParentProxy(proxy) {
  if (Object(proxy.$parent) === proxy.$parent) {
    return proxy.$parent;
  }
  let { parent } = proxy.$;
  while (Object(parent) === parent) {
    if (Object(parent.proxy) === parent.proxy) {
      return parent.proxy;
    }
    parent = parent.parent;
  }
}
function fillNormalizedVNodes(children, vnode) {
  if (typeof vnode.type === "symbol") {
    if (Array.isArray(vnode.children) === true) {
      vnode.children.forEach((child) => {
        fillNormalizedVNodes(children, child);
      });
    }
  } else {
    children.add(vnode);
  }
}
function getNormalizedVNodes(vnodes) {
  const children = /* @__PURE__ */ new Set();
  vnodes.forEach((vnode) => {
    fillNormalizedVNodes(children, vnode);
  });
  return Array.from(children);
}
function vmHasRouter(vm) {
  return vm.appContext.config.globalProperties.$router !== void 0;
}
function vmIsDestroyed(vm) {
  return vm.isUnmounted === true || vm.isDeactivated === true;
}
function useTimeout() {
  let timer2;
  const vm = getCurrentInstance();
  function removeTimeout() {
    clearTimeout(timer2);
  }
  onDeactivated(removeTimeout);
  onBeforeUnmount(removeTimeout);
  return {
    removeTimeout,
    registerTimeout(fn, delay) {
      clearTimeout(timer2);
      if (vmIsDestroyed(vm) === false) {
        timer2 = setTimeout(fn, delay);
      }
    }
  };
}
function useTick() {
  let tickFn;
  const vm = getCurrentInstance();
  function removeTick() {
    tickFn = void 0;
  }
  onDeactivated(removeTick);
  onBeforeUnmount(removeTick);
  return {
    removeTick,
    registerTick(fn) {
      tickFn = fn;
      nextTick(() => {
        if (tickFn === fn) {
          vmIsDestroyed(vm) === false && tickFn();
          tickFn = void 0;
        }
      });
    }
  };
}
const useModelToggleProps = {
  modelValue: {
    type: Boolean,
    default: null
  },
  "onUpdate:modelValue": [Function, Array]
};
const useModelToggleEmits = [
  "beforeShow",
  "show",
  "beforeHide",
  "hide"
];
function useModelToggle({
  showing,
  canShow,
  hideOnRouteChange,
  handleShow,
  handleHide,
  processOnMount
}) {
  const vm = getCurrentInstance();
  const { props, emit, proxy } = vm;
  let payload;
  function toggle(evt) {
    if (showing.value === true) {
      hide(evt);
    } else {
      show(evt);
    }
  }
  function show(evt) {
    if (props.disable === true || evt !== void 0 && evt.qAnchorHandled === true || canShow !== void 0 && canShow(evt) !== true) {
      return;
    }
    const listener = props["onUpdate:modelValue"] !== void 0;
    if (listener === true && true) {
      emit("update:modelValue", true);
      payload = evt;
      nextTick(() => {
        if (payload === evt) {
          payload = void 0;
        }
      });
    }
    if (props.modelValue === null || listener === false || false) {
      processShow(evt);
    }
  }
  function processShow(evt) {
    if (showing.value === true) {
      return;
    }
    showing.value = true;
    emit("beforeShow", evt);
    if (handleShow !== void 0) {
      handleShow(evt);
    } else {
      emit("show", evt);
    }
  }
  function hide(evt) {
    if (props.disable === true) {
      return;
    }
    const listener = props["onUpdate:modelValue"] !== void 0;
    if (listener === true && true) {
      emit("update:modelValue", false);
      payload = evt;
      nextTick(() => {
        if (payload === evt) {
          payload = void 0;
        }
      });
    }
    if (props.modelValue === null || listener === false || false) {
      processHide(evt);
    }
  }
  function processHide(evt) {
    if (showing.value === false) {
      return;
    }
    showing.value = false;
    emit("beforeHide", evt);
    if (handleHide !== void 0) {
      handleHide(evt);
    } else {
      emit("hide", evt);
    }
  }
  function processModelChange(val) {
    if (props.disable === true && val === true) {
      if (props["onUpdate:modelValue"] !== void 0) {
        emit("update:modelValue", false);
      }
    } else if (val === true !== showing.value) {
      const fn = val === true ? processShow : processHide;
      fn(payload);
    }
  }
  watch(() => props.modelValue, processModelChange);
  if (hideOnRouteChange !== void 0 && vmHasRouter(vm) === true) {
    watch(() => proxy.$route.fullPath, () => {
      if (hideOnRouteChange.value === true && showing.value === true) {
        hide();
      }
    });
  }
  processOnMount === true && onMounted(() => {
    processModelChange(props.modelValue);
  });
  const publicMethods = { show, hide, toggle };
  Object.assign(proxy, publicMethods);
  return publicMethods;
}
const useTransitionProps = {
  transitionShow: {
    type: String,
    default: "fade"
  },
  transitionHide: {
    type: String,
    default: "fade"
  },
  transitionDuration: {
    type: [String, Number],
    default: 300
  }
};
function useTransition(props, defaultShowFn = () => {
}, defaultHideFn = () => {
}) {
  return {
    transitionProps: computed(() => {
      const show = `q-transition--${props.transitionShow || defaultShowFn()}`;
      const hide = `q-transition--${props.transitionHide || defaultHideFn()}`;
      return {
        appear: true,
        enterFromClass: `${show}-enter-from`,
        enterActiveClass: `${show}-enter-active`,
        enterToClass: `${show}-enter-to`,
        leaveFromClass: `${hide}-leave-from`,
        leaveActiveClass: `${hide}-leave-active`,
        leaveToClass: `${hide}-leave-to`
      };
    }),
    transitionStyle: computed(() => `--q-transition-duration: ${props.transitionDuration}ms`)
  };
}
let queue = [];
let waitFlags = [];
function clearFlag(flag) {
  waitFlags = waitFlags.filter((entry) => entry !== flag);
}
function addFocusWaitFlag(flag) {
  clearFlag(flag);
  waitFlags.push(flag);
}
function removeFocusWaitFlag(flag) {
  clearFlag(flag);
  if (waitFlags.length === 0 && queue.length > 0) {
    queue[queue.length - 1]();
    queue = [];
  }
}
function addFocusFn(fn) {
  if (waitFlags.length === 0) {
    fn();
  } else {
    queue.push(fn);
  }
}
function removeFocusFn(fn) {
  queue = queue.filter((entry) => entry !== fn);
}
const globalConfig = {};
let globalConfigIsFrozen = false;
function freezeGlobalConfig() {
  globalConfigIsFrozen = true;
}
let target = document.body;
function createGlobalNode(id2) {
  const el = document.createElement("div");
  if (id2 !== void 0) {
    el.id = id2;
  }
  if (globalConfig.globalNodes !== void 0) {
    const cls = globalConfig.globalNodes.class;
    if (cls !== void 0) {
      el.className = cls;
    }
  }
  target.appendChild(el);
  return el;
}
function removeGlobalNode(el) {
  el.remove();
}
const portalProxyList = [];
function getPortalProxy(el) {
  return portalProxyList.find(
    (proxy) => proxy.contentEl !== null && proxy.contentEl.contains(el)
  );
}
function closePortalMenus(proxy, evt) {
  do {
    if (proxy.$options.name === "QMenu") {
      proxy.hide(evt);
      if (proxy.$props.separateClosePopup === true) {
        return getParentProxy(proxy);
      }
    } else if (proxy.__qPortal === true) {
      const parent = getParentProxy(proxy);
      if (parent !== void 0 && parent.$options.name === "QPopupProxy") {
        proxy.hide(evt);
        return parent;
      } else {
        return proxy;
      }
    }
    proxy = getParentProxy(proxy);
  } while (proxy !== void 0 && proxy !== null);
}
function closePortals(proxy, evt, depth) {
  while (depth !== 0 && proxy !== void 0 && proxy !== null) {
    if (proxy.__qPortal === true) {
      depth--;
      if (proxy.$options.name === "QMenu") {
        proxy = closePortalMenus(proxy, evt);
        continue;
      }
      proxy.hide(evt);
    }
    proxy = getParentProxy(proxy);
  }
}
function isOnGlobalDialog(vm) {
  vm = vm.parent;
  while (vm !== void 0 && vm !== null) {
    if (vm.type.name === "QGlobalDialog") {
      return true;
    }
    if (vm.type.name === "QDialog" || vm.type.name === "QMenu") {
      return false;
    }
    vm = vm.parent;
  }
  return false;
}
function usePortal(vm, innerRef, renderPortalContent, checkGlobalDialog) {
  const portalIsActive = ref(false);
  const portalIsAccessible = ref(false);
  let portalEl = null;
  const focusObj = {};
  const onGlobalDialog = checkGlobalDialog === true && isOnGlobalDialog(vm);
  function showPortal(isReady) {
    if (isReady === true) {
      removeFocusWaitFlag(focusObj);
      portalIsAccessible.value = true;
      return;
    }
    portalIsAccessible.value = false;
    if (portalIsActive.value === false) {
      if (onGlobalDialog === false && portalEl === null) {
        portalEl = createGlobalNode();
      }
      portalIsActive.value = true;
      portalProxyList.push(vm.proxy);
      addFocusWaitFlag(focusObj);
    }
  }
  function hidePortal(isReady) {
    portalIsAccessible.value = false;
    if (isReady !== true) {
      return;
    }
    removeFocusWaitFlag(focusObj);
    portalIsActive.value = false;
    const index2 = portalProxyList.indexOf(vm.proxy);
    if (index2 !== -1) {
      portalProxyList.splice(index2, 1);
    }
    if (portalEl !== null) {
      removeGlobalNode(portalEl);
      portalEl = null;
    }
  }
  onUnmounted(() => {
    hidePortal(true);
  });
  vm.proxy.__qPortal = true;
  injectProp(vm.proxy, "contentEl", () => innerRef.value);
  return {
    showPortal,
    hidePortal,
    portalIsActive,
    portalIsAccessible,
    renderPortal: () => onGlobalDialog === true ? renderPortalContent() : portalIsActive.value === true ? [h(Teleport, { to: portalEl }, renderPortalContent())] : void 0
  };
}
function css$1(element, css2) {
  const style = element.style;
  for (const prop in css2) {
    style[prop] = css2[prop];
  }
}
function getElement(el) {
  if (el === void 0 || el === null) {
    return void 0;
  }
  if (typeof el === "string") {
    try {
      return document.querySelector(el) || void 0;
    } catch (err) {
      return void 0;
    }
  }
  const target2 = unref(el);
  if (target2) {
    return target2.$el || target2;
  }
}
function childHasFocus(el, focusedEl) {
  if (el === void 0 || el === null || el.contains(focusedEl) === true) {
    return true;
  }
  for (let next = el.nextElementSibling; next !== null; next = next.nextElementSibling) {
    if (next.contains(focusedEl)) {
      return true;
    }
  }
  return false;
}
const scrollTargets = [null, document, document.body, document.scrollingElement, document.documentElement];
function getScrollTarget(el, targetEl) {
  let target2 = getElement(targetEl);
  if (target2 === void 0) {
    if (el === void 0 || el === null) {
      return window;
    }
    target2 = el.closest(".scroll,.scroll-y,.overflow-auto");
  }
  return scrollTargets.includes(target2) ? window : target2;
}
function getVerticalScrollPosition(scrollTarget) {
  return scrollTarget === window ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0 : scrollTarget.scrollTop;
}
function getHorizontalScrollPosition(scrollTarget) {
  return scrollTarget === window ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0 : scrollTarget.scrollLeft;
}
let size;
function getScrollbarWidth() {
  if (size !== void 0) {
    return size;
  }
  const inner = document.createElement("p"), outer = document.createElement("div");
  css$1(inner, {
    width: "100%",
    height: "200px"
  });
  css$1(outer, {
    position: "absolute",
    top: "0px",
    left: "0px",
    visibility: "hidden",
    width: "200px",
    height: "150px",
    overflow: "hidden"
  });
  outer.appendChild(inner);
  document.body.appendChild(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = "scroll";
  let w2 = inner.offsetWidth;
  if (w1 === w2) {
    w2 = outer.clientWidth;
  }
  outer.remove();
  size = w1 - w2;
  return size;
}
function hasScrollbar(el, onY = true) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  return onY ? el.scrollHeight > el.clientHeight && (el.classList.contains("scroll") || el.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(el)["overflow-y"])) : el.scrollWidth > el.clientWidth && (el.classList.contains("scroll") || el.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(el)["overflow-x"]));
}
let registered = 0, scrollPositionX, scrollPositionY, maxScrollTop, vpPendingUpdate = false, bodyLeft, bodyTop, closeTimer;
function onWheel(e) {
  if (shouldPreventScroll(e)) {
    stopAndPrevent(e);
  }
}
function shouldPreventScroll(e) {
  if (e.target === document.body || e.target.classList.contains("q-layout__backdrop")) {
    return true;
  }
  const path = getEventPath(e), shift = e.shiftKey && !e.deltaX, scrollY = !shift && Math.abs(e.deltaX) <= Math.abs(e.deltaY), delta = shift || scrollY ? e.deltaY : e.deltaX;
  for (let index2 = 0; index2 < path.length; index2++) {
    const el = path[index2];
    if (hasScrollbar(el, scrollY)) {
      return scrollY ? delta < 0 && el.scrollTop === 0 ? true : delta > 0 && el.scrollTop + el.clientHeight === el.scrollHeight : delta < 0 && el.scrollLeft === 0 ? true : delta > 0 && el.scrollLeft + el.clientWidth === el.scrollWidth;
    }
  }
  return true;
}
function onAppleScroll(e) {
  if (e.target === document) {
    document.scrollingElement.scrollTop = document.scrollingElement.scrollTop;
  }
}
function onAppleResize(evt) {
  if (vpPendingUpdate === true) {
    return;
  }
  vpPendingUpdate = true;
  requestAnimationFrame(() => {
    vpPendingUpdate = false;
    const { height } = evt.target, { clientHeight, scrollTop } = document.scrollingElement;
    if (maxScrollTop === void 0 || height !== window.innerHeight) {
      maxScrollTop = clientHeight - height;
      document.scrollingElement.scrollTop = scrollTop;
    }
    if (scrollTop > maxScrollTop) {
      document.scrollingElement.scrollTop -= Math.ceil((scrollTop - maxScrollTop) / 8);
    }
  });
}
function apply(action) {
  const body = document.body, hasViewport = window.visualViewport !== void 0;
  if (action === "add") {
    const { overflowY, overflowX } = window.getComputedStyle(body);
    scrollPositionX = getHorizontalScrollPosition(window);
    scrollPositionY = getVerticalScrollPosition(window);
    bodyLeft = body.style.left;
    bodyTop = body.style.top;
    body.style.left = `-${scrollPositionX}px`;
    body.style.top = `-${scrollPositionY}px`;
    if (overflowX !== "hidden" && (overflowX === "scroll" || body.scrollWidth > window.innerWidth)) {
      body.classList.add("q-body--force-scrollbar-x");
    }
    if (overflowY !== "hidden" && (overflowY === "scroll" || body.scrollHeight > window.innerHeight)) {
      body.classList.add("q-body--force-scrollbar-y");
    }
    body.classList.add("q-body--prevent-scroll");
    document.qScrollPrevented = true;
    if (client.is.ios === true) {
      if (hasViewport === true) {
        window.scrollTo(0, 0);
        window.visualViewport.addEventListener("resize", onAppleResize, listenOpts.passiveCapture);
        window.visualViewport.addEventListener("scroll", onAppleResize, listenOpts.passiveCapture);
        window.scrollTo(0, 0);
      } else {
        window.addEventListener("scroll", onAppleScroll, listenOpts.passiveCapture);
      }
    }
  }
  if (client.is.desktop === true && client.is.mac === true) {
    window[`${action}EventListener`]("wheel", onWheel, listenOpts.notPassive);
  }
  if (action === "remove") {
    if (client.is.ios === true) {
      if (hasViewport === true) {
        window.visualViewport.removeEventListener("resize", onAppleResize, listenOpts.passiveCapture);
        window.visualViewport.removeEventListener("scroll", onAppleResize, listenOpts.passiveCapture);
      } else {
        window.removeEventListener("scroll", onAppleScroll, listenOpts.passiveCapture);
      }
    }
    body.classList.remove("q-body--prevent-scroll");
    body.classList.remove("q-body--force-scrollbar-x");
    body.classList.remove("q-body--force-scrollbar-y");
    document.qScrollPrevented = false;
    body.style.left = bodyLeft;
    body.style.top = bodyTop;
    window.scrollTo(scrollPositionX, scrollPositionY);
    maxScrollTop = void 0;
  }
}
function preventScroll(state) {
  let action = "add";
  if (state === true) {
    registered++;
    if (closeTimer !== void 0) {
      clearTimeout(closeTimer);
      closeTimer = void 0;
      return;
    }
    if (registered > 1) {
      return;
    }
  } else {
    if (registered === 0) {
      return;
    }
    registered--;
    if (registered > 0) {
      return;
    }
    action = "remove";
    if (client.is.ios === true && client.is.nativeMobile === true) {
      clearTimeout(closeTimer);
      closeTimer = setTimeout(() => {
        apply(action);
        closeTimer = void 0;
      }, 100);
      return;
    }
  }
  apply(action);
}
function usePreventScroll() {
  let currentState;
  return {
    preventBodyScroll(state) {
      if (state !== currentState && (currentState !== void 0 || state === true)) {
        currentState = state;
        preventScroll(state);
      }
    }
  };
}
const createComponent = (raw) => markRaw(defineComponent(raw));
const createDirective = (raw) => markRaw(raw);
function hSlot(slot, otherwise) {
  return slot !== void 0 ? slot() || otherwise : otherwise;
}
function hUniqueSlot(slot, otherwise) {
  if (slot !== void 0) {
    const vnode = slot();
    if (vnode !== void 0 && vnode !== null) {
      return vnode.slice();
    }
  }
  return otherwise;
}
function hMergeSlot(slot, source) {
  return slot !== void 0 ? source.concat(slot()) : source;
}
function hMergeSlotSafely(slot, source) {
  if (slot === void 0) {
    return source;
  }
  return source !== void 0 ? source.concat(slot()) : slot();
}
function hDir(tag, data, children, key, condition, getDirsFn) {
  data.key = key + condition;
  const vnode = h(tag, data, children);
  return condition === true ? withDirectives(vnode, getDirsFn()) : vnode;
}
let lastKeyCompositionStatus = false;
function onKeyDownComposition(evt) {
  lastKeyCompositionStatus = evt.isComposing === true;
}
function shouldIgnoreKey(evt) {
  return lastKeyCompositionStatus === true || evt !== Object(evt) || evt.isComposing === true || evt.qKeyEvent === true;
}
function isKeyCode(evt, keyCodes) {
  return shouldIgnoreKey(evt) === true ? false : [].concat(keyCodes).includes(evt.keyCode);
}
const handlers$1 = [];
let escDown;
function onKeydown(evt) {
  escDown = evt.keyCode === 27;
}
function onBlur() {
  if (escDown === true) {
    escDown = false;
  }
}
function onKeyup(evt) {
  if (escDown === true) {
    escDown = false;
    if (isKeyCode(evt, 27) === true) {
      handlers$1[handlers$1.length - 1](evt);
    }
  }
}
function update(action) {
  window[action]("keydown", onKeydown);
  window[action]("blur", onBlur);
  window[action]("keyup", onKeyup);
  escDown = false;
}
function addEscapeKey(fn) {
  if (client.is.desktop === true) {
    handlers$1.push(fn);
    if (handlers$1.length === 1) {
      update("addEventListener");
    }
  }
}
function removeEscapeKey(fn) {
  const index2 = handlers$1.indexOf(fn);
  if (index2 > -1) {
    handlers$1.splice(index2, 1);
    if (handlers$1.length === 0) {
      update("removeEventListener");
    }
  }
}
const handlers = [];
function trigger(e) {
  handlers[handlers.length - 1](e);
}
function addFocusout(fn) {
  if (client.is.desktop === true) {
    handlers.push(fn);
    if (handlers.length === 1) {
      document.body.addEventListener("focusin", trigger);
    }
  }
}
function removeFocusout(fn) {
  const index2 = handlers.indexOf(fn);
  if (index2 > -1) {
    handlers.splice(index2, 1);
    if (handlers.length === 0) {
      document.body.removeEventListener("focusin", trigger);
    }
  }
}
let maximizedModals = 0;
const positionClass$1 = {
  standard: "fixed-full flex-center",
  top: "fixed-top justify-center",
  bottom: "fixed-bottom justify-center",
  right: "fixed-right items-center",
  left: "fixed-left items-center"
};
const defaultTransitions = {
  standard: ["scale", "scale"],
  top: ["slide-down", "slide-up"],
  bottom: ["slide-up", "slide-down"],
  right: ["slide-left", "slide-right"],
  left: ["slide-right", "slide-left"]
};
const QDialog = createComponent({
  name: "QDialog",
  inheritAttrs: false,
  props: {
    ...useModelToggleProps,
    ...useTransitionProps,
    transitionShow: String,
    transitionHide: String,
    persistent: Boolean,
    autoClose: Boolean,
    allowFocusOutside: Boolean,
    noEscDismiss: Boolean,
    noBackdropDismiss: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    noShake: Boolean,
    seamless: Boolean,
    maximized: Boolean,
    fullWidth: Boolean,
    fullHeight: Boolean,
    square: Boolean,
    position: {
      type: String,
      default: "standard",
      validator: (val) => val === "standard" || ["top", "bottom", "left", "right"].includes(val)
    }
  },
  emits: [
    ...useModelToggleEmits,
    "shake",
    "click",
    "escapeKey"
  ],
  setup(props, { slots, emit, attrs }) {
    const vm = getCurrentInstance();
    const innerRef = ref(null);
    const showing = ref(false);
    const animating = ref(false);
    let shakeTimeout, refocusTarget = null, isMaximized, avoidAutoClose;
    const hideOnRouteChange = computed(
      () => props.persistent !== true && props.noRouteDismiss !== true && props.seamless !== true
    );
    const { preventBodyScroll } = usePreventScroll();
    const { registerTimeout } = useTimeout();
    const { registerTick, removeTick } = useTick();
    const { transitionProps, transitionStyle } = useTransition(
      props,
      () => defaultTransitions[props.position][0],
      () => defaultTransitions[props.position][1]
    );
    const { showPortal, hidePortal, portalIsAccessible, renderPortal } = usePortal(
      vm,
      innerRef,
      renderPortalContent,
      true
    );
    const { hide } = useModelToggle({
      showing,
      hideOnRouteChange,
      handleShow,
      handleHide,
      processOnMount: true
    });
    const { addToHistory, removeFromHistory } = useHistory(showing, hide, hideOnRouteChange);
    const classes = computed(
      () => `q-dialog__inner flex no-pointer-events q-dialog__inner--${props.maximized === true ? "maximized" : "minimized"} q-dialog__inner--${props.position} ${positionClass$1[props.position]}` + (animating.value === true ? " q-dialog__inner--animating" : "") + (props.fullWidth === true ? " q-dialog__inner--fullwidth" : "") + (props.fullHeight === true ? " q-dialog__inner--fullheight" : "") + (props.square === true ? " q-dialog__inner--square" : "")
    );
    const useBackdrop = computed(() => showing.value === true && props.seamless !== true);
    const onEvents = computed(() => props.autoClose === true ? { onClick: onAutoClose } : {});
    const rootClasses = computed(() => [
      `q-dialog fullscreen no-pointer-events q-dialog--${useBackdrop.value === true ? "modal" : "seamless"}`,
      attrs.class
    ]);
    watch(() => props.maximized, (state) => {
      showing.value === true && updateMaximized(state);
    });
    watch(useBackdrop, (val) => {
      preventBodyScroll(val);
      if (val === true) {
        addFocusout(onFocusChange);
        addEscapeKey(onEscapeKey);
      } else {
        removeFocusout(onFocusChange);
        removeEscapeKey(onEscapeKey);
      }
    });
    function handleShow(evt) {
      addToHistory();
      refocusTarget = props.noRefocus === false && document.activeElement !== null ? document.activeElement : null;
      updateMaximized(props.maximized);
      showPortal();
      animating.value = true;
      if (props.noFocus !== true) {
        document.activeElement !== null && document.activeElement.blur();
        registerTick(focus);
      } else {
        removeTick();
      }
      registerTimeout(() => {
        if (vm.proxy.$q.platform.is.ios === true) {
          if (props.seamless !== true && document.activeElement) {
            const { top, bottom } = document.activeElement.getBoundingClientRect(), { innerHeight } = window, height = window.visualViewport !== void 0 ? window.visualViewport.height : innerHeight;
            if (top > 0 && bottom > height / 2) {
              document.scrollingElement.scrollTop = Math.min(
                document.scrollingElement.scrollHeight - height,
                bottom >= innerHeight ? Infinity : Math.ceil(document.scrollingElement.scrollTop + bottom - height / 2)
              );
            }
            document.activeElement.scrollIntoView();
          }
          avoidAutoClose = true;
          innerRef.value.click();
          avoidAutoClose = false;
        }
        showPortal(true);
        animating.value = false;
        emit("show", evt);
      }, props.transitionDuration);
    }
    function handleHide(evt) {
      removeTick();
      removeFromHistory();
      cleanup(true);
      animating.value = true;
      hidePortal();
      if (refocusTarget !== null) {
        ((evt && evt.type.indexOf("key") === 0 ? refocusTarget.closest('[tabindex]:not([tabindex^="-"])') : void 0) || refocusTarget).focus();
        refocusTarget = null;
      }
      registerTimeout(() => {
        hidePortal(true);
        animating.value = false;
        emit("hide", evt);
      }, props.transitionDuration);
    }
    function focus(selector) {
      addFocusFn(() => {
        let node = innerRef.value;
        if (node === null || node.contains(document.activeElement) === true) {
          return;
        }
        node = (selector !== "" ? node.querySelector(selector) : null) || node.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || node.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || node.querySelector("[autofocus], [data-autofocus]") || node;
        node.focus({ preventScroll: true });
      });
    }
    function shake(focusTarget) {
      if (focusTarget && typeof focusTarget.focus === "function") {
        focusTarget.focus({ preventScroll: true });
      } else {
        focus();
      }
      emit("shake");
      const node = innerRef.value;
      if (node !== null) {
        node.classList.remove("q-animate--scale");
        node.classList.add("q-animate--scale");
        clearTimeout(shakeTimeout);
        shakeTimeout = setTimeout(() => {
          if (innerRef.value !== null) {
            node.classList.remove("q-animate--scale");
            focus();
          }
        }, 170);
      }
    }
    function onEscapeKey() {
      if (props.seamless !== true) {
        if (props.persistent === true || props.noEscDismiss === true) {
          props.maximized !== true && props.noShake !== true && shake();
        } else {
          emit("escapeKey");
          hide();
        }
      }
    }
    function cleanup(hiding) {
      clearTimeout(shakeTimeout);
      if (hiding === true || showing.value === true) {
        updateMaximized(false);
        if (props.seamless !== true) {
          preventBodyScroll(false);
          removeFocusout(onFocusChange);
          removeEscapeKey(onEscapeKey);
        }
      }
      if (hiding !== true) {
        refocusTarget = null;
      }
    }
    function updateMaximized(active) {
      if (active === true) {
        if (isMaximized !== true) {
          maximizedModals < 1 && document.body.classList.add("q-body--dialog");
          maximizedModals++;
          isMaximized = true;
        }
      } else if (isMaximized === true) {
        if (maximizedModals < 2) {
          document.body.classList.remove("q-body--dialog");
        }
        maximizedModals--;
        isMaximized = false;
      }
    }
    function onAutoClose(e) {
      if (avoidAutoClose !== true) {
        hide(e);
        emit("click", e);
      }
    }
    function onBackdropClick(e) {
      if (props.persistent !== true && props.noBackdropDismiss !== true) {
        hide(e);
      } else if (props.noShake !== true) {
        shake(e.relatedTarget);
      }
    }
    function onFocusChange(evt) {
      if (props.allowFocusOutside !== true && portalIsAccessible.value === true && childHasFocus(innerRef.value, evt.target) !== true) {
        focus('[tabindex]:not([tabindex="-1"])');
      }
    }
    Object.assign(vm.proxy, {
      focus,
      shake,
      __updateRefocusTarget(target2) {
        refocusTarget = target2 || null;
      }
    });
    onBeforeUnmount(cleanup);
    function renderPortalContent() {
      return h("div", {
        role: "dialog",
        "aria-modal": useBackdrop.value === true ? "true" : "false",
        ...attrs,
        class: rootClasses.value
      }, [
        h(Transition, {
          name: "q-transition--fade",
          appear: true
        }, () => useBackdrop.value === true ? h("div", {
          class: "q-dialog__backdrop fixed-full",
          style: transitionStyle.value,
          "aria-hidden": "true",
          tabindex: -1,
          onFocusin: onBackdropClick
        }) : null),
        h(
          Transition,
          transitionProps.value,
          () => showing.value === true ? h("div", {
            ref: innerRef,
            class: classes.value,
            style: transitionStyle.value,
            tabindex: -1,
            ...onEvents.value
          }, hSlot(slots.default)) : null
        )
      ]);
    }
    return renderPortal;
  }
});
const useSizeDefaults = {
  xs: 18,
  sm: 24,
  md: 32,
  lg: 38,
  xl: 46
};
const useSizeProps = {
  size: String
};
function useSize(props, sizes = useSizeDefaults) {
  return computed(() => props.size !== void 0 ? { fontSize: props.size in sizes ? `${sizes[props.size]}px` : props.size } : null);
}
const defaultViewBox = "0 0 24 24";
const sameFn = (i) => i;
const ionFn = (i) => `ionicons ${i}`;
const libMap = {
  "mdi-": (i) => `mdi ${i}`,
  "icon-": sameFn,
  "bt-": (i) => `bt ${i}`,
  "eva-": (i) => `eva ${i}`,
  "ion-md": ionFn,
  "ion-ios": ionFn,
  "ion-logo": ionFn,
  "iconfont ": sameFn,
  "ti-": (i) => `themify-icon ${i}`,
  "bi-": (i) => `bootstrap-icons ${i}`
};
const matMap = {
  o_: "-outlined",
  r_: "-round",
  s_: "-sharp"
};
const symMap = {
  sym_o_: "-outlined",
  sym_r_: "-rounded",
  sym_s_: "-sharp"
};
const libRE = new RegExp("^(" + Object.keys(libMap).join("|") + ")");
const matRE = new RegExp("^(" + Object.keys(matMap).join("|") + ")");
const symRE = new RegExp("^(" + Object.keys(symMap).join("|") + ")");
const mRE = /^[Mm]\s?[-+]?\.?\d/;
const imgRE = /^img:/;
const svgUseRE = /^svguse:/;
const ionRE = /^ion-/;
const faRE = /^(fa-(solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /;
const QIcon = createComponent({
  name: "QIcon",
  props: {
    ...useSizeProps,
    tag: {
      type: String,
      default: "i"
    },
    name: String,
    color: String,
    left: Boolean,
    right: Boolean
  },
  setup(props, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const sizeStyle = useSize(props);
    const classes = computed(
      () => "q-icon" + (props.left === true ? " on-left" : "") + (props.right === true ? " on-right" : "") + (props.color !== void 0 ? ` text-${props.color}` : "")
    );
    const type = computed(() => {
      let cls;
      let icon = props.name;
      if (icon === "none" || !icon) {
        return { none: true };
      }
      if ($q.iconMapFn !== null) {
        const res = $q.iconMapFn(icon);
        if (res !== void 0) {
          if (res.icon !== void 0) {
            icon = res.icon;
            if (icon === "none" || !icon) {
              return { none: true };
            }
          } else {
            return {
              cls: res.cls,
              content: res.content !== void 0 ? res.content : " "
            };
          }
        }
      }
      if (mRE.test(icon) === true) {
        const [def2, viewBox = defaultViewBox] = icon.split("|");
        return {
          svg: true,
          viewBox,
          nodes: def2.split("&&").map((path) => {
            const [d, style, transform] = path.split("@@");
            return h("path", { style, d, transform });
          })
        };
      }
      if (imgRE.test(icon) === true) {
        return {
          img: true,
          src: icon.substring(4)
        };
      }
      if (svgUseRE.test(icon) === true) {
        const [def2, viewBox = defaultViewBox] = icon.split("|");
        return {
          svguse: true,
          src: def2.substring(7),
          viewBox
        };
      }
      let content = " ";
      const matches2 = icon.match(libRE);
      if (matches2 !== null) {
        cls = libMap[matches2[1]](icon);
      } else if (faRE.test(icon) === true) {
        cls = icon;
      } else if (ionRE.test(icon) === true) {
        cls = `ionicons ion-${$q.platform.is.ios === true ? "ios" : "md"}${icon.substring(3)}`;
      } else if (symRE.test(icon) === true) {
        cls = "notranslate material-symbols";
        const matches3 = icon.match(symRE);
        if (matches3 !== null) {
          icon = icon.substring(6);
          cls += symMap[matches3[1]];
        }
        content = icon;
      } else {
        cls = "notranslate material-icons";
        const matches3 = icon.match(matRE);
        if (matches3 !== null) {
          icon = icon.substring(2);
          cls += matMap[matches3[1]];
        }
        content = icon;
      }
      return {
        cls,
        content
      };
    });
    return () => {
      const data = {
        class: classes.value,
        style: sizeStyle.value,
        "aria-hidden": "true",
        role: "presentation"
      };
      if (type.value.none === true) {
        return h(props.tag, data, hSlot(slots.default));
      }
      if (type.value.img === true) {
        return h("span", data, hMergeSlot(slots.default, [
          h("img", { src: type.value.src })
        ]));
      }
      if (type.value.svg === true) {
        return h("span", data, hMergeSlot(slots.default, [
          h("svg", {
            viewBox: type.value.viewBox || "0 0 24 24"
          }, type.value.nodes)
        ]));
      }
      if (type.value.svguse === true) {
        return h("span", data, hMergeSlot(slots.default, [
          h("svg", {
            viewBox: type.value.viewBox
          }, [
            h("use", { "xlink:href": type.value.src })
          ])
        ]));
      }
      if (type.value.cls !== void 0) {
        data.class += " " + type.value.cls;
      }
      return h(props.tag, data, hMergeSlot(slots.default, [
        type.value.content
      ]));
    };
  }
});
const useSpinnerProps = {
  size: {
    type: [Number, String],
    default: "1em"
  },
  color: String
};
function useSpinner(props) {
  return {
    cSize: computed(() => props.size in useSizeDefaults ? `${useSizeDefaults[props.size]}px` : props.size),
    classes: computed(
      () => "q-spinner" + (props.color ? ` text-${props.color}` : "")
    )
  };
}
const QSpinner = createComponent({
  name: "QSpinner",
  props: {
    ...useSpinnerProps,
    thickness: {
      type: Number,
      default: 5
    }
  },
  setup(props) {
    const { cSize, classes } = useSpinner(props);
    return () => h("svg", {
      class: classes.value + " q-spinner-mat",
      width: cSize.value,
      height: cSize.value,
      viewBox: "25 25 50 50"
    }, [
      h("circle", {
        class: "path",
        cx: "50",
        cy: "50",
        r: "20",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": props.thickness,
        "stroke-miterlimit": "10"
      })
    ]);
  }
});
function throttle$1(fn, limit = 250) {
  let wait = false, result;
  return function() {
    if (wait === false) {
      wait = true;
      setTimeout(() => {
        wait = false;
      }, limit);
      result = fn.apply(this, arguments);
    }
    return result;
  };
}
function showRipple(evt, el, ctx, forceCenter) {
  ctx.modifiers.stop === true && stop(evt);
  const color = ctx.modifiers.color;
  let center = ctx.modifiers.center;
  center = center === true || forceCenter === true;
  const node = document.createElement("span"), innerNode = document.createElement("span"), pos = position(evt), { left, top, width, height } = el.getBoundingClientRect(), diameter2 = Math.sqrt(width * width + height * height), radius2 = diameter2 / 2, centerX = `${(width - diameter2) / 2}px`, x = center ? centerX : `${pos.left - left - radius2}px`, centerY = `${(height - diameter2) / 2}px`, y = center ? centerY : `${pos.top - top - radius2}px`;
  innerNode.className = "q-ripple__inner";
  css$1(innerNode, {
    height: `${diameter2}px`,
    width: `${diameter2}px`,
    transform: `translate3d(${x},${y},0) scale3d(.2,.2,1)`,
    opacity: 0
  });
  node.className = `q-ripple${color ? " text-" + color : ""}`;
  node.setAttribute("dir", "ltr");
  node.appendChild(innerNode);
  el.appendChild(node);
  const abort = () => {
    node.remove();
    clearTimeout(timer2);
  };
  ctx.abort.push(abort);
  let timer2 = setTimeout(() => {
    innerNode.classList.add("q-ripple__inner--enter");
    innerNode.style.transform = `translate3d(${centerX},${centerY},0) scale3d(1,1,1)`;
    innerNode.style.opacity = 0.2;
    timer2 = setTimeout(() => {
      innerNode.classList.remove("q-ripple__inner--enter");
      innerNode.classList.add("q-ripple__inner--leave");
      innerNode.style.opacity = 0;
      timer2 = setTimeout(() => {
        node.remove();
        ctx.abort.splice(ctx.abort.indexOf(abort), 1);
      }, 275);
    }, 250);
  }, 50);
}
function updateModifiers(ctx, { modifiers, value: value2, arg }) {
  const cfg = Object.assign({}, ctx.cfg.ripple, modifiers, value2);
  ctx.modifiers = {
    early: cfg.early === true,
    stop: cfg.stop === true,
    center: cfg.center === true,
    color: cfg.color || arg,
    keyCodes: [].concat(cfg.keyCodes || 13)
  };
}
const Ripple = createDirective(
  {
    name: "ripple",
    beforeMount(el, binding) {
      const cfg = binding.instance.$.appContext.config.globalProperties.$q.config || {};
      if (cfg.ripple === false) {
        return;
      }
      const ctx = {
        cfg,
        enabled: binding.value !== false,
        modifiers: {},
        abort: [],
        start(evt) {
          if (ctx.enabled === true && evt.qSkipRipple !== true && evt.type === (ctx.modifiers.early === true ? "pointerdown" : "click")) {
            showRipple(evt, el, ctx, evt.qKeyEvent === true);
          }
        },
        keystart: throttle$1((evt) => {
          if (ctx.enabled === true && evt.qSkipRipple !== true && isKeyCode(evt, ctx.modifiers.keyCodes) === true && evt.type === `key${ctx.modifiers.early === true ? "down" : "up"}`) {
            showRipple(evt, el, ctx, true);
          }
        }, 300)
      };
      updateModifiers(ctx, binding);
      el.__qripple = ctx;
      addEvt(ctx, "main", [
        [el, "pointerdown", "start", "passive"],
        [el, "click", "start", "passive"],
        [el, "keydown", "keystart", "passive"],
        [el, "keyup", "keystart", "passive"]
      ]);
    },
    updated(el, binding) {
      if (binding.oldValue !== binding.value) {
        const ctx = el.__qripple;
        if (ctx !== void 0) {
          ctx.enabled = binding.value !== false;
          if (ctx.enabled === true && Object(binding.value) === binding.value) {
            updateModifiers(ctx, binding);
          }
        }
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qripple;
      if (ctx !== void 0) {
        ctx.abort.forEach((fn) => {
          fn();
        });
        cleanEvt(ctx, "main");
        delete el._qripple;
      }
    }
  }
);
const alignMap = {
  left: "start",
  center: "center",
  right: "end",
  between: "between",
  around: "around",
  evenly: "evenly",
  stretch: "stretch"
};
const alignValues$1 = Object.keys(alignMap);
const useAlignProps = {
  align: {
    type: String,
    validator: (v2) => alignValues$1.includes(v2)
  }
};
function useAlign(props) {
  return computed(() => {
    const align = props.align === void 0 ? props.vertical === true ? "stretch" : "left" : props.align;
    return `${props.vertical === true ? "items" : "justify"}-${alignMap[align]}`;
  });
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key], outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue) {
        return false;
      }
    } else if (Array.isArray(outerValue) === false || outerValue.length !== innerValue.length || innerValue.some((value2, i) => value2 !== outerValue[i])) {
      return false;
    }
  }
  return true;
}
function isEquivalentArray(a, b) {
  return Array.isArray(b) === true ? a.length === b.length && a.every((value2, i) => value2 === b[i]) : a.length === 1 && a[0] === b;
}
function isSameRouteLocationParamsValue(a, b) {
  return Array.isArray(a) === true ? isEquivalentArray(a, b) : Array.isArray(b) === true ? isEquivalentArray(b, a) : a === b;
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (isSameRouteLocationParamsValue(a[key], b[key]) === false) {
      return false;
    }
  }
  return true;
}
const useRouterLinkProps = {
  to: [String, Object],
  replace: Boolean,
  exact: Boolean,
  activeClass: {
    type: String,
    default: "q-router-link--active"
  },
  exactActiveClass: {
    type: String,
    default: "q-router-link--exact-active"
  },
  href: String,
  target: String,
  disable: Boolean
};
function useRouterLink({ fallbackTag, useDisableForRouterLinkProps = true } = {}) {
  const vm = getCurrentInstance();
  const { props, proxy, emit } = vm;
  const hasRouter = vmHasRouter(vm);
  const hasHrefLink = computed(() => props.disable !== true && props.href !== void 0);
  const hasRouterLinkProps = useDisableForRouterLinkProps === true ? computed(
    () => hasRouter === true && props.disable !== true && hasHrefLink.value !== true && props.to !== void 0 && props.to !== null && props.to !== ""
  ) : computed(
    () => hasRouter === true && hasHrefLink.value !== true && props.to !== void 0 && props.to !== null && props.to !== ""
  );
  const resolvedLink = computed(() => hasRouterLinkProps.value === true ? getLink(props.to) : null);
  const hasRouterLink = computed(() => resolvedLink.value !== null);
  const hasLink = computed(() => hasHrefLink.value === true || hasRouterLink.value === true);
  const linkTag = computed(() => props.type === "a" || hasLink.value === true ? "a" : props.tag || fallbackTag || "div");
  const linkAttrs = computed(() => hasHrefLink.value === true ? {
    href: props.href,
    target: props.target
  } : hasRouterLink.value === true ? {
    href: resolvedLink.value.href,
    target: props.target
  } : {});
  const linkActiveIndex = computed(() => {
    if (hasRouterLink.value === false) {
      return -1;
    }
    const { matched } = resolvedLink.value, { length } = matched, routeMatched = matched[length - 1];
    if (routeMatched === void 0) {
      return -1;
    }
    const currentMatched = proxy.$route.matched;
    if (currentMatched.length === 0) {
      return -1;
    }
    const index2 = currentMatched.findIndex(
      isSameRouteRecord.bind(null, routeMatched)
    );
    if (index2 > -1) {
      return index2;
    }
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(
      isSameRouteRecord.bind(null, matched[length - 2])
    ) : index2;
  });
  const linkIsActive = computed(
    () => hasRouterLink.value === true && linkActiveIndex.value !== -1 && includesParams(proxy.$route.params, resolvedLink.value.params)
  );
  const linkIsExactActive = computed(
    () => linkIsActive.value === true && linkActiveIndex.value === proxy.$route.matched.length - 1 && isSameRouteLocationParams(proxy.$route.params, resolvedLink.value.params)
  );
  const linkClass = computed(() => hasRouterLink.value === true ? linkIsExactActive.value === true ? ` ${props.exactActiveClass} ${props.activeClass}` : props.exact === true ? "" : linkIsActive.value === true ? ` ${props.activeClass}` : "" : "");
  function getLink(to) {
    try {
      return proxy.$router.resolve(to);
    } catch (_) {
    }
    return null;
  }
  function navigateToRouterLink(e, { returnRouterError, to = props.to, replace = props.replace } = {}) {
    if (props.disable === true) {
      e.preventDefault();
      return Promise.resolve(false);
    }
    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey || e.button !== void 0 && e.button !== 0 || props.target === "_blank") {
      return Promise.resolve(false);
    }
    e.preventDefault();
    const promise = proxy.$router[replace === true ? "replace" : "push"](to);
    return returnRouterError === true ? promise : promise.then(() => {
    }).catch(() => {
    });
  }
  function navigateOnClick(e) {
    if (hasRouterLink.value === true) {
      const go = (opts) => navigateToRouterLink(e, opts);
      emit("click", e, go);
      e.defaultPrevented !== true && go();
    } else {
      emit("click", e);
    }
  }
  return {
    hasRouterLink,
    hasHrefLink,
    hasLink,
    linkTag,
    resolvedLink,
    linkIsActive,
    linkIsExactActive,
    linkClass,
    linkAttrs,
    getLink,
    navigateToRouterLink,
    navigateOnClick
  };
}
const btnPadding = {
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32
};
const defaultSizes$1 = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
};
const formTypes = ["button", "submit", "reset"];
const mediaTypeRE = /[^\s]\/[^\s]/;
const btnDesignOptions = ["flat", "outline", "push", "unelevated"];
const getBtnDesign = (props, defaultValue) => {
  if (props.flat === true)
    return "flat";
  if (props.outline === true)
    return "outline";
  if (props.push === true)
    return "push";
  if (props.unelevated === true)
    return "unelevated";
  return defaultValue;
};
const useBtnProps = {
  ...useSizeProps,
  ...useRouterLinkProps,
  type: {
    type: String,
    default: "button"
  },
  label: [Number, String],
  icon: String,
  iconRight: String,
  ...btnDesignOptions.reduce(
    (acc, val) => (acc[val] = Boolean) && acc,
    {}
  ),
  square: Boolean,
  round: Boolean,
  rounded: Boolean,
  glossy: Boolean,
  size: String,
  fab: Boolean,
  fabMini: Boolean,
  padding: String,
  color: String,
  textColor: String,
  noCaps: Boolean,
  noWrap: Boolean,
  dense: Boolean,
  tabindex: [Number, String],
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  align: {
    ...useAlignProps.align,
    default: "center"
  },
  stack: Boolean,
  stretch: Boolean,
  loading: {
    type: Boolean,
    default: null
  },
  disable: Boolean
};
function useBtn(props) {
  const sizeStyle = useSize(props, defaultSizes$1);
  const alignClass = useAlign(props);
  const { hasRouterLink, hasLink, linkTag, linkAttrs, navigateOnClick } = useRouterLink({
    fallbackTag: "button"
  });
  const style = computed(() => {
    const obj = props.fab === false && props.fabMini === false ? sizeStyle.value : {};
    return props.padding !== void 0 ? Object.assign({}, obj, {
      padding: props.padding.split(/\s+/).map((v2) => v2 in btnPadding ? btnPadding[v2] + "px" : v2).join(" "),
      minWidth: "0",
      minHeight: "0"
    }) : obj;
  });
  const isRounded = computed(
    () => props.rounded === true || props.fab === true || props.fabMini === true
  );
  const isActionable = computed(
    () => props.disable !== true && props.loading !== true
  );
  const tabIndex = computed(() => isActionable.value === true ? props.tabindex || 0 : -1);
  const design = computed(() => getBtnDesign(props, "standard"));
  const attributes = computed(() => {
    const acc = { tabindex: tabIndex.value };
    if (hasLink.value === true) {
      Object.assign(acc, linkAttrs.value);
    } else if (formTypes.includes(props.type) === true) {
      acc.type = props.type;
    }
    if (linkTag.value === "a") {
      if (props.disable === true) {
        acc["aria-disabled"] = "true";
      } else if (acc.href === void 0) {
        acc.role = "button";
      }
      if (hasRouterLink.value !== true && mediaTypeRE.test(props.type) === true) {
        acc.type = props.type;
      }
    } else if (props.disable === true) {
      acc.disabled = "";
      acc["aria-disabled"] = "true";
    }
    if (props.loading === true && props.percentage !== void 0) {
      Object.assign(acc, {
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": props.percentage
      });
    }
    return acc;
  });
  const classes = computed(() => {
    let colors;
    if (props.color !== void 0) {
      if (props.flat === true || props.outline === true) {
        colors = `text-${props.textColor || props.color}`;
      } else {
        colors = `bg-${props.color} text-${props.textColor || "white"}`;
      }
    } else if (props.textColor) {
      colors = `text-${props.textColor}`;
    }
    const shape = props.round === true ? "round" : `rectangle${isRounded.value === true ? " q-btn--rounded" : props.square === true ? " q-btn--square" : ""}`;
    return `q-btn--${design.value} q-btn--${shape}` + (colors !== void 0 ? " " + colors : "") + (isActionable.value === true ? " q-btn--actionable q-focusable q-hoverable" : props.disable === true ? " disabled" : "") + (props.fab === true ? " q-btn--fab" : props.fabMini === true ? " q-btn--fab-mini" : "") + (props.noCaps === true ? " q-btn--no-uppercase" : "") + (props.dense === true ? " q-btn--dense" : "") + (props.stretch === true ? " no-border-radius self-stretch" : "") + (props.glossy === true ? " glossy" : "") + (props.square ? " q-btn--square" : "");
  });
  const innerClasses = computed(
    () => alignClass.value + (props.stack === true ? " column" : " row") + (props.noWrap === true ? " no-wrap text-no-wrap" : "") + (props.loading === true ? " q-btn__content--hidden" : "")
  );
  return {
    classes,
    style,
    innerClasses,
    attributes,
    hasLink,
    linkTag,
    navigateOnClick,
    isActionable
  };
}
const { passiveCapture } = listenOpts;
let touchTarget = null, keyboardTarget = null, mouseTarget = null;
const QBtn = createComponent({
  name: "QBtn",
  props: {
    ...useBtnProps,
    percentage: Number,
    darkPercentage: Boolean,
    onTouchstart: [Function, Array]
  },
  emits: ["click", "keydown", "mousedown", "keyup"],
  setup(props, { slots, emit }) {
    const { proxy } = getCurrentInstance();
    const {
      classes,
      style,
      innerClasses,
      attributes,
      hasLink,
      linkTag,
      navigateOnClick,
      isActionable
    } = useBtn(props);
    const rootRef = ref(null);
    const blurTargetRef = ref(null);
    let localTouchTargetEl = null, avoidMouseRipple, mouseTimer;
    const hasLabel = computed(
      () => props.label !== void 0 && props.label !== null && props.label !== ""
    );
    const ripple = computed(() => props.disable === true || props.ripple === false ? false : {
      keyCodes: hasLink.value === true ? [13, 32] : [13],
      ...props.ripple === true ? {} : props.ripple
    });
    const rippleProps = computed(() => ({ center: props.round }));
    const percentageStyle = computed(() => {
      const val = Math.max(0, Math.min(100, props.percentage));
      return val > 0 ? { transition: "transform 0.6s", transform: `translateX(${val - 100}%)` } : {};
    });
    const onEvents = computed(() => {
      if (props.loading === true) {
        return {
          onMousedown: onLoadingEvt,
          onTouchstart: onLoadingEvt,
          onClick: onLoadingEvt,
          onKeydown: onLoadingEvt,
          onKeyup: onLoadingEvt
        };
      }
      if (isActionable.value === true) {
        const acc = {
          onClick,
          onKeydown: onKeydown2,
          onMousedown
        };
        if (proxy.$q.platform.has.touch === true) {
          const suffix = props.onTouchstart !== void 0 ? "" : "Passive";
          acc[`onTouchstart${suffix}`] = onTouchstart;
        }
        return acc;
      }
      return {
        onClick: stopAndPrevent
      };
    });
    const nodeProps = computed(() => ({
      ref: rootRef,
      class: "q-btn q-btn-item non-selectable no-outline " + classes.value,
      style: style.value,
      ...attributes.value,
      ...onEvents.value
    }));
    function onClick(e) {
      if (rootRef.value === null) {
        return;
      }
      if (e !== void 0) {
        if (e.defaultPrevented === true) {
          return;
        }
        const el = document.activeElement;
        if (props.type === "submit" && el !== document.body && rootRef.value.contains(el) === false && el.contains(rootRef.value) === false) {
          rootRef.value.focus();
          const onClickCleanup = () => {
            document.removeEventListener("keydown", stopAndPrevent, true);
            document.removeEventListener("keyup", onClickCleanup, passiveCapture);
            rootRef.value !== null && rootRef.value.removeEventListener("blur", onClickCleanup, passiveCapture);
          };
          document.addEventListener("keydown", stopAndPrevent, true);
          document.addEventListener("keyup", onClickCleanup, passiveCapture);
          rootRef.value.addEventListener("blur", onClickCleanup, passiveCapture);
        }
      }
      navigateOnClick(e);
    }
    function onKeydown2(e) {
      if (rootRef.value === null) {
        return;
      }
      emit("keydown", e);
      if (isKeyCode(e, [13, 32]) === true && keyboardTarget !== rootRef.value) {
        keyboardTarget !== null && cleanup();
        if (e.defaultPrevented !== true) {
          rootRef.value.focus();
          keyboardTarget = rootRef.value;
          rootRef.value.classList.add("q-btn--active");
          document.addEventListener("keyup", onPressEnd, true);
          rootRef.value.addEventListener("blur", onPressEnd, passiveCapture);
        }
        stopAndPrevent(e);
      }
    }
    function onTouchstart(e) {
      if (rootRef.value === null) {
        return;
      }
      emit("touchstart", e);
      if (e.defaultPrevented === true) {
        return;
      }
      if (touchTarget !== rootRef.value) {
        touchTarget !== null && cleanup();
        touchTarget = rootRef.value;
        localTouchTargetEl = e.target;
        localTouchTargetEl.addEventListener("touchcancel", onPressEnd, passiveCapture);
        localTouchTargetEl.addEventListener("touchend", onPressEnd, passiveCapture);
      }
      avoidMouseRipple = true;
      clearTimeout(mouseTimer);
      mouseTimer = setTimeout(() => {
        avoidMouseRipple = false;
      }, 200);
    }
    function onMousedown(e) {
      if (rootRef.value === null) {
        return;
      }
      e.qSkipRipple = avoidMouseRipple === true;
      emit("mousedown", e);
      if (e.defaultPrevented !== true && mouseTarget !== rootRef.value) {
        mouseTarget !== null && cleanup();
        mouseTarget = rootRef.value;
        rootRef.value.classList.add("q-btn--active");
        document.addEventListener("mouseup", onPressEnd, passiveCapture);
      }
    }
    function onPressEnd(e) {
      if (rootRef.value === null) {
        return;
      }
      if (e !== void 0 && e.type === "blur" && document.activeElement === rootRef.value) {
        return;
      }
      if (e !== void 0 && e.type === "keyup") {
        if (keyboardTarget === rootRef.value && isKeyCode(e, [13, 32]) === true) {
          const evt = new MouseEvent("click", e);
          evt.qKeyEvent = true;
          e.defaultPrevented === true && prevent(evt);
          e.cancelBubble === true && stop(evt);
          rootRef.value.dispatchEvent(evt);
          stopAndPrevent(e);
          e.qKeyEvent = true;
        }
        emit("keyup", e);
      }
      cleanup();
    }
    function cleanup(destroying) {
      const blurTarget = blurTargetRef.value;
      if (destroying !== true && (touchTarget === rootRef.value || mouseTarget === rootRef.value) && blurTarget !== null && blurTarget !== document.activeElement) {
        blurTarget.setAttribute("tabindex", -1);
        blurTarget.focus();
      }
      if (touchTarget === rootRef.value) {
        if (localTouchTargetEl !== null) {
          localTouchTargetEl.removeEventListener("touchcancel", onPressEnd, passiveCapture);
          localTouchTargetEl.removeEventListener("touchend", onPressEnd, passiveCapture);
        }
        touchTarget = localTouchTargetEl = null;
      }
      if (mouseTarget === rootRef.value) {
        document.removeEventListener("mouseup", onPressEnd, passiveCapture);
        mouseTarget = null;
      }
      if (keyboardTarget === rootRef.value) {
        document.removeEventListener("keyup", onPressEnd, true);
        rootRef.value !== null && rootRef.value.removeEventListener("blur", onPressEnd, passiveCapture);
        keyboardTarget = null;
      }
      rootRef.value !== null && rootRef.value.classList.remove("q-btn--active");
    }
    function onLoadingEvt(evt) {
      stopAndPrevent(evt);
      evt.qSkipRipple = true;
    }
    onBeforeUnmount(() => {
      cleanup(true);
    });
    Object.assign(proxy, { click: onClick });
    return () => {
      let inner = [];
      props.icon !== void 0 && inner.push(
        h(QIcon, {
          name: props.icon,
          left: props.stack === false && hasLabel.value === true,
          role: "img",
          "aria-hidden": "true"
        })
      );
      hasLabel.value === true && inner.push(
        h("span", { class: "block" }, [props.label])
      );
      inner = hMergeSlot(slots.default, inner);
      if (props.iconRight !== void 0 && props.round === false) {
        inner.push(
          h(QIcon, {
            name: props.iconRight,
            right: props.stack === false && hasLabel.value === true,
            role: "img",
            "aria-hidden": "true"
          })
        );
      }
      const child = [
        h("span", {
          class: "q-focus-helper",
          ref: blurTargetRef
        })
      ];
      if (props.loading === true && props.percentage !== void 0) {
        child.push(
          h("span", {
            class: "q-btn__progress absolute-full overflow-hidden" + (props.darkPercentage === true ? " q-btn__progress--dark" : "")
          }, [
            h("span", {
              class: "q-btn__progress-indicator fit block",
              style: percentageStyle.value
            })
          ])
        );
      }
      child.push(
        h("span", {
          class: "q-btn__content text-center col items-center q-anchor--skip " + innerClasses.value
        }, inner)
      );
      props.loading !== null && child.push(
        h(Transition, {
          name: "q-transition--fade"
        }, () => props.loading === true ? [
          h("span", {
            key: "loading",
            class: "absolute-full flex flex-center"
          }, slots.loading !== void 0 ? slots.loading() : [h(QSpinner)])
        ] : null)
      );
      return withDirectives(
        h(
          linkTag.value,
          nodeProps.value,
          child
        ),
        [[
          Ripple,
          ripple.value,
          void 0,
          rippleProps.value
        ]]
      );
    };
  }
});
const useDarkProps = {
  dark: {
    type: Boolean,
    default: null
  }
};
function useDark(props, $q) {
  return computed(() => props.dark === null ? $q.dark.isActive : props.dark);
}
const QCard = createComponent({
  name: "QCard",
  props: {
    ...useDarkProps,
    tag: {
      type: String,
      default: "div"
    },
    square: Boolean,
    flat: Boolean,
    bordered: Boolean
  },
  setup(props, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = useDark(props, $q);
    const classes = computed(
      () => "q-card" + (isDark.value === true ? " q-card--dark q-dark" : "") + (props.bordered === true ? " q-card--bordered" : "") + (props.square === true ? " q-card--square no-border-radius" : "") + (props.flat === true ? " q-card--flat no-shadow" : "")
    );
    return () => h(props.tag, { class: classes.value }, hSlot(slots.default));
  }
});
const QCardSection = createComponent({
  name: "QCardSection",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    horizontal: Boolean
  },
  setup(props, { slots }) {
    const classes = computed(
      () => `q-card__section q-card__section--${props.horizontal === true ? "horiz row no-wrap" : "vert"}`
    );
    return () => h(props.tag, { class: classes.value }, hSlot(slots.default));
  }
});
const QCardActions = createComponent({
  name: "QCardActions",
  props: {
    ...useAlignProps,
    vertical: Boolean
  },
  setup(props, { slots }) {
    const alignClass = useAlign(props);
    const classes = computed(
      () => `q-card__actions ${alignClass.value} q-card__actions--${props.vertical === true ? "vert column" : "horiz row"}`
    );
    return () => h("div", { class: classes.value }, hSlot(slots.default));
  }
});
const insetMap = {
  true: "inset",
  item: "item-inset",
  "item-thumbnail": "item-thumbnail-inset"
};
const margins = {
  xs: 2,
  sm: 4,
  md: 8,
  lg: 16,
  xl: 24
};
const QSeparator = createComponent({
  name: "QSeparator",
  props: {
    ...useDarkProps,
    spaced: [Boolean, String],
    inset: [Boolean, String],
    vertical: Boolean,
    color: String,
    size: String
  },
  setup(props) {
    const vm = getCurrentInstance();
    const isDark = useDark(props, vm.proxy.$q);
    const orientation = computed(() => props.vertical === true ? "vertical" : "horizontal");
    const orientClass = computed(() => ` q-separator--${orientation.value}`);
    const insetClass = computed(() => props.inset !== false ? `${orientClass.value}-${insetMap[props.inset]}` : "");
    const classes = computed(
      () => `q-separator${orientClass.value}${insetClass.value}` + (props.color !== void 0 ? ` bg-${props.color}` : "") + (isDark.value === true ? " q-separator--dark" : "")
    );
    const style = computed(() => {
      const acc = {};
      if (props.size !== void 0) {
        acc[props.vertical === true ? "width" : "height"] = props.size;
      }
      if (props.spaced !== false) {
        const size2 = props.spaced === true ? `${margins.md}px` : props.spaced in margins ? `${margins[props.spaced]}px` : props.spaced;
        const dir = props.vertical === true ? ["Left", "Right"] : ["Top", "Bottom"];
        acc[`margin${dir[0]}`] = acc[`margin${dir[1]}`] = size2;
      }
      return acc;
    });
    return () => h("hr", {
      class: classes.value,
      style: style.value,
      "aria-orientation": orientation.value
    });
  }
});
const quasarKey = "_q_";
const formKey = "_q_fo_";
const tabsKey = "_q_tabs_";
const emptyRenderFn = () => {
};
function useFormChild({ validate, resetValidation, requiresQForm }) {
  const $form = inject(formKey, false);
  if ($form !== false) {
    const { props, proxy } = getCurrentInstance();
    Object.assign(proxy, { validate, resetValidation });
    watch(() => props.disable, (val) => {
      if (val === true) {
        typeof resetValidation === "function" && resetValidation();
        $form.unbindComponent(proxy);
      } else {
        $form.bindComponent(proxy);
      }
    });
    onMounted(() => {
      props.disable !== true && $form.bindComponent(proxy);
    });
    onBeforeUnmount(() => {
      props.disable !== true && $form.unbindComponent(proxy);
    });
  } else if (requiresQForm === true) {
    console.error("Parent QForm not found on useFormChild()!");
  }
}
const hex = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/, hexa = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/, hexOrHexa = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/, rgb = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/, rgba = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/;
const testPattern = {
  date: (v2) => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v2),
  time: (v2) => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(v2),
  fulltime: (v2) => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(v2),
  timeOrFulltime: (v2) => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(v2),
  email: (v2) => /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v2),
  hexColor: (v2) => hex.test(v2),
  hexaColor: (v2) => hexa.test(v2),
  hexOrHexaColor: (v2) => hexOrHexa.test(v2),
  rgbColor: (v2) => rgb.test(v2),
  rgbaColor: (v2) => rgba.test(v2),
  rgbOrRgbaColor: (v2) => rgb.test(v2) || rgba.test(v2),
  hexOrRgbColor: (v2) => hex.test(v2) || rgb.test(v2),
  hexaOrRgbaColor: (v2) => hexa.test(v2) || rgba.test(v2),
  anyColor: (v2) => hexOrHexa.test(v2) || rgb.test(v2) || rgba.test(v2)
};
function debounce(fn, wait = 250, immediate) {
  let timeout;
  function debounced() {
    const args = arguments;
    const later = () => {
      timeout = void 0;
      if (immediate !== true) {
        fn.apply(this, args);
      }
    };
    clearTimeout(timeout);
    if (immediate === true && timeout === void 0) {
      fn.apply(this, args);
    }
    timeout = setTimeout(later, wait);
  }
  debounced.cancel = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
const lazyRulesValues = [true, false, "ondemand"];
const useValidateProps = {
  modelValue: {},
  error: {
    type: Boolean,
    default: null
  },
  errorMessage: String,
  noErrorIcon: Boolean,
  rules: Array,
  reactiveRules: Boolean,
  lazyRules: {
    type: [Boolean, String],
    validator: (v2) => lazyRulesValues.includes(v2)
  }
};
function useValidate(focused, innerLoading) {
  const { props, proxy } = getCurrentInstance();
  const innerError = ref(false);
  const innerErrorMessage = ref(null);
  const isDirtyModel = ref(null);
  useFormChild({ validate, resetValidation });
  let validateIndex = 0, unwatchRules;
  const hasRules = computed(
    () => props.rules !== void 0 && props.rules !== null && props.rules.length > 0
  );
  const hasActiveRules = computed(
    () => props.disable !== true && hasRules.value === true
  );
  const hasError = computed(
    () => props.error === true || innerError.value === true
  );
  const errorMessage = computed(() => typeof props.errorMessage === "string" && props.errorMessage.length > 0 ? props.errorMessage : innerErrorMessage.value);
  watch(() => props.modelValue, () => {
    validateIfNeeded();
  });
  watch(() => props.reactiveRules, (val) => {
    if (val === true) {
      if (unwatchRules === void 0) {
        unwatchRules = watch(() => props.rules, () => {
          validateIfNeeded(true);
        });
      }
    } else if (unwatchRules !== void 0) {
      unwatchRules();
      unwatchRules = void 0;
    }
  }, { immediate: true });
  watch(focused, (val) => {
    if (val === true) {
      if (isDirtyModel.value === null) {
        isDirtyModel.value = false;
      }
    } else if (isDirtyModel.value === false) {
      isDirtyModel.value = true;
      if (hasActiveRules.value === true && props.lazyRules !== "ondemand" && innerLoading.value === false) {
        debouncedValidate();
      }
    }
  });
  function resetValidation() {
    validateIndex++;
    innerLoading.value = false;
    isDirtyModel.value = null;
    innerError.value = false;
    innerErrorMessage.value = null;
    debouncedValidate.cancel();
  }
  function validate(val = props.modelValue) {
    if (hasActiveRules.value !== true) {
      return true;
    }
    const index2 = ++validateIndex;
    const setDirty = innerLoading.value !== true ? () => {
      isDirtyModel.value = true;
    } : () => {
    };
    const update2 = (err, msg) => {
      err === true && setDirty();
      innerError.value = err;
      innerErrorMessage.value = msg || null;
      innerLoading.value = false;
    };
    const promises = [];
    for (let i = 0; i < props.rules.length; i++) {
      const rule = props.rules[i];
      let res;
      if (typeof rule === "function") {
        res = rule(val, testPattern);
      } else if (typeof rule === "string" && testPattern[rule] !== void 0) {
        res = testPattern[rule](val);
      }
      if (res === false || typeof res === "string") {
        update2(true, res);
        return false;
      } else if (res !== true && res !== void 0) {
        promises.push(res);
      }
    }
    if (promises.length === 0) {
      update2(false);
      return true;
    }
    innerLoading.value = true;
    return Promise.all(promises).then(
      (res) => {
        if (res === void 0 || Array.isArray(res) === false || res.length === 0) {
          index2 === validateIndex && update2(false);
          return true;
        }
        const msg = res.find((r) => r === false || typeof r === "string");
        index2 === validateIndex && update2(msg !== void 0, msg);
        return msg === void 0;
      },
      (e) => {
        if (index2 === validateIndex) {
          console.error(e);
          update2(true);
        }
        return false;
      }
    );
  }
  function validateIfNeeded(changedRules) {
    if (hasActiveRules.value === true && props.lazyRules !== "ondemand" && (isDirtyModel.value === true || props.lazyRules !== true && changedRules !== true)) {
      debouncedValidate();
    }
  }
  const debouncedValidate = debounce(validate, 0);
  onBeforeUnmount(() => {
    unwatchRules !== void 0 && unwatchRules();
    debouncedValidate.cancel();
  });
  Object.assign(proxy, { resetValidation, validate });
  injectProp(proxy, "hasError", () => hasError.value);
  return {
    isDirtyModel,
    hasRules,
    hasError,
    errorMessage,
    validate,
    resetValidation
  };
}
const listenerRE = /^on[A-Z]/;
function useSplitAttrs(attrs, vnode) {
  const acc = {
    listeners: ref({}),
    attributes: ref({})
  };
  function update2() {
    const attributes = {};
    const listeners = {};
    for (const key in attrs) {
      if (key !== "class" && key !== "style" && listenerRE.test(key) === false) {
        attributes[key] = attrs[key];
      }
    }
    for (const key in vnode.props) {
      if (listenerRE.test(key) === true) {
        listeners[key] = vnode.props[key];
      }
    }
    acc.attributes.value = attributes;
    acc.listeners.value = listeners;
  }
  onBeforeUpdate(update2);
  update2();
  return acc;
}
let buf, bufIdx = 0;
const hexBytes = new Array(256);
for (let i = 0; i < 256; i++) {
  hexBytes[i] = (i + 256).toString(16).substring(1);
}
const randomBytes = (() => {
  const lib = typeof crypto !== "undefined" ? crypto : typeof window !== "undefined" ? window.crypto || window.msCrypto : void 0;
  if (lib !== void 0) {
    if (lib.randomBytes !== void 0) {
      return lib.randomBytes;
    }
    if (lib.getRandomValues !== void 0) {
      return (n) => {
        const bytes = new Uint8Array(n);
        lib.getRandomValues(bytes);
        return bytes;
      };
    }
  }
  return (n) => {
    const r = [];
    for (let i = n; i > 0; i--) {
      r.push(Math.floor(Math.random() * 256));
    }
    return r;
  };
})();
const BUFFER_SIZE = 4096;
function uid$2() {
  if (buf === void 0 || bufIdx + 16 > BUFFER_SIZE) {
    bufIdx = 0;
    buf = randomBytes(BUFFER_SIZE);
  }
  const b = Array.prototype.slice.call(buf, bufIdx, bufIdx += 16);
  b[6] = b[6] & 15 | 64;
  b[8] = b[8] & 63 | 128;
  return hexBytes[b[0]] + hexBytes[b[1]] + hexBytes[b[2]] + hexBytes[b[3]] + "-" + hexBytes[b[4]] + hexBytes[b[5]] + "-" + hexBytes[b[6]] + hexBytes[b[7]] + "-" + hexBytes[b[8]] + hexBytes[b[9]] + "-" + hexBytes[b[10]] + hexBytes[b[11]] + hexBytes[b[12]] + hexBytes[b[13]] + hexBytes[b[14]] + hexBytes[b[15]];
}
function getTargetUid(val) {
  return val === void 0 ? `f_${uid$2()}` : val;
}
function fieldValueIsFilled(val) {
  return val !== void 0 && val !== null && ("" + val).length > 0;
}
const useFieldProps = {
  ...useDarkProps,
  ...useValidateProps,
  label: String,
  stackLabel: Boolean,
  hint: String,
  hideHint: Boolean,
  prefix: String,
  suffix: String,
  labelColor: String,
  color: String,
  bgColor: String,
  filled: Boolean,
  outlined: Boolean,
  borderless: Boolean,
  standout: [Boolean, String],
  square: Boolean,
  loading: Boolean,
  labelSlot: Boolean,
  bottomSlots: Boolean,
  hideBottomSpace: Boolean,
  rounded: Boolean,
  dense: Boolean,
  itemAligned: Boolean,
  counter: Boolean,
  clearable: Boolean,
  clearIcon: String,
  disable: Boolean,
  readonly: Boolean,
  autofocus: Boolean,
  for: String,
  maxlength: [Number, String]
};
const useFieldEmits = ["update:modelValue", "clear", "focus", "blur", "popupShow", "popupHide"];
function useFieldState() {
  const { props, attrs, proxy, vnode } = getCurrentInstance();
  const isDark = useDark(props, proxy.$q);
  return {
    isDark,
    editable: computed(
      () => props.disable !== true && props.readonly !== true
    ),
    innerLoading: ref(false),
    focused: ref(false),
    hasPopupOpen: false,
    splitAttrs: useSplitAttrs(attrs, vnode),
    targetUid: ref(getTargetUid(props.for)),
    rootRef: ref(null),
    targetRef: ref(null),
    controlRef: ref(null)
  };
}
function useField(state) {
  const { props, emit, slots, attrs, proxy } = getCurrentInstance();
  const { $q } = proxy;
  let focusoutTimer;
  if (state.hasValue === void 0) {
    state.hasValue = computed(() => fieldValueIsFilled(props.modelValue));
  }
  if (state.emitValue === void 0) {
    state.emitValue = (value2) => {
      emit("update:modelValue", value2);
    };
  }
  if (state.controlEvents === void 0) {
    state.controlEvents = {
      onFocusin: onControlFocusin,
      onFocusout: onControlFocusout
    };
  }
  Object.assign(state, {
    clearValue,
    onControlFocusin,
    onControlFocusout,
    focus
  });
  if (state.computedCounter === void 0) {
    state.computedCounter = computed(() => {
      if (props.counter !== false) {
        const len = typeof props.modelValue === "string" || typeof props.modelValue === "number" ? ("" + props.modelValue).length : Array.isArray(props.modelValue) === true ? props.modelValue.length : 0;
        const max = props.maxlength !== void 0 ? props.maxlength : props.maxValues;
        return len + (max !== void 0 ? " / " + max : "");
      }
    });
  }
  const {
    isDirtyModel,
    hasRules,
    hasError,
    errorMessage,
    resetValidation
  } = useValidate(state.focused, state.innerLoading);
  const floatingLabel = state.floatingLabel !== void 0 ? computed(() => props.stackLabel === true || state.focused.value === true || state.floatingLabel.value === true) : computed(() => props.stackLabel === true || state.focused.value === true || state.hasValue.value === true);
  const shouldRenderBottom = computed(
    () => props.bottomSlots === true || props.hint !== void 0 || hasRules.value === true || props.counter === true || props.error !== null
  );
  const styleType = computed(() => {
    if (props.filled === true) {
      return "filled";
    }
    if (props.outlined === true) {
      return "outlined";
    }
    if (props.borderless === true) {
      return "borderless";
    }
    if (props.standout) {
      return "standout";
    }
    return "standard";
  });
  const classes = computed(
    () => `q-field row no-wrap items-start q-field--${styleType.value}` + (state.fieldClass !== void 0 ? ` ${state.fieldClass.value}` : "") + (props.rounded === true ? " q-field--rounded" : "") + (props.square === true ? " q-field--square" : "") + (floatingLabel.value === true ? " q-field--float" : "") + (hasLabel.value === true ? " q-field--labeled" : "") + (props.dense === true ? " q-field--dense" : "") + (props.itemAligned === true ? " q-field--item-aligned q-item-type" : "") + (state.isDark.value === true ? " q-field--dark" : "") + (state.getControl === void 0 ? " q-field--auto-height" : "") + (state.focused.value === true ? " q-field--focused" : "") + (hasError.value === true ? " q-field--error" : "") + (hasError.value === true || state.focused.value === true ? " q-field--highlighted" : "") + (props.hideBottomSpace !== true && shouldRenderBottom.value === true ? " q-field--with-bottom" : "") + (props.disable === true ? " q-field--disabled" : props.readonly === true ? " q-field--readonly" : "")
  );
  const contentClass = computed(
    () => "q-field__control relative-position row no-wrap" + (props.bgColor !== void 0 ? ` bg-${props.bgColor}` : "") + (hasError.value === true ? " text-negative" : typeof props.standout === "string" && props.standout.length > 0 && state.focused.value === true ? ` ${props.standout}` : props.color !== void 0 ? ` text-${props.color}` : "")
  );
  const hasLabel = computed(
    () => props.labelSlot === true || props.label !== void 0
  );
  const labelClass = computed(
    () => "q-field__label no-pointer-events absolute ellipsis" + (props.labelColor !== void 0 && hasError.value !== true ? ` text-${props.labelColor}` : "")
  );
  const controlSlotScope = computed(() => ({
    id: state.targetUid.value,
    editable: state.editable.value,
    focused: state.focused.value,
    floatingLabel: floatingLabel.value,
    modelValue: props.modelValue,
    emitValue: state.emitValue
  }));
  const attributes = computed(() => {
    const acc = {
      for: state.targetUid.value
    };
    if (props.disable === true) {
      acc["aria-disabled"] = "true";
    } else if (props.readonly === true) {
      acc["aria-readonly"] = "true";
    }
    return acc;
  });
  watch(() => props.for, (val) => {
    state.targetUid.value = getTargetUid(val);
  });
  function focusHandler() {
    const el = document.activeElement;
    let target2 = state.targetRef !== void 0 && state.targetRef.value;
    if (target2 && (el === null || el.id !== state.targetUid.value)) {
      target2.hasAttribute("tabindex") === true || (target2 = target2.querySelector("[tabindex]"));
      if (target2 && target2 !== el) {
        target2.focus({ preventScroll: true });
      }
    }
  }
  function focus() {
    addFocusFn(focusHandler);
  }
  function blur() {
    removeFocusFn(focusHandler);
    const el = document.activeElement;
    if (el !== null && state.rootRef.value.contains(el)) {
      el.blur();
    }
  }
  function onControlFocusin(e) {
    clearTimeout(focusoutTimer);
    if (state.editable.value === true && state.focused.value === false) {
      state.focused.value = true;
      emit("focus", e);
    }
  }
  function onControlFocusout(e, then) {
    clearTimeout(focusoutTimer);
    focusoutTimer = setTimeout(() => {
      if (document.hasFocus() === true && (state.hasPopupOpen === true || state.controlRef === void 0 || state.controlRef.value === null || state.controlRef.value.contains(document.activeElement) !== false)) {
        return;
      }
      if (state.focused.value === true) {
        state.focused.value = false;
        emit("blur", e);
      }
      then !== void 0 && then();
    });
  }
  function clearValue(e) {
    stopAndPrevent(e);
    if ($q.platform.is.mobile !== true) {
      const el = state.targetRef !== void 0 && state.targetRef.value || state.rootRef.value;
      el.focus();
    } else if (state.rootRef.value.contains(document.activeElement) === true) {
      document.activeElement.blur();
    }
    if (props.type === "file") {
      state.inputRef.value.value = null;
    }
    emit("update:modelValue", null);
    emit("clear", props.modelValue);
    nextTick(() => {
      resetValidation();
      if ($q.platform.is.mobile !== true) {
        isDirtyModel.value = false;
      }
    });
  }
  function getContent() {
    const node = [];
    slots.prepend !== void 0 && node.push(
      h("div", {
        class: "q-field__prepend q-field__marginal row no-wrap items-center",
        key: "prepend",
        onClick: prevent
      }, slots.prepend())
    );
    node.push(
      h("div", {
        class: "q-field__control-container col relative-position row no-wrap q-anchor--skip"
      }, getControlContainer())
    );
    hasError.value === true && props.noErrorIcon === false && node.push(
      getInnerAppendNode("error", [
        h(QIcon, { name: $q.iconSet.field.error, color: "negative" })
      ])
    );
    if (props.loading === true || state.innerLoading.value === true) {
      node.push(
        getInnerAppendNode(
          "inner-loading-append",
          slots.loading !== void 0 ? slots.loading() : [h(QSpinner, { color: props.color })]
        )
      );
    } else if (props.clearable === true && state.hasValue.value === true && state.editable.value === true) {
      node.push(
        getInnerAppendNode("inner-clearable-append", [
          h(QIcon, {
            class: "q-field__focusable-action",
            tag: "button",
            name: props.clearIcon || $q.iconSet.field.clear,
            tabindex: 0,
            type: "button",
            "aria-hidden": null,
            role: null,
            onClick: clearValue
          })
        ])
      );
    }
    slots.append !== void 0 && node.push(
      h("div", {
        class: "q-field__append q-field__marginal row no-wrap items-center",
        key: "append",
        onClick: prevent
      }, slots.append())
    );
    state.getInnerAppend !== void 0 && node.push(
      getInnerAppendNode("inner-append", state.getInnerAppend())
    );
    state.getControlChild !== void 0 && node.push(
      state.getControlChild()
    );
    return node;
  }
  function getControlContainer() {
    const node = [];
    props.prefix !== void 0 && props.prefix !== null && node.push(
      h("div", {
        class: "q-field__prefix no-pointer-events row items-center"
      }, props.prefix)
    );
    if (state.getShadowControl !== void 0 && state.hasShadow.value === true) {
      node.push(
        state.getShadowControl()
      );
    }
    if (state.getControl !== void 0) {
      node.push(state.getControl());
    } else if (slots.rawControl !== void 0) {
      node.push(slots.rawControl());
    } else if (slots.control !== void 0) {
      node.push(
        h("div", {
          ref: state.targetRef,
          class: "q-field__native row",
          tabindex: -1,
          ...state.splitAttrs.attributes.value,
          "data-autofocus": props.autofocus === true || void 0
        }, slots.control(controlSlotScope.value))
      );
    }
    hasLabel.value === true && node.push(
      h("div", {
        class: labelClass.value
      }, hSlot(slots.label, props.label))
    );
    props.suffix !== void 0 && props.suffix !== null && node.push(
      h("div", {
        class: "q-field__suffix no-pointer-events row items-center"
      }, props.suffix)
    );
    return node.concat(hSlot(slots.default));
  }
  function getBottom() {
    let msg, key;
    if (hasError.value === true) {
      if (errorMessage.value !== null) {
        msg = [h("div", { role: "alert" }, errorMessage.value)];
        key = `q--slot-error-${errorMessage.value}`;
      } else {
        msg = hSlot(slots.error);
        key = "q--slot-error";
      }
    } else if (props.hideHint !== true || state.focused.value === true) {
      if (props.hint !== void 0) {
        msg = [h("div", props.hint)];
        key = `q--slot-hint-${props.hint}`;
      } else {
        msg = hSlot(slots.hint);
        key = "q--slot-hint";
      }
    }
    const hasCounter = props.counter === true || slots.counter !== void 0;
    if (props.hideBottomSpace === true && hasCounter === false && msg === void 0) {
      return;
    }
    const main = h("div", {
      key,
      class: "q-field__messages col"
    }, msg);
    return h("div", {
      class: "q-field__bottom row items-start q-field__bottom--" + (props.hideBottomSpace !== true ? "animated" : "stale"),
      onClick: prevent
    }, [
      props.hideBottomSpace === true ? main : h(Transition, { name: "q-transition--field-message" }, () => main),
      hasCounter === true ? h("div", {
        class: "q-field__counter"
      }, slots.counter !== void 0 ? slots.counter() : state.computedCounter.value) : null
    ]);
  }
  function getInnerAppendNode(key, content) {
    return content === null ? null : h("div", {
      key,
      class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip"
    }, content);
  }
  let shouldActivate = false;
  onDeactivated(() => {
    shouldActivate = true;
  });
  onActivated(() => {
    shouldActivate === true && props.autofocus === true && proxy.focus();
  });
  onMounted(() => {
    if (isRuntimeSsrPreHydration.value === true && props.for === void 0) {
      state.targetUid.value = getTargetUid();
    }
    props.autofocus === true && proxy.focus();
  });
  onBeforeUnmount(() => {
    clearTimeout(focusoutTimer);
  });
  Object.assign(proxy, { focus, blur });
  return function renderField() {
    const labelAttrs = state.getControl === void 0 && slots.control === void 0 ? {
      ...state.splitAttrs.attributes.value,
      "data-autofocus": props.autofocus === true || void 0,
      ...attributes.value
    } : attributes.value;
    return h("label", {
      ref: state.rootRef,
      class: [
        classes.value,
        attrs.class
      ],
      style: attrs.style,
      ...labelAttrs
    }, [
      slots.before !== void 0 ? h("div", {
        class: "q-field__before q-field__marginal row no-wrap items-center",
        onClick: prevent
      }, slots.before()) : null,
      h("div", {
        class: "q-field__inner relative-position col self-stretch"
      }, [
        h("div", {
          ref: state.controlRef,
          class: contentClass.value,
          tabindex: -1,
          ...state.controlEvents
        }, getContent()),
        shouldRenderBottom.value === true ? getBottom() : null
      ]),
      slots.after !== void 0 ? h("div", {
        class: "q-field__after q-field__marginal row no-wrap items-center",
        onClick: prevent
      }, slots.after()) : null
    ]);
  };
}
const NAMED_MASKS = {
  date: "####/##/##",
  datetime: "####/##/## ##:##",
  time: "##:##",
  fulltime: "##:##:##",
  phone: "(###) ### - ####",
  card: "#### #### #### ####"
};
const TOKENS = {
  "#": { pattern: "[\\d]", negate: "[^\\d]" },
  S: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]" },
  N: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]" },
  A: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (v2) => v2.toLocaleUpperCase() },
  a: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (v2) => v2.toLocaleLowerCase() },
  X: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (v2) => v2.toLocaleUpperCase() },
  x: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (v2) => v2.toLocaleLowerCase() }
};
const KEYS = Object.keys(TOKENS);
KEYS.forEach((key) => {
  TOKENS[key].regex = new RegExp(TOKENS[key].pattern);
});
const tokenRegexMask = new RegExp("\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([" + KEYS.join("") + "])|(.)", "g"), escRegex = /[.*+?^${}()|[\]\\]/g;
const MARKER = String.fromCharCode(1);
const useMaskProps = {
  mask: String,
  reverseFillMask: Boolean,
  fillMask: [Boolean, String],
  unmaskedValue: Boolean
};
function useMask(props, emit, emitValue, inputRef) {
  let maskMarked, maskReplaced, computedMask, computedUnmask;
  const hasMask = ref(null);
  const innerValue = ref(getInitialMaskedValue());
  function getIsTypeText() {
    return props.autogrow === true || ["textarea", "text", "search", "url", "tel", "password"].includes(props.type);
  }
  watch(() => props.type + props.autogrow, updateMaskInternals);
  watch(() => props.mask, (v2) => {
    if (v2 !== void 0) {
      updateMaskValue(innerValue.value, true);
    } else {
      const val = unmaskValue(innerValue.value);
      updateMaskInternals();
      props.modelValue !== val && emit("update:modelValue", val);
    }
  });
  watch(() => props.fillMask + props.reverseFillMask, () => {
    hasMask.value === true && updateMaskValue(innerValue.value, true);
  });
  watch(() => props.unmaskedValue, () => {
    hasMask.value === true && updateMaskValue(innerValue.value);
  });
  function getInitialMaskedValue() {
    updateMaskInternals();
    if (hasMask.value === true) {
      const masked = maskValue(unmaskValue(props.modelValue));
      return props.fillMask !== false ? fillWithMask(masked) : masked;
    }
    return props.modelValue;
  }
  function getPaddedMaskMarked(size2) {
    if (size2 < maskMarked.length) {
      return maskMarked.slice(-size2);
    }
    let pad = "", localMaskMarked = maskMarked;
    const padPos = localMaskMarked.indexOf(MARKER);
    if (padPos > -1) {
      for (let i = size2 - localMaskMarked.length; i > 0; i--) {
        pad += MARKER;
      }
      localMaskMarked = localMaskMarked.slice(0, padPos) + pad + localMaskMarked.slice(padPos);
    }
    return localMaskMarked;
  }
  function updateMaskInternals() {
    hasMask.value = props.mask !== void 0 && props.mask.length > 0 && getIsTypeText();
    if (hasMask.value === false) {
      computedUnmask = void 0;
      maskMarked = "";
      maskReplaced = "";
      return;
    }
    const localComputedMask = NAMED_MASKS[props.mask] === void 0 ? props.mask : NAMED_MASKS[props.mask], fillChar = typeof props.fillMask === "string" && props.fillMask.length > 0 ? props.fillMask.slice(0, 1) : "_", fillCharEscaped = fillChar.replace(escRegex, "\\$&"), unmask = [], extract = [], mask = [];
    let firstMatch = props.reverseFillMask === true, unmaskChar = "", negateChar = "";
    localComputedMask.replace(tokenRegexMask, (_, char1, esc, token, char2) => {
      if (token !== void 0) {
        const c = TOKENS[token];
        mask.push(c);
        negateChar = c.negate;
        if (firstMatch === true) {
          extract.push("(?:" + negateChar + "+)?(" + c.pattern + "+)?(?:" + negateChar + "+)?(" + c.pattern + "+)?");
          firstMatch = false;
        }
        extract.push("(?:" + negateChar + "+)?(" + c.pattern + ")?");
      } else if (esc !== void 0) {
        unmaskChar = "\\" + (esc === "\\" ? "" : esc);
        mask.push(esc);
        unmask.push("([^" + unmaskChar + "]+)?" + unmaskChar + "?");
      } else {
        const c = char1 !== void 0 ? char1 : char2;
        unmaskChar = c === "\\" ? "\\\\\\\\" : c.replace(escRegex, "\\\\$&");
        mask.push(c);
        unmask.push("([^" + unmaskChar + "]+)?" + unmaskChar + "?");
      }
    });
    const unmaskMatcher = new RegExp(
      "^" + unmask.join("") + "(" + (unmaskChar === "" ? "." : "[^" + unmaskChar + "]") + "+)?" + (unmaskChar === "" ? "" : "[" + unmaskChar + "]*") + "$"
    ), extractLast = extract.length - 1, extractMatcher = extract.map((re, index2) => {
      if (index2 === 0 && props.reverseFillMask === true) {
        return new RegExp("^" + fillCharEscaped + "*" + re);
      } else if (index2 === extractLast) {
        return new RegExp(
          "^" + re + "(" + (negateChar === "" ? "." : negateChar) + "+)?" + (props.reverseFillMask === true ? "$" : fillCharEscaped + "*")
        );
      }
      return new RegExp("^" + re);
    });
    computedMask = mask;
    computedUnmask = (val) => {
      const unmaskMatch = unmaskMatcher.exec(props.reverseFillMask === true ? val : val.slice(0, mask.length));
      if (unmaskMatch !== null) {
        val = unmaskMatch.slice(1).join("");
      }
      const extractMatch = [], extractMatcherLength = extractMatcher.length;
      for (let i = 0, str = val; i < extractMatcherLength; i++) {
        const m = extractMatcher[i].exec(str);
        if (m === null) {
          break;
        }
        str = str.slice(m.shift().length);
        extractMatch.push(...m);
      }
      if (extractMatch.length > 0) {
        return extractMatch.join("");
      }
      return val;
    };
    maskMarked = mask.map((v2) => typeof v2 === "string" ? v2 : MARKER).join("");
    maskReplaced = maskMarked.split(MARKER).join(fillChar);
  }
  function updateMaskValue(rawVal, updateMaskInternalsFlag, inputType) {
    const inp = inputRef.value, end = inp.selectionEnd, endReverse = inp.value.length - end, unmasked = unmaskValue(rawVal);
    updateMaskInternalsFlag === true && updateMaskInternals();
    const preMasked = maskValue(unmasked), masked = props.fillMask !== false ? fillWithMask(preMasked) : preMasked, changed = innerValue.value !== masked;
    inp.value !== masked && (inp.value = masked);
    changed === true && (innerValue.value = masked);
    document.activeElement === inp && nextTick(() => {
      if (masked === maskReplaced) {
        const cursor = props.reverseFillMask === true ? maskReplaced.length : 0;
        inp.setSelectionRange(cursor, cursor, "forward");
        return;
      }
      if (inputType === "insertFromPaste" && props.reverseFillMask !== true) {
        const cursor = end - 1;
        moveCursor.right(inp, cursor, cursor);
        return;
      }
      if (["deleteContentBackward", "deleteContentForward"].indexOf(inputType) > -1) {
        const cursor = props.reverseFillMask === true ? end === 0 ? masked.length > preMasked.length ? 1 : 0 : Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1 : end;
        inp.setSelectionRange(cursor, cursor, "forward");
        return;
      }
      if (props.reverseFillMask === true) {
        if (changed === true) {
          const cursor = Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)));
          if (cursor === 1 && end === 1) {
            inp.setSelectionRange(cursor, cursor, "forward");
          } else {
            moveCursor.rightReverse(inp, cursor, cursor);
          }
        } else {
          const cursor = masked.length - endReverse;
          inp.setSelectionRange(cursor, cursor, "backward");
        }
      } else {
        if (changed === true) {
          const cursor = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1);
          moveCursor.right(inp, cursor, cursor);
        } else {
          const cursor = end - 1;
          moveCursor.right(inp, cursor, cursor);
        }
      }
    });
    const val = props.unmaskedValue === true ? unmaskValue(masked) : masked;
    String(props.modelValue) !== val && emitValue(val, true);
  }
  function moveCursorForPaste(inp, start, end) {
    const preMasked = maskValue(unmaskValue(inp.value));
    start = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, start));
    inp.setSelectionRange(start, end, "forward");
  }
  const moveCursor = {
    left(inp, start, end, selection) {
      const noMarkBefore = maskMarked.slice(start - 1).indexOf(MARKER) === -1;
      let i = Math.max(0, start - 1);
      for (; i >= 0; i--) {
        if (maskMarked[i] === MARKER) {
          start = i;
          noMarkBefore === true && start++;
          break;
        }
      }
      if (i < 0 && maskMarked[start] !== void 0 && maskMarked[start] !== MARKER) {
        return moveCursor.right(inp, 0, 0);
      }
      start >= 0 && inp.setSelectionRange(
        start,
        selection === true ? end : start,
        "backward"
      );
    },
    right(inp, start, end, selection) {
      const limit = inp.value.length;
      let i = Math.min(limit, end + 1);
      for (; i <= limit; i++) {
        if (maskMarked[i] === MARKER) {
          end = i;
          break;
        } else if (maskMarked[i - 1] === MARKER) {
          end = i;
        }
      }
      if (i > limit && maskMarked[end - 1] !== void 0 && maskMarked[end - 1] !== MARKER) {
        return moveCursor.left(inp, limit, limit);
      }
      inp.setSelectionRange(selection ? start : end, end, "forward");
    },
    leftReverse(inp, start, end, selection) {
      const localMaskMarked = getPaddedMaskMarked(inp.value.length);
      let i = Math.max(0, start - 1);
      for (; i >= 0; i--) {
        if (localMaskMarked[i - 1] === MARKER) {
          start = i;
          break;
        } else if (localMaskMarked[i] === MARKER) {
          start = i;
          if (i === 0) {
            break;
          }
        }
      }
      if (i < 0 && localMaskMarked[start] !== void 0 && localMaskMarked[start] !== MARKER) {
        return moveCursor.rightReverse(inp, 0, 0);
      }
      start >= 0 && inp.setSelectionRange(
        start,
        selection === true ? end : start,
        "backward"
      );
    },
    rightReverse(inp, start, end, selection) {
      const limit = inp.value.length, localMaskMarked = getPaddedMaskMarked(limit), noMarkBefore = localMaskMarked.slice(0, end + 1).indexOf(MARKER) === -1;
      let i = Math.min(limit, end + 1);
      for (; i <= limit; i++) {
        if (localMaskMarked[i - 1] === MARKER) {
          end = i;
          end > 0 && noMarkBefore === true && end--;
          break;
        }
      }
      if (i > limit && localMaskMarked[end - 1] !== void 0 && localMaskMarked[end - 1] !== MARKER) {
        return moveCursor.leftReverse(inp, limit, limit);
      }
      inp.setSelectionRange(selection === true ? start : end, end, "forward");
    }
  };
  function onMaskedKeydown(e) {
    emit("keydown", e);
    if (shouldIgnoreKey(e) === true) {
      return;
    }
    const inp = inputRef.value, start = inp.selectionStart, end = inp.selectionEnd;
    if (e.keyCode === 37 || e.keyCode === 39) {
      const fn = moveCursor[(e.keyCode === 39 ? "right" : "left") + (props.reverseFillMask === true ? "Reverse" : "")];
      e.preventDefault();
      fn(inp, start, end, e.shiftKey);
    } else if (e.keyCode === 8 && props.reverseFillMask !== true && start === end) {
      moveCursor.left(inp, start, end, true);
    } else if (e.keyCode === 46 && props.reverseFillMask === true && start === end) {
      moveCursor.rightReverse(inp, start, end, true);
    }
  }
  function maskValue(val) {
    if (val === void 0 || val === null || val === "") {
      return "";
    }
    if (props.reverseFillMask === true) {
      return maskValueReverse(val);
    }
    const mask = computedMask;
    let valIndex = 0, output = "";
    for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {
      const valChar = val[valIndex], maskDef = mask[maskIndex];
      if (typeof maskDef === "string") {
        output += maskDef;
        valChar === maskDef && valIndex++;
      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
        output += maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar;
        valIndex++;
      } else {
        return output;
      }
    }
    return output;
  }
  function maskValueReverse(val) {
    const mask = computedMask, firstTokenIndex = maskMarked.indexOf(MARKER);
    let valIndex = val.length - 1, output = "";
    for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex > -1; maskIndex--) {
      const maskDef = mask[maskIndex];
      let valChar = val[valIndex];
      if (typeof maskDef === "string") {
        output = maskDef + output;
        valChar === maskDef && valIndex--;
      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
        do {
          output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output;
          valIndex--;
          valChar = val[valIndex];
        } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar));
      } else {
        return output;
      }
    }
    return output;
  }
  function unmaskValue(val) {
    return typeof val !== "string" || computedUnmask === void 0 ? typeof val === "number" ? computedUnmask("" + val) : val : computedUnmask(val);
  }
  function fillWithMask(val) {
    if (maskReplaced.length - val.length <= 0) {
      return val;
    }
    return props.reverseFillMask === true && val.length > 0 ? maskReplaced.slice(0, -val.length) + val : val + maskReplaced.slice(val.length);
  }
  return {
    innerValue,
    hasMask,
    moveCursorForPaste,
    updateMaskValue,
    onMaskedKeydown
  };
}
const useFormProps = {
  name: String
};
function useFormInject(formAttrs = {}) {
  return (child, action, className) => {
    child[action](
      h("input", {
        class: "hidden" + (className || ""),
        ...formAttrs.value
      })
    );
  };
}
function useFormInputNameAttr(props) {
  return computed(() => props.name || props.for);
}
function useFileFormDomProps(props, typeGuard) {
  function getFormDomProps() {
    const model = props.modelValue;
    try {
      const dt = "DataTransfer" in window ? new DataTransfer() : "ClipboardEvent" in window ? new ClipboardEvent("").clipboardData : void 0;
      if (Object(model) === model) {
        ("length" in model ? Array.from(model) : [model]).forEach((file) => {
          dt.items.add(file);
        });
      }
      return {
        files: dt.files
      };
    } catch (e) {
      return {
        files: void 0
      };
    }
  }
  return typeGuard === true ? computed(() => {
    if (props.type !== "file") {
      return;
    }
    return getFormDomProps();
  }) : computed(getFormDomProps);
}
const isJapanese = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/;
const isChinese = /[\u4e00-\u9fff\u3400-\u4dbf\u{20000}-\u{2a6df}\u{2a700}-\u{2b73f}\u{2b740}-\u{2b81f}\u{2b820}-\u{2ceaf}\uf900-\ufaff\u3300-\u33ff\ufe30-\ufe4f\uf900-\ufaff\u{2f800}-\u{2fa1f}]/u;
const isKorean = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/;
const isPlainText = /[a-z0-9_ -]$/i;
function useKeyComposition(onInput) {
  return function onComposition(e) {
    if (e.type === "compositionend" || e.type === "change") {
      if (e.target.qComposing !== true) {
        return;
      }
      e.target.qComposing = false;
      onInput(e);
    } else if (e.type === "compositionupdate" && e.target.qComposing !== true && typeof e.data === "string") {
      const isComposing = client.is.firefox === true ? isPlainText.test(e.data) === false : isJapanese.test(e.data) === true || isChinese.test(e.data) === true || isKorean.test(e.data) === true;
      if (isComposing === true) {
        e.target.qComposing = true;
      }
    }
  };
}
const QInput = createComponent({
  name: "QInput",
  inheritAttrs: false,
  props: {
    ...useFieldProps,
    ...useMaskProps,
    ...useFormProps,
    modelValue: { required: false },
    shadowText: String,
    type: {
      type: String,
      default: "text"
    },
    debounce: [String, Number],
    autogrow: Boolean,
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  emits: [
    ...useFieldEmits,
    "paste",
    "change",
    "keydown",
    "animationend"
  ],
  setup(props, { emit, attrs }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const temp = {};
    let emitCachedValue = NaN, typedNumber, stopValueWatcher, emitTimer, emitValueFn;
    const inputRef = ref(null);
    const nameProp = useFormInputNameAttr(props);
    const {
      innerValue,
      hasMask,
      moveCursorForPaste,
      updateMaskValue,
      onMaskedKeydown
    } = useMask(props, emit, emitValue, inputRef);
    const formDomProps = useFileFormDomProps(props, true);
    const hasValue = computed(() => fieldValueIsFilled(innerValue.value));
    const onComposition = useKeyComposition(onInput);
    const state = useFieldState();
    const isTextarea = computed(
      () => props.type === "textarea" || props.autogrow === true
    );
    const isTypeText = computed(
      () => isTextarea.value === true || ["text", "search", "url", "tel", "password"].includes(props.type)
    );
    const onEvents = computed(() => {
      const evt = {
        ...state.splitAttrs.listeners.value,
        onInput,
        onPaste,
        onChange,
        onBlur: onFinishEditing,
        onFocus: stop
      };
      evt.onCompositionstart = evt.onCompositionupdate = evt.onCompositionend = onComposition;
      if (hasMask.value === true) {
        evt.onKeydown = onMaskedKeydown;
      }
      if (props.autogrow === true) {
        evt.onAnimationend = onAnimationend;
      }
      return evt;
    });
    const inputAttrs = computed(() => {
      const attrs2 = {
        tabindex: 0,
        "data-autofocus": props.autofocus === true || void 0,
        rows: props.type === "textarea" ? 6 : void 0,
        "aria-label": props.label,
        name: nameProp.value,
        ...state.splitAttrs.attributes.value,
        id: state.targetUid.value,
        maxlength: props.maxlength,
        disabled: props.disable === true,
        readonly: props.readonly === true
      };
      if (isTextarea.value === false) {
        attrs2.type = props.type;
      }
      if (props.autogrow === true) {
        attrs2.rows = 1;
      }
      return attrs2;
    });
    watch(() => props.type, () => {
      if (inputRef.value) {
        inputRef.value.value = props.modelValue;
      }
    });
    watch(() => props.modelValue, (v2) => {
      if (hasMask.value === true) {
        if (stopValueWatcher === true) {
          stopValueWatcher = false;
          if (String(v2) === emitCachedValue) {
            return;
          }
        }
        updateMaskValue(v2);
      } else if (innerValue.value !== v2) {
        innerValue.value = v2;
        if (props.type === "number" && temp.hasOwnProperty("value") === true) {
          if (typedNumber === true) {
            typedNumber = false;
          } else {
            delete temp.value;
          }
        }
      }
      props.autogrow === true && nextTick(adjustHeight);
    });
    watch(() => props.autogrow, (val) => {
      if (val === true) {
        nextTick(adjustHeight);
      } else if (inputRef.value !== null && attrs.rows > 0) {
        inputRef.value.style.height = "auto";
      }
    });
    watch(() => props.dense, () => {
      props.autogrow === true && nextTick(adjustHeight);
    });
    function focus() {
      addFocusFn(() => {
        const el = document.activeElement;
        if (inputRef.value !== null && inputRef.value !== el && (el === null || el.id !== state.targetUid.value)) {
          inputRef.value.focus({ preventScroll: true });
        }
      });
    }
    function select() {
      inputRef.value !== null && inputRef.value.select();
    }
    function onPaste(e) {
      if (hasMask.value === true && props.reverseFillMask !== true) {
        const inp = e.target;
        moveCursorForPaste(inp, inp.selectionStart, inp.selectionEnd);
      }
      emit("paste", e);
    }
    function onInput(e) {
      if (!e || !e.target) {
        return;
      }
      if (props.type === "file") {
        emit("update:modelValue", e.target.files);
        return;
      }
      const val = e.target.value;
      if (e.target.qComposing === true) {
        temp.value = val;
        return;
      }
      if (hasMask.value === true) {
        updateMaskValue(val, false, e.inputType);
      } else {
        emitValue(val);
        if (isTypeText.value === true && e.target === document.activeElement) {
          const { selectionStart, selectionEnd } = e.target;
          if (selectionStart !== void 0 && selectionEnd !== void 0) {
            nextTick(() => {
              if (e.target === document.activeElement && val.indexOf(e.target.value) === 0) {
                e.target.setSelectionRange(selectionStart, selectionEnd);
              }
            });
          }
        }
      }
      props.autogrow === true && adjustHeight();
    }
    function onAnimationend(e) {
      emit("animationend", e);
      adjustHeight();
    }
    function emitValue(val, stopWatcher) {
      emitValueFn = () => {
        if (props.type !== "number" && temp.hasOwnProperty("value") === true) {
          delete temp.value;
        }
        if (props.modelValue !== val && emitCachedValue !== val) {
          emitCachedValue = val;
          stopWatcher === true && (stopValueWatcher = true);
          emit("update:modelValue", val);
          nextTick(() => {
            emitCachedValue === val && (emitCachedValue = NaN);
          });
        }
        emitValueFn = void 0;
      };
      if (props.type === "number") {
        typedNumber = true;
        temp.value = val;
      }
      if (props.debounce !== void 0) {
        clearTimeout(emitTimer);
        temp.value = val;
        emitTimer = setTimeout(emitValueFn, props.debounce);
      } else {
        emitValueFn();
      }
    }
    function adjustHeight() {
      requestAnimationFrame(() => {
        const inp = inputRef.value;
        if (inp !== null) {
          const parentStyle = inp.parentNode.style;
          const { overflow } = inp.style;
          $q.platform.is.firefox !== true && (inp.style.overflow = "hidden");
          inp.style.height = "1px";
          parentStyle.marginBottom = inp.scrollHeight - 1 + "px";
          inp.style.height = inp.scrollHeight + "px";
          inp.style.overflow = overflow;
          parentStyle.marginBottom = "";
        }
      });
    }
    function onChange(e) {
      onComposition(e);
      clearTimeout(emitTimer);
      emitValueFn !== void 0 && emitValueFn();
      emit("change", e.target.value);
    }
    function onFinishEditing(e) {
      e !== void 0 && stop(e);
      clearTimeout(emitTimer);
      emitValueFn !== void 0 && emitValueFn();
      typedNumber = false;
      stopValueWatcher = false;
      delete temp.value;
      props.type !== "file" && setTimeout(() => {
        if (inputRef.value !== null) {
          inputRef.value.value = innerValue.value !== void 0 ? innerValue.value : "";
        }
      });
    }
    function getCurValue() {
      return temp.hasOwnProperty("value") === true ? temp.value : innerValue.value !== void 0 ? innerValue.value : "";
    }
    onBeforeUnmount(() => {
      onFinishEditing();
    });
    onMounted(() => {
      props.autogrow === true && adjustHeight();
    });
    Object.assign(state, {
      innerValue,
      fieldClass: computed(
        () => `q-${isTextarea.value === true ? "textarea" : "input"}` + (props.autogrow === true ? " q-textarea--autogrow" : "")
      ),
      hasShadow: computed(
        () => props.type !== "file" && typeof props.shadowText === "string" && props.shadowText.length > 0
      ),
      inputRef,
      emitValue,
      hasValue,
      floatingLabel: computed(
        () => hasValue.value === true || fieldValueIsFilled(props.displayValue)
      ),
      getControl: () => {
        return h(isTextarea.value === true ? "textarea" : "input", {
          ref: inputRef,
          class: [
            "q-field__native q-placeholder",
            props.inputClass
          ],
          style: props.inputStyle,
          ...inputAttrs.value,
          ...onEvents.value,
          ...props.type !== "file" ? { value: getCurValue() } : formDomProps.value
        });
      },
      getShadowControl: () => {
        return h("div", {
          class: "q-field__native q-field__shadow absolute-bottom no-pointer-events" + (isTextarea.value === true ? "" : " text-no-wrap")
        }, [
          h("span", { class: "invisible" }, getCurValue()),
          h("span", props.shadowText)
        ]);
      }
    });
    const renderFn = useField(state);
    Object.assign(proxy, {
      focus,
      select,
      getNativeElement: () => inputRef.value
    });
    injectProp(proxy, "nativeEl", () => inputRef.value);
    return renderFn;
  }
});
function useRefocusTarget(props, rootRef) {
  const refocusRef = ref(null);
  const refocusTargetEl = computed(() => {
    if (props.disable === true) {
      return null;
    }
    return h("span", {
      ref: refocusRef,
      class: "no-outline",
      tabindex: -1
    });
  });
  function refocusTarget(e) {
    const root = rootRef.value;
    if (e !== void 0 && e.type.indexOf("key") === 0) {
      if (root !== null && document.activeElement !== root && root.contains(document.activeElement) === true) {
        root.focus();
      }
    } else if (refocusRef.value !== null && (e === void 0 || root !== null && root.contains(e.target) === true)) {
      refocusRef.value.focus();
    }
  }
  return {
    refocusTargetEl,
    refocusTarget
  };
}
const optionSizes = {
  xs: 30,
  sm: 35,
  md: 40,
  lg: 50,
  xl: 60
};
const svg = h("svg", {
  key: "svg",
  class: "q-radio__bg absolute non-selectable",
  viewBox: "0 0 24 24"
}, [
  h("path", {
    d: "M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12"
  }),
  h("path", {
    class: "q-radio__check",
    d: "M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6"
  })
]);
const QRadio = createComponent({
  name: "QRadio",
  props: {
    ...useDarkProps,
    ...useSizeProps,
    ...useFormProps,
    modelValue: { required: true },
    val: { required: true },
    label: String,
    leftLabel: Boolean,
    checkedIcon: String,
    uncheckedIcon: String,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  emits: ["update:modelValue"],
  setup(props, { slots, emit }) {
    const { proxy } = getCurrentInstance();
    const isDark = useDark(props, proxy.$q);
    const sizeStyle = useSize(props, optionSizes);
    const rootRef = ref(null);
    const { refocusTargetEl, refocusTarget } = useRefocusTarget(props, rootRef);
    const isTrue = computed(() => toRaw(props.modelValue) === toRaw(props.val));
    const classes = computed(
      () => "q-radio cursor-pointer no-outline row inline no-wrap items-center" + (props.disable === true ? " disabled" : "") + (isDark.value === true ? " q-radio--dark" : "") + (props.dense === true ? " q-radio--dense" : "") + (props.leftLabel === true ? " reverse" : "")
    );
    const innerClass = computed(() => {
      const color = props.color !== void 0 && (props.keepColor === true || isTrue.value === true) ? ` text-${props.color}` : "";
      return `q-radio__inner relative-position q-radio__inner--${isTrue.value === true ? "truthy" : "falsy"}${color}`;
    });
    const icon = computed(
      () => (isTrue.value === true ? props.checkedIcon : props.uncheckedIcon) || null
    );
    const tabindex = computed(() => props.disable === true ? -1 : props.tabindex || 0);
    const formAttrs = computed(() => {
      const prop = { type: "radio" };
      props.name !== void 0 && Object.assign(prop, {
        "^checked": isTrue.value === true ? "checked" : void 0,
        name: props.name,
        value: props.val
      });
      return prop;
    });
    const injectFormInput = useFormInject(formAttrs);
    function onClick(e) {
      if (e !== void 0) {
        stopAndPrevent(e);
        refocusTarget(e);
      }
      if (props.disable !== true && isTrue.value !== true) {
        emit("update:modelValue", props.val, e);
      }
    }
    function onKeydown2(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        stopAndPrevent(e);
      }
    }
    function onKeyup2(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        onClick(e);
      }
    }
    Object.assign(proxy, { set: onClick });
    return () => {
      const content = icon.value !== null ? [
        h("div", {
          key: "icon",
          class: "q-radio__icon-container absolute-full flex flex-center no-wrap"
        }, [
          h(QIcon, {
            class: "q-radio__icon",
            name: icon.value
          })
        ])
      ] : [svg];
      props.disable !== true && injectFormInput(
        content,
        "unshift",
        " q-radio__native q-ma-none q-pa-none"
      );
      const child = [
        h("div", {
          class: innerClass.value,
          style: sizeStyle.value,
          "aria-hidden": "true"
        }, content)
      ];
      if (refocusTargetEl.value !== null) {
        child.push(refocusTargetEl.value);
      }
      const label = props.label !== void 0 ? hMergeSlot(slots.default, [props.label]) : hSlot(slots.default);
      label !== void 0 && child.push(
        h("div", {
          class: "q-radio__label q-anchor--skip"
        }, label)
      );
      return h("div", {
        ref: rootRef,
        class: classes.value,
        tabindex: tabindex.value,
        role: "radio",
        "aria-label": props.label,
        "aria-checked": isTrue.value === true ? "true" : "false",
        "aria-disabled": props.disable === true ? "true" : void 0,
        onClick,
        onKeydown: onKeydown2,
        onKeyup: onKeyup2
      }, child);
    };
  }
});
const useCheckboxProps = {
  ...useDarkProps,
  ...useSizeProps,
  ...useFormProps,
  modelValue: {
    required: true,
    default: null
  },
  val: {},
  trueValue: { default: true },
  falseValue: { default: false },
  indeterminateValue: { default: null },
  checkedIcon: String,
  uncheckedIcon: String,
  indeterminateIcon: String,
  toggleOrder: {
    type: String,
    validator: (v2) => v2 === "tf" || v2 === "ft"
  },
  toggleIndeterminate: Boolean,
  label: String,
  leftLabel: Boolean,
  color: String,
  keepColor: Boolean,
  dense: Boolean,
  disable: Boolean,
  tabindex: [String, Number]
};
const useCheckboxEmits = ["update:modelValue"];
function useCheckbox(type, getInner) {
  const { props, slots, emit, proxy } = getCurrentInstance();
  const { $q } = proxy;
  const isDark = useDark(props, $q);
  const rootRef = ref(null);
  const { refocusTargetEl, refocusTarget } = useRefocusTarget(props, rootRef);
  const sizeStyle = useSize(props, optionSizes);
  const modelIsArray = computed(
    () => props.val !== void 0 && Array.isArray(props.modelValue)
  );
  const index2 = computed(() => {
    const val = toRaw(props.val);
    return modelIsArray.value === true ? props.modelValue.findIndex((opt) => toRaw(opt) === val) : -1;
  });
  const isTrue = computed(() => modelIsArray.value === true ? index2.value > -1 : toRaw(props.modelValue) === toRaw(props.trueValue));
  const isFalse = computed(() => modelIsArray.value === true ? index2.value === -1 : toRaw(props.modelValue) === toRaw(props.falseValue));
  const isIndeterminate = computed(
    () => isTrue.value === false && isFalse.value === false
  );
  const tabindex = computed(() => props.disable === true ? -1 : props.tabindex || 0);
  const classes = computed(
    () => `q-${type} cursor-pointer no-outline row inline no-wrap items-center` + (props.disable === true ? " disabled" : "") + (isDark.value === true ? ` q-${type}--dark` : "") + (props.dense === true ? ` q-${type}--dense` : "") + (props.leftLabel === true ? " reverse" : "")
  );
  const innerClass = computed(() => {
    const state = isTrue.value === true ? "truthy" : isFalse.value === true ? "falsy" : "indet";
    const color = props.color !== void 0 && (props.keepColor === true || (type === "toggle" ? isTrue.value === true : isFalse.value !== true)) ? ` text-${props.color}` : "";
    return `q-${type}__inner relative-position non-selectable q-${type}__inner--${state}${color}`;
  });
  const formAttrs = computed(() => {
    const prop = { type: "checkbox" };
    props.name !== void 0 && Object.assign(prop, {
      "^checked": isTrue.value === true ? "checked" : void 0,
      name: props.name,
      value: modelIsArray.value === true ? props.val : props.trueValue
    });
    return prop;
  });
  const injectFormInput = useFormInject(formAttrs);
  const attributes = computed(() => {
    const attrs = {
      tabindex: tabindex.value,
      role: type === "toggle" ? "switch" : "checkbox",
      "aria-label": props.label,
      "aria-checked": isIndeterminate.value === true ? "mixed" : isTrue.value === true ? "true" : "false"
    };
    if (props.disable === true) {
      attrs["aria-disabled"] = "true";
    }
    return attrs;
  });
  function onClick(e) {
    if (e !== void 0) {
      stopAndPrevent(e);
      refocusTarget(e);
    }
    if (props.disable !== true) {
      emit("update:modelValue", getNextValue(), e);
    }
  }
  function getNextValue() {
    if (modelIsArray.value === true) {
      if (isTrue.value === true) {
        const val = props.modelValue.slice();
        val.splice(index2.value, 1);
        return val;
      }
      return props.modelValue.concat([props.val]);
    }
    if (isTrue.value === true) {
      if (props.toggleOrder !== "ft" || props.toggleIndeterminate === false) {
        return props.falseValue;
      }
    } else if (isFalse.value === true) {
      if (props.toggleOrder === "ft" || props.toggleIndeterminate === false) {
        return props.trueValue;
      }
    } else {
      return props.toggleOrder !== "ft" ? props.trueValue : props.falseValue;
    }
    return props.indeterminateValue;
  }
  function onKeydown2(e) {
    if (e.keyCode === 13 || e.keyCode === 32) {
      stopAndPrevent(e);
    }
  }
  function onKeyup2(e) {
    if (e.keyCode === 13 || e.keyCode === 32) {
      onClick(e);
    }
  }
  const getInnerContent = getInner(isTrue, isIndeterminate);
  Object.assign(proxy, { toggle: onClick });
  return () => {
    const inner = getInnerContent();
    props.disable !== true && injectFormInput(
      inner,
      "unshift",
      ` q-${type}__native absolute q-ma-none q-pa-none`
    );
    const child = [
      h("div", {
        class: innerClass.value,
        style: sizeStyle.value,
        "aria-hidden": "true"
      }, inner)
    ];
    if (refocusTargetEl.value !== null) {
      child.push(refocusTargetEl.value);
    }
    const label = props.label !== void 0 ? hMergeSlot(slots.default, [props.label]) : hSlot(slots.default);
    label !== void 0 && child.push(
      h("div", {
        class: `q-${type}__label q-anchor--skip`
      }, label)
    );
    return h("div", {
      ref: rootRef,
      class: classes.value,
      ...attributes.value,
      onClick,
      onKeydown: onKeydown2,
      onKeyup: onKeyup2
    }, child);
  };
}
const bgNode = h("div", {
  key: "svg",
  class: "q-checkbox__bg absolute"
}, [
  h("svg", {
    class: "q-checkbox__svg fit absolute-full",
    viewBox: "0 0 24 24"
  }, [
    h("path", {
      class: "q-checkbox__truthy",
      fill: "none",
      d: "M1.73,12.91 8.1,19.28 22.79,4.59"
    }),
    h("path", {
      class: "q-checkbox__indet",
      d: "M4,14H20V10H4"
    })
  ])
]);
const QCheckbox = createComponent({
  name: "QCheckbox",
  props: useCheckboxProps,
  emits: useCheckboxEmits,
  setup(props) {
    function getInner(isTrue, isIndeterminate) {
      const icon = computed(
        () => (isTrue.value === true ? props.checkedIcon : isIndeterminate.value === true ? props.indeterminateIcon : props.uncheckedIcon) || null
      );
      return () => icon.value !== null ? [
        h("div", {
          key: "icon",
          class: "q-checkbox__icon-container absolute-full flex flex-center no-wrap"
        }, [
          h(QIcon, {
            class: "q-checkbox__icon",
            name: icon.value
          })
        ])
      ] : [bgNode];
    }
    return useCheckbox("checkbox", getInner);
  }
});
const QToggle = createComponent({
  name: "QToggle",
  props: {
    ...useCheckboxProps,
    icon: String,
    iconColor: String
  },
  emits: useCheckboxEmits,
  setup(props) {
    function getInner(isTrue, isIndeterminate) {
      const icon = computed(
        () => (isTrue.value === true ? props.checkedIcon : isIndeterminate.value === true ? props.indeterminateIcon : props.uncheckedIcon) || props.icon
      );
      const color = computed(() => isTrue.value === true ? props.iconColor : null);
      return () => [
        h("div", { class: "q-toggle__track" }),
        h(
          "div",
          {
            class: "q-toggle__thumb absolute flex flex-center no-wrap"
          },
          icon.value !== void 0 ? [
            h(QIcon, {
              name: icon.value,
              color: color.value
            })
          ] : void 0
        )
      ];
    }
    return useCheckbox("toggle", getInner);
  }
});
const components = {
  radio: QRadio,
  checkbox: QCheckbox,
  toggle: QToggle
};
const typeValues = Object.keys(components);
const QOptionGroup = createComponent({
  name: "QOptionGroup",
  props: {
    ...useDarkProps,
    modelValue: {
      required: true
    },
    options: {
      type: Array,
      validator: (opts) => opts.every((opt) => "value" in opt && "label" in opt)
    },
    name: String,
    type: {
      default: "radio",
      validator: (v2) => typeValues.includes(v2)
    },
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    size: String,
    leftLabel: Boolean,
    inline: Boolean,
    disable: Boolean
  },
  emits: ["update:modelValue"],
  setup(props, { emit, slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const arrayModel = Array.isArray(props.modelValue);
    if (props.type === "radio") {
      if (arrayModel === true) {
        console.error("q-option-group: model should not be array");
      }
    } else if (arrayModel === false) {
      console.error("q-option-group: model should be array in your case");
    }
    const isDark = useDark(props, $q);
    const component = computed(() => components[props.type]);
    const classes = computed(
      () => "q-option-group q-gutter-x-sm" + (props.inline === true ? " q-option-group--inline" : "")
    );
    const attrs = computed(() => {
      const attrs2 = { role: "group" };
      if (props.type === "radio") {
        attrs2.role = "radiogroup";
        if (props.disable === true) {
          attrs2["aria-disabled"] = "true";
        }
      }
      return attrs2;
    });
    function onUpdateModelValue(value2) {
      emit("update:modelValue", value2);
    }
    return () => h("div", {
      class: classes.value,
      ...attrs.value
    }, props.options.map((opt, i) => {
      const child = slots["label-" + i] !== void 0 ? () => slots["label-" + i](opt) : slots.label !== void 0 ? () => slots.label(opt) : void 0;
      return h("div", [
        h(component.value, {
          modelValue: props.modelValue,
          val: opt.value,
          name: opt.name === void 0 ? props.name : opt.name,
          disable: props.disable || opt.disable,
          label: child === void 0 ? opt.label : null,
          leftLabel: opt.leftLabel === void 0 ? props.leftLabel : opt.leftLabel,
          color: opt.color === void 0 ? props.color : opt.color,
          checkedIcon: opt.checkedIcon,
          uncheckedIcon: opt.uncheckedIcon,
          dark: opt.dark || isDark.value,
          size: opt.size === void 0 ? props.size : opt.size,
          dense: props.dense,
          keepColor: opt.keepColor === void 0 ? props.keepColor : opt.keepColor,
          "onUpdate:modelValue": onUpdateModelValue
        }, child)
      ]);
    }));
  }
});
function isDeepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (a !== null && b !== null && typeof a === "object" && typeof b === "object") {
    if (a.constructor !== b.constructor) {
      return false;
    }
    let length, i;
    if (a.constructor === Array) {
      length = a.length;
      if (length !== b.length) {
        return false;
      }
      for (i = length; i-- !== 0; ) {
        if (isDeepEqual(a[i], b[i]) !== true) {
          return false;
        }
      }
      return true;
    }
    if (a.constructor === Map) {
      if (a.size !== b.size) {
        return false;
      }
      i = a.entries().next();
      while (i.done !== true) {
        if (b.has(i.value[0]) !== true) {
          return false;
        }
        i = i.next();
      }
      i = a.entries().next();
      while (i.done !== true) {
        if (isDeepEqual(i.value[1], b.get(i.value[0])) !== true) {
          return false;
        }
        i = i.next();
      }
      return true;
    }
    if (a.constructor === Set) {
      if (a.size !== b.size) {
        return false;
      }
      i = a.entries().next();
      while (i.done !== true) {
        if (b.has(i.value[0]) !== true) {
          return false;
        }
        i = i.next();
      }
      return true;
    }
    if (a.buffer != null && a.buffer.constructor === ArrayBuffer) {
      length = a.length;
      if (length !== b.length) {
        return false;
      }
      for (i = length; i-- !== 0; ) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    if (a.constructor === RegExp) {
      return a.source === b.source && a.flags === b.flags;
    }
    if (a.valueOf !== Object.prototype.valueOf) {
      return a.valueOf() === b.valueOf();
    }
    if (a.toString !== Object.prototype.toString) {
      return a.toString() === b.toString();
    }
    const keys = Object.keys(a).filter((key) => a[key] !== void 0);
    length = keys.length;
    if (length !== Object.keys(b).filter((key) => b[key] !== void 0).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (isDeepEqual(a[key], b[key]) !== true) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function isObject(v2) {
  return v2 !== null && typeof v2 === "object" && Array.isArray(v2) !== true;
}
const DialogPlugin = createComponent({
  name: "DialogPlugin",
  props: {
    ...useDarkProps,
    title: String,
    message: String,
    prompt: Object,
    options: Object,
    progress: [Boolean, Object],
    html: Boolean,
    ok: {
      type: [String, Object, Boolean],
      default: true
    },
    cancel: [String, Object, Boolean],
    focus: {
      type: String,
      default: "ok",
      validator: (v2) => ["ok", "cancel", "none"].includes(v2)
    },
    stackButtons: Boolean,
    color: String,
    cardClass: [String, Array, Object],
    cardStyle: [String, Array, Object]
  },
  emits: ["ok", "hide"],
  setup(props, { emit }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const isDark = useDark(props, $q);
    const dialogRef = ref(null);
    const model = ref(
      props.prompt !== void 0 ? props.prompt.model : props.options !== void 0 ? props.options.model : void 0
    );
    const classes = computed(
      () => "q-dialog-plugin" + (isDark.value === true ? " q-dialog-plugin--dark q-dark" : "") + (props.progress !== false ? " q-dialog-plugin--progress" : "")
    );
    const vmColor = computed(
      () => props.color || (isDark.value === true ? "amber" : "primary")
    );
    const spinner = computed(() => props.progress === false ? null : isObject(props.progress) === true ? {
      component: props.progress.spinner || QSpinner,
      props: { color: props.progress.color || vmColor.value }
    } : {
      component: QSpinner,
      props: { color: vmColor.value }
    });
    const hasForm = computed(
      () => props.prompt !== void 0 || props.options !== void 0
    );
    const formProps = computed(() => {
      if (hasForm.value !== true) {
        return {};
      }
      const { model: model2, isValid, items, ...formProps2 } = props.prompt !== void 0 ? props.prompt : props.options;
      return formProps2;
    });
    const okLabel = computed(() => isObject(props.ok) === true ? $q.lang.label.ok : props.ok === true ? $q.lang.label.ok : props.ok);
    const cancelLabel = computed(() => isObject(props.cancel) === true ? $q.lang.label.cancel : props.cancel === true ? $q.lang.label.cancel : props.cancel);
    const okDisabled = computed(() => {
      if (props.prompt !== void 0) {
        return props.prompt.isValid !== void 0 && props.prompt.isValid(model.value) !== true;
      }
      if (props.options !== void 0) {
        return props.options.isValid !== void 0 && props.options.isValid(model.value) !== true;
      }
      return false;
    });
    const okProps = computed(() => ({
      color: vmColor.value,
      label: okLabel.value,
      ripple: false,
      disable: okDisabled.value,
      ...isObject(props.ok) === true ? props.ok : { flat: true },
      "data-autofocus": props.focus === "ok" && hasForm.value !== true || void 0,
      onClick: onOk
    }));
    const cancelProps = computed(() => ({
      color: vmColor.value,
      label: cancelLabel.value,
      ripple: false,
      ...isObject(props.cancel) === true ? props.cancel : { flat: true },
      "data-autofocus": props.focus === "cancel" && hasForm.value !== true || void 0,
      onClick: onCancel
    }));
    watch(() => props.prompt && props.prompt.model, onUpdateModel);
    watch(() => props.options && props.options.model, onUpdateModel);
    function show() {
      dialogRef.value.show();
    }
    function hide() {
      dialogRef.value.hide();
    }
    function onOk() {
      emit("ok", toRaw(model.value));
      hide();
    }
    function onCancel() {
      hide();
    }
    function onDialogHide() {
      emit("hide");
    }
    function onUpdateModel(val) {
      model.value = val;
    }
    function onInputKeyup(evt) {
      if (okDisabled.value !== true && props.prompt.type !== "textarea" && isKeyCode(evt, 13) === true) {
        onOk();
      }
    }
    function getSection(classes2, text) {
      return props.html === true ? h(QCardSection, {
        class: classes2,
        innerHTML: text
      }) : h(QCardSection, { class: classes2 }, () => text);
    }
    function getPrompt() {
      return [
        h(QInput, {
          color: vmColor.value,
          dense: true,
          autofocus: true,
          dark: isDark.value,
          ...formProps.value,
          modelValue: model.value,
          "onUpdate:modelValue": onUpdateModel,
          onKeyup: onInputKeyup
        })
      ];
    }
    function getOptions() {
      return [
        h(QOptionGroup, {
          color: vmColor.value,
          options: props.options.items,
          dark: isDark.value,
          ...formProps.value,
          modelValue: model.value,
          "onUpdate:modelValue": onUpdateModel
        })
      ];
    }
    function getButtons() {
      const child = [];
      props.cancel && child.push(
        h(QBtn, cancelProps.value)
      );
      props.ok && child.push(
        h(QBtn, okProps.value)
      );
      return h(QCardActions, {
        class: props.stackButtons === true ? "items-end" : "",
        vertical: props.stackButtons,
        align: "right"
      }, () => child);
    }
    function getCardContent() {
      const child = [];
      props.title && child.push(
        getSection("q-dialog__title", props.title)
      );
      props.progress !== false && child.push(
        h(
          QCardSection,
          { class: "q-dialog__progress" },
          () => h(spinner.value.component, spinner.value.props)
        )
      );
      props.message && child.push(
        getSection("q-dialog__message", props.message)
      );
      if (props.prompt !== void 0) {
        child.push(
          h(
            QCardSection,
            { class: "scroll q-dialog-plugin__form" },
            getPrompt
          )
        );
      } else if (props.options !== void 0) {
        child.push(
          h(QSeparator, { dark: isDark.value }),
          h(
            QCardSection,
            { class: "scroll q-dialog-plugin__form" },
            getOptions
          ),
          h(QSeparator, { dark: isDark.value })
        );
      }
      if (props.ok || props.cancel) {
        child.push(getButtons());
      }
      return child;
    }
    function getContent() {
      return [
        h(QCard, {
          class: [
            classes.value,
            props.cardClass
          ],
          style: props.cardStyle,
          dark: isDark.value
        }, getCardContent)
      ];
    }
    Object.assign(proxy, { show, hide });
    return () => h(QDialog, {
      ref: dialogRef,
      onHide: onDialogHide
    }, getContent);
  }
});
const defineReactivePlugin = (state, plugin) => {
  const reactiveState = reactive(state);
  for (const name in state) {
    injectProp(
      plugin,
      name,
      () => reactiveState[name],
      (val) => {
        reactiveState[name] = val;
      }
    );
  }
  return plugin;
};
const SIZE_LIST = ["sm", "md", "lg", "xl"];
const { passive } = listenOpts;
const Screen = defineReactivePlugin({
  width: 0,
  height: 0,
  name: "xs",
  sizes: {
    sm: 600,
    md: 1024,
    lg: 1440,
    xl: 1920
  },
  lt: {
    sm: true,
    md: true,
    lg: true,
    xl: true
  },
  gt: {
    xs: false,
    sm: false,
    md: false,
    lg: false
  },
  xs: true,
  sm: false,
  md: false,
  lg: false,
  xl: false
}, {
  setSizes: noop,
  setDebounce: noop,
  install({ $q, onSSRHydrated }) {
    $q.screen = this;
    if (this.__installed === true) {
      if ($q.config.screen !== void 0) {
        if ($q.config.screen.bodyClasses === false) {
          document.body.classList.remove(`screen--${this.name}`);
        } else {
          this.__update(true);
        }
      }
      return;
    }
    const { visualViewport } = window;
    const target2 = visualViewport || window;
    const scrollingElement = document.scrollingElement || document.documentElement;
    const getSize = visualViewport === void 0 || client.is.mobile === true ? () => [
      Math.max(window.innerWidth, scrollingElement.clientWidth),
      Math.max(window.innerHeight, scrollingElement.clientHeight)
    ] : () => [
      visualViewport.width * visualViewport.scale + window.innerWidth - scrollingElement.clientWidth,
      visualViewport.height * visualViewport.scale + window.innerHeight - scrollingElement.clientHeight
    ];
    const classes = $q.config.screen !== void 0 && $q.config.screen.bodyClasses === true;
    this.__update = (force) => {
      const [w, h2] = getSize();
      if (h2 !== this.height) {
        this.height = h2;
      }
      if (w !== this.width) {
        this.width = w;
      } else if (force !== true) {
        return;
      }
      let s = this.sizes;
      this.gt.xs = w >= s.sm;
      this.gt.sm = w >= s.md;
      this.gt.md = w >= s.lg;
      this.gt.lg = w >= s.xl;
      this.lt.sm = w < s.sm;
      this.lt.md = w < s.md;
      this.lt.lg = w < s.lg;
      this.lt.xl = w < s.xl;
      this.xs = this.lt.sm;
      this.sm = this.gt.xs === true && this.lt.md === true;
      this.md = this.gt.sm === true && this.lt.lg === true;
      this.lg = this.gt.md === true && this.lt.xl === true;
      this.xl = this.gt.lg;
      s = this.xs === true && "xs" || this.sm === true && "sm" || this.md === true && "md" || this.lg === true && "lg" || "xl";
      if (s !== this.name) {
        if (classes === true) {
          document.body.classList.remove(`screen--${this.name}`);
          document.body.classList.add(`screen--${s}`);
        }
        this.name = s;
      }
    };
    let updateEvt, updateSizes = {}, updateDebounce = 16;
    this.setSizes = (sizes) => {
      SIZE_LIST.forEach((name) => {
        if (sizes[name] !== void 0) {
          updateSizes[name] = sizes[name];
        }
      });
    };
    this.setDebounce = (deb) => {
      updateDebounce = deb;
    };
    const start = () => {
      const style = getComputedStyle(document.body);
      if (style.getPropertyValue("--q-size-sm")) {
        SIZE_LIST.forEach((name) => {
          this.sizes[name] = parseInt(style.getPropertyValue(`--q-size-${name}`), 10);
        });
      }
      this.setSizes = (sizes) => {
        SIZE_LIST.forEach((name) => {
          if (sizes[name]) {
            this.sizes[name] = sizes[name];
          }
        });
        this.__update(true);
      };
      this.setDebounce = (delay) => {
        updateEvt !== void 0 && target2.removeEventListener("resize", updateEvt, passive);
        updateEvt = delay > 0 ? debounce(this.__update, delay) : this.__update;
        target2.addEventListener("resize", updateEvt, passive);
      };
      this.setDebounce(updateDebounce);
      if (Object.keys(updateSizes).length > 0) {
        this.setSizes(updateSizes);
        updateSizes = void 0;
      } else {
        this.__update();
      }
      classes === true && this.name === "xs" && document.body.classList.add("screen--xs");
    };
    if (isRuntimeSsrPreHydration.value === true) {
      onSSRHydrated.push(start);
    } else {
      start();
    }
  }
});
const Plugin$2 = defineReactivePlugin({
  isActive: false,
  mode: false
}, {
  __media: void 0,
  set(val) {
    Plugin$2.mode = val;
    if (val === "auto") {
      if (Plugin$2.__media === void 0) {
        Plugin$2.__media = window.matchMedia("(prefers-color-scheme: dark)");
        Plugin$2.__updateMedia = () => {
          Plugin$2.set("auto");
        };
        Plugin$2.__media.addListener(Plugin$2.__updateMedia);
      }
      val = Plugin$2.__media.matches;
    } else if (Plugin$2.__media !== void 0) {
      Plugin$2.__media.removeListener(Plugin$2.__updateMedia);
      Plugin$2.__media = void 0;
    }
    Plugin$2.isActive = val === true;
    document.body.classList.remove(`body--${val === true ? "light" : "dark"}`);
    document.body.classList.add(`body--${val === true ? "dark" : "light"}`);
  },
  toggle() {
    {
      Plugin$2.set(Plugin$2.isActive === false);
    }
  },
  install({ $q, onSSRHydrated, ssrContext }) {
    const { dark } = $q.config;
    $q.dark = this;
    if (this.__installed === true && dark === void 0) {
      return;
    }
    this.isActive = dark === true;
    const initialVal = dark !== void 0 ? dark : false;
    if (isRuntimeSsrPreHydration.value === true) {
      const ssrSet = (val) => {
        this.__fromSSR = val;
      };
      const originalSet = this.set;
      this.set = ssrSet;
      ssrSet(initialVal);
      onSSRHydrated.push(() => {
        this.set = originalSet;
        this.set(this.__fromSSR);
      });
    } else {
      this.set(initialVal);
    }
  }
});
const defaultLang = {
  isoName: "en-US",
  nativeName: "English (US)",
  label: {
    clear: "Clear",
    ok: "OK",
    cancel: "Cancel",
    close: "Close",
    set: "Set",
    select: "Select",
    reset: "Reset",
    remove: "Remove",
    update: "Update",
    create: "Create",
    search: "Search",
    filter: "Filter",
    refresh: "Refresh",
    expand: (label) => label ? `Expand "${label}"` : "Expand",
    collapse: (label) => label ? `Collapse "${label}"` : "Collapse"
  },
  date: {
    days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    firstDayOfWeek: 0,
    format24h: false,
    pluralDay: "days"
  },
  table: {
    noData: "No data available",
    noResults: "No matching records found",
    loading: "Loading...",
    selectedRecords: (rows) => rows === 1 ? "1 record selected." : (rows === 0 ? "No" : rows) + " records selected.",
    recordsPerPage: "Records per page:",
    allRows: "All",
    pagination: (start, end, total) => start + "-" + end + " of " + total,
    columns: "Columns"
  },
  editor: {
    url: "URL",
    bold: "Bold",
    italic: "Italic",
    strikethrough: "Strikethrough",
    underline: "Underline",
    unorderedList: "Unordered List",
    orderedList: "Ordered List",
    subscript: "Subscript",
    superscript: "Superscript",
    hyperlink: "Hyperlink",
    toggleFullscreen: "Toggle Fullscreen",
    quote: "Quote",
    left: "Left align",
    center: "Center align",
    right: "Right align",
    justify: "Justify align",
    print: "Print",
    outdent: "Decrease indentation",
    indent: "Increase indentation",
    removeFormat: "Remove formatting",
    formatting: "Formatting",
    fontSize: "Font Size",
    align: "Align",
    hr: "Insert Horizontal Rule",
    undo: "Undo",
    redo: "Redo",
    heading1: "Heading 1",
    heading2: "Heading 2",
    heading3: "Heading 3",
    heading4: "Heading 4",
    heading5: "Heading 5",
    heading6: "Heading 6",
    paragraph: "Paragraph",
    code: "Code",
    size1: "Very small",
    size2: "A bit small",
    size3: "Normal",
    size4: "Medium-large",
    size5: "Big",
    size6: "Very big",
    size7: "Maximum",
    defaultFont: "Default Font",
    viewSource: "View Source"
  },
  tree: {
    noNodes: "No nodes available",
    noResults: "No matching nodes found"
  }
};
function getLocale() {
  const val = Array.isArray(navigator.languages) === true && navigator.languages.length > 0 ? navigator.languages[0] : navigator.language;
  if (typeof val === "string") {
    return val.split(/[-_]/).map((v2, i) => i === 0 ? v2.toLowerCase() : i > 1 || v2.length < 4 ? v2.toUpperCase() : v2[0].toUpperCase() + v2.slice(1).toLowerCase()).join("-");
  }
}
const Plugin$1 = defineReactivePlugin({
  __langPack: {}
}, {
  getLocale,
  set(langObject = defaultLang, ssrContext) {
    const lang = {
      ...langObject,
      rtl: langObject.rtl === true,
      getLocale
    };
    {
      const el = document.documentElement;
      el.setAttribute("dir", lang.rtl === true ? "rtl" : "ltr");
      el.setAttribute("lang", lang.isoName);
      lang.set = Plugin$1.set;
      Object.assign(Plugin$1.__langPack, lang);
      Plugin$1.props = lang;
      Plugin$1.isoName = lang.isoName;
      Plugin$1.nativeName = lang.nativeName;
    }
  },
  install({ $q, lang, ssrContext }) {
    {
      $q.lang = Plugin$1.__langPack;
      if (this.__installed === true) {
        lang !== void 0 && this.set(lang);
      } else {
        this.set(lang || defaultLang);
      }
    }
  }
});
function setCssVar(propName, value2, element = document.body) {
  if (typeof propName !== "string") {
    throw new TypeError("Expected a string as propName");
  }
  if (typeof value2 !== "string") {
    throw new TypeError("Expected a string as value");
  }
  if (!(element instanceof Element)) {
    throw new TypeError("Expected a DOM element");
  }
  element.style.setProperty(`--q-${propName}`, value2);
}
function getMobilePlatform(is2) {
  if (is2.ios === true)
    return "ios";
  if (is2.android === true)
    return "android";
}
function getBodyClasses({ is: is2, has: has2, within }, cfg) {
  const cls = [
    is2.desktop === true ? "desktop" : "mobile",
    `${has2.touch === false ? "no-" : ""}touch`
  ];
  if (is2.mobile === true) {
    const mobile = getMobilePlatform(is2);
    mobile !== void 0 && cls.push("platform-" + mobile);
  }
  if (is2.nativeMobile === true) {
    const type = is2.nativeMobileWrapper;
    cls.push(type);
    cls.push("native-mobile");
    if (is2.ios === true && (cfg[type] === void 0 || cfg[type].iosStatusBarPadding !== false)) {
      cls.push("q-ios-padding");
    }
  } else if (is2.electron === true) {
    cls.push("electron");
  } else if (is2.bex === true) {
    cls.push("bex");
  }
  within.iframe === true && cls.push("within-iframe");
  return cls;
}
function applyClientSsrCorrections() {
  const classes = document.body.className;
  let newCls = classes;
  if (iosCorrection !== void 0) {
    newCls = newCls.replace("desktop", "platform-ios mobile");
  }
  if (client.has.touch === true) {
    newCls = newCls.replace("no-touch", "touch");
  }
  if (client.within.iframe === true) {
    newCls += " within-iframe";
  }
  if (classes !== newCls) {
    document.body.className = newCls;
  }
}
function setColors(brand) {
  for (const color in brand) {
    setCssVar(color, brand[color]);
  }
}
const Body = {
  install(opts) {
    if (this.__installed === true) {
      return;
    }
    if (isRuntimeSsrPreHydration.value === true) {
      applyClientSsrCorrections();
    } else {
      const { $q } = opts;
      $q.config.brand !== void 0 && setColors($q.config.brand);
      const cls = getBodyClasses(client, $q.config);
      document.body.classList.add.apply(document.body.classList, cls);
    }
    if (client.is.ios === true) {
      document.body.addEventListener("touchstart", noop);
    }
    window.addEventListener("keydown", onKeyDownComposition, true);
  }
};
const materialIcons = {
  name: "material-icons",
  type: {
    positive: "check_circle",
    negative: "warning",
    info: "info",
    warning: "priority_high"
  },
  arrow: {
    up: "arrow_upward",
    right: "arrow_forward",
    down: "arrow_downward",
    left: "arrow_back",
    dropdown: "arrow_drop_down"
  },
  chevron: {
    left: "chevron_left",
    right: "chevron_right"
  },
  colorPicker: {
    spectrum: "gradient",
    tune: "tune",
    palette: "style"
  },
  pullToRefresh: {
    icon: "refresh"
  },
  carousel: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down",
    navigationIcon: "lens"
  },
  chip: {
    remove: "cancel",
    selected: "check"
  },
  datetime: {
    arrowLeft: "chevron_left",
    arrowRight: "chevron_right",
    now: "access_time",
    today: "today"
  },
  editor: {
    bold: "format_bold",
    italic: "format_italic",
    strikethrough: "strikethrough_s",
    underline: "format_underlined",
    unorderedList: "format_list_bulleted",
    orderedList: "format_list_numbered",
    subscript: "vertical_align_bottom",
    superscript: "vertical_align_top",
    hyperlink: "link",
    toggleFullscreen: "fullscreen",
    quote: "format_quote",
    left: "format_align_left",
    center: "format_align_center",
    right: "format_align_right",
    justify: "format_align_justify",
    print: "print",
    outdent: "format_indent_decrease",
    indent: "format_indent_increase",
    removeFormat: "format_clear",
    formatting: "text_format",
    fontSize: "format_size",
    align: "format_align_left",
    hr: "remove",
    undo: "undo",
    redo: "redo",
    heading: "format_size",
    code: "code",
    size: "format_size",
    font: "font_download",
    viewSource: "code"
  },
  expansionItem: {
    icon: "keyboard_arrow_down",
    denseIcon: "arrow_drop_down"
  },
  fab: {
    icon: "add",
    activeIcon: "close"
  },
  field: {
    clear: "cancel",
    error: "error"
  },
  pagination: {
    first: "first_page",
    prev: "keyboard_arrow_left",
    next: "keyboard_arrow_right",
    last: "last_page"
  },
  rating: {
    icon: "grade"
  },
  stepper: {
    done: "check",
    active: "edit",
    error: "warning"
  },
  tabs: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down"
  },
  table: {
    arrowUp: "arrow_upward",
    warning: "warning",
    firstPage: "first_page",
    prevPage: "chevron_left",
    nextPage: "chevron_right",
    lastPage: "last_page"
  },
  tree: {
    icon: "play_arrow"
  },
  uploader: {
    done: "done",
    clear: "clear",
    add: "add_box",
    upload: "cloud_upload",
    removeQueue: "clear_all",
    removeUploaded: "done_all"
  }
};
const Plugin = defineReactivePlugin({
  iconMapFn: null,
  __icons: {}
}, {
  set(setObject, ssrContext) {
    const def2 = { ...setObject, rtl: setObject.rtl === true };
    {
      def2.set = Plugin.set;
      Object.assign(Plugin.__icons, def2);
    }
  },
  install({ $q, iconSet, ssrContext }) {
    {
      if ($q.config.iconMapFn !== void 0) {
        this.iconMapFn = $q.config.iconMapFn;
      }
      $q.iconSet = this.__icons;
      injectProp($q, "iconMapFn", () => this.iconMapFn, (val) => {
        this.iconMapFn = val;
      });
      if (this.__installed === true) {
        iconSet !== void 0 && this.set(iconSet);
      } else {
        this.set(iconSet || materialIcons);
      }
    }
  }
});
const autoInstalledPlugins = [
  Platform,
  Body,
  Plugin$2,
  Screen,
  History,
  Plugin$1,
  Plugin
];
function createChildApp(appCfg, parentApp) {
  const app2 = createApp(appCfg);
  app2.config.globalProperties = parentApp.config.globalProperties;
  const { reload, ...appContext } = parentApp._context;
  Object.assign(app2._context, appContext);
  return app2;
}
function installPlugins(pluginOpts, pluginList) {
  pluginList.forEach((Plugin2) => {
    Plugin2.install(pluginOpts);
    Plugin2.__installed = true;
  });
}
function prepareApp(app2, uiOpts, pluginOpts) {
  app2.config.globalProperties.$q = pluginOpts.$q;
  app2.provide(quasarKey, pluginOpts.$q);
  installPlugins(pluginOpts, autoInstalledPlugins);
  uiOpts.components !== void 0 && Object.values(uiOpts.components).forEach((c) => {
    if (isObject(c) === true && c.name !== void 0) {
      app2.component(c.name, c);
    }
  });
  uiOpts.directives !== void 0 && Object.values(uiOpts.directives).forEach((d) => {
    if (isObject(d) === true && d.name !== void 0) {
      app2.directive(d.name, d);
    }
  });
  uiOpts.plugins !== void 0 && installPlugins(
    pluginOpts,
    Object.values(uiOpts.plugins).filter(
      (p2) => typeof p2.install === "function" && autoInstalledPlugins.includes(p2) === false
    )
  );
  if (isRuntimeSsrPreHydration.value === true) {
    pluginOpts.$q.onSSRHydrated = () => {
      pluginOpts.onSSRHydrated.forEach((fn) => {
        fn();
      });
      pluginOpts.$q.onSSRHydrated = () => {
      };
    };
  }
}
const installQuasar = function(parentApp, opts = {}) {
  const $q = { version: "2.10.2" };
  if (globalConfigIsFrozen === false) {
    if (opts.config !== void 0) {
      Object.assign(globalConfig, opts.config);
    }
    $q.config = { ...globalConfig };
    freezeGlobalConfig();
  } else {
    $q.config = opts.config || {};
  }
  prepareApp(parentApp, opts, {
    parentApp,
    $q,
    lang: opts.lang,
    iconSet: opts.iconSet,
    onSSRHydrated: []
  });
};
function merge(target2, source) {
  for (const key in source) {
    if (key !== "spinner" && Object(source[key]) === source[key]) {
      target2[key] = Object(target2[key]) !== target2[key] ? {} : { ...target2[key] };
      merge(target2[key], source[key]);
    } else {
      target2[key] = source[key];
    }
  }
}
function globalDialog(DefaultComponent, supportsCustomComponent, parentApp) {
  return (pluginProps) => {
    let DialogComponent, props;
    const isCustom = supportsCustomComponent === true && pluginProps.component !== void 0;
    if (isCustom === true) {
      const { component, componentProps } = pluginProps;
      DialogComponent = typeof component === "string" ? parentApp.component(component) : component;
      props = componentProps || {};
    } else {
      const { class: klass, style, ...otherProps } = pluginProps;
      DialogComponent = DefaultComponent;
      props = otherProps;
      klass !== void 0 && (otherProps.cardClass = klass);
      style !== void 0 && (otherProps.cardStyle = style);
    }
    let vm, emittedOK = false;
    const dialogRef = ref(null);
    const el = createGlobalNode();
    const applyState = (cmd) => {
      if (dialogRef.value !== null && dialogRef.value[cmd] !== void 0) {
        dialogRef.value[cmd]();
        return;
      }
      const target2 = vm.$.subTree;
      if (target2 && target2.component) {
        if (target2.component.proxy && target2.component.proxy[cmd]) {
          target2.component.proxy[cmd]();
          return;
        }
        if (target2.component.subTree && target2.component.subTree.component && target2.component.subTree.component.proxy && target2.component.subTree.component.proxy[cmd]) {
          target2.component.subTree.component.proxy[cmd]();
          return;
        }
      }
      console.error("[Quasar] Incorrectly defined Dialog component");
    };
    const okFns = [], cancelFns = [], API = {
      onOk(fn) {
        okFns.push(fn);
        return API;
      },
      onCancel(fn) {
        cancelFns.push(fn);
        return API;
      },
      onDismiss(fn) {
        okFns.push(fn);
        cancelFns.push(fn);
        return API;
      },
      hide() {
        applyState("hide");
        return API;
      },
      update(componentProps) {
        if (vm !== null) {
          if (isCustom === true) {
            Object.assign(props, componentProps);
          } else {
            const { class: klass, style, ...cfg } = componentProps;
            klass !== void 0 && (cfg.cardClass = klass);
            style !== void 0 && (cfg.cardStyle = style);
            merge(props, cfg);
          }
          vm.$forceUpdate();
        }
        return API;
      }
    };
    const onOk = (data) => {
      emittedOK = true;
      okFns.forEach((fn) => {
        fn(data);
      });
    };
    const onHide = () => {
      app2.unmount(el);
      removeGlobalNode(el);
      app2 = null;
      vm = null;
      if (emittedOK !== true) {
        cancelFns.forEach((fn) => {
          fn();
        });
      }
    };
    let app2 = createChildApp({
      name: "QGlobalDialog",
      setup: () => () => h(DialogComponent, {
        ...props,
        ref: dialogRef,
        onOk,
        onHide,
        onVnodeMounted(...args) {
          if (typeof props.onVnodeMounted === "function") {
            props.onVnodeMounted(...args);
          }
          nextTick(() => applyState("show"));
        }
      })
    }, parentApp);
    vm = app2.mount(el);
    return API;
  };
}
const Dialog = {
  install({ $q, parentApp }) {
    $q.dialog = globalDialog(DialogPlugin, true, parentApp);
    if (this.__installed !== true) {
      this.create = $q.dialog;
    }
  }
};
const QAvatar = createComponent({
  name: "QAvatar",
  props: {
    ...useSizeProps,
    fontSize: String,
    color: String,
    textColor: String,
    icon: String,
    square: Boolean,
    rounded: Boolean
  },
  setup(props, { slots }) {
    const sizeStyle = useSize(props);
    const classes = computed(
      () => "q-avatar" + (props.color ? ` bg-${props.color}` : "") + (props.textColor ? ` text-${props.textColor} q-chip--colored` : "") + (props.square === true ? " q-avatar--square" : props.rounded === true ? " rounded-borders" : "")
    );
    const contentStyle = computed(() => props.fontSize ? { fontSize: props.fontSize } : null);
    return () => {
      const icon = props.icon !== void 0 ? [h(QIcon, { name: props.icon })] : void 0;
      return h("div", {
        class: classes.value,
        style: sizeStyle.value
      }, [
        h("div", {
          class: "q-avatar__content row flex-center overflow-hidden",
          style: contentStyle.value
        }, hMergeSlotSafely(slots.default, icon))
      ]);
    };
  }
});
let uid$1 = 0;
const defaults$1 = {};
const groups = {};
const notificationsList = {};
const positionClass = {};
const emptyRE = /^\s*$/;
const notifRefs = [];
const positionList = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right",
  "top",
  "bottom",
  "left",
  "right",
  "center"
];
const badgePositions = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right"
];
const notifTypes = {
  positive: {
    icon: ($q) => $q.iconSet.type.positive,
    color: "positive"
  },
  negative: {
    icon: ($q) => $q.iconSet.type.negative,
    color: "negative"
  },
  warning: {
    icon: ($q) => $q.iconSet.type.warning,
    color: "warning",
    textColor: "dark"
  },
  info: {
    icon: ($q) => $q.iconSet.type.info,
    color: "info"
  },
  ongoing: {
    group: false,
    timeout: 0,
    spinner: true,
    color: "grey-8"
  }
};
function addNotification(config, $q, originalApi) {
  if (!config) {
    return logError("parameter required");
  }
  let Api;
  const notif = { textColor: "white" };
  if (config.ignoreDefaults !== true) {
    Object.assign(notif, defaults$1);
  }
  if (isObject(config) === false) {
    if (notif.type) {
      Object.assign(notif, notifTypes[notif.type]);
    }
    config = { message: config };
  }
  Object.assign(notif, notifTypes[config.type || notif.type], config);
  if (typeof notif.icon === "function") {
    notif.icon = notif.icon($q);
  }
  if (!notif.spinner) {
    notif.spinner = false;
  } else {
    if (notif.spinner === true) {
      notif.spinner = QSpinner;
    }
    notif.spinner = markRaw(notif.spinner);
  }
  notif.meta = {
    hasMedia: Boolean(notif.spinner !== false || notif.icon || notif.avatar),
    hasText: hasContent(notif.message) || hasContent(notif.caption)
  };
  if (notif.position) {
    if (positionList.includes(notif.position) === false) {
      return logError("wrong position", config);
    }
  } else {
    notif.position = "bottom";
  }
  if (notif.timeout === void 0) {
    notif.timeout = 5e3;
  } else {
    const t = parseInt(notif.timeout, 10);
    if (isNaN(t) || t < 0) {
      return logError("wrong timeout", config);
    }
    notif.timeout = t;
  }
  if (notif.timeout === 0) {
    notif.progress = false;
  } else if (notif.progress === true) {
    notif.meta.progressClass = "q-notification__progress" + (notif.progressClass ? ` ${notif.progressClass}` : "");
    notif.meta.progressStyle = {
      animationDuration: `${notif.timeout + 1e3}ms`
    };
  }
  const actions = (Array.isArray(config.actions) === true ? config.actions : []).concat(
    config.ignoreDefaults !== true && Array.isArray(defaults$1.actions) === true ? defaults$1.actions : []
  ).concat(
    notifTypes[config.type] !== void 0 && Array.isArray(notifTypes[config.type].actions) === true ? notifTypes[config.type].actions : []
  );
  const { closeBtn } = notif;
  closeBtn && actions.push({
    label: typeof closeBtn === "string" ? closeBtn : $q.lang.label.close
  });
  notif.actions = actions.map(({ handler, noDismiss, ...item }) => ({
    flat: true,
    ...item,
    onClick: typeof handler === "function" ? () => {
      handler();
      noDismiss !== true && dismiss();
    } : () => {
      dismiss();
    }
  }));
  if (notif.multiLine === void 0) {
    notif.multiLine = notif.actions.length > 1;
  }
  Object.assign(notif.meta, {
    class: `q-notification row items-stretch q-notification--${notif.multiLine === true ? "multi-line" : "standard"}` + (notif.color !== void 0 ? ` bg-${notif.color}` : "") + (notif.textColor !== void 0 ? ` text-${notif.textColor}` : "") + (notif.classes !== void 0 ? ` ${notif.classes}` : ""),
    wrapperClass: "q-notification__wrapper col relative-position border-radius-inherit " + (notif.multiLine === true ? "column no-wrap justify-center" : "row items-center"),
    contentClass: "q-notification__content row items-center" + (notif.multiLine === true ? "" : " col"),
    leftClass: notif.meta.hasText === true ? "additional" : "single",
    attrs: {
      role: "alert",
      ...notif.attrs
    }
  });
  if (notif.group === false) {
    notif.group = void 0;
    notif.meta.group = void 0;
  } else {
    if (notif.group === void 0 || notif.group === true) {
      notif.group = [
        notif.message,
        notif.caption,
        notif.multiline
      ].concat(
        notif.actions.map((props) => `${props.label}*${props.icon}`)
      ).join("|");
    }
    notif.meta.group = notif.group + "|" + notif.position;
  }
  if (notif.actions.length === 0) {
    notif.actions = void 0;
  } else {
    notif.meta.actionsClass = "q-notification__actions row items-center " + (notif.multiLine === true ? "justify-end" : "col-auto") + (notif.meta.hasMedia === true ? " q-notification__actions--with-media" : "");
  }
  if (originalApi !== void 0) {
    clearTimeout(originalApi.notif.meta.timer);
    notif.meta.uid = originalApi.notif.meta.uid;
    const index2 = notificationsList[notif.position].value.indexOf(originalApi.notif);
    notificationsList[notif.position].value[index2] = notif;
  } else {
    const original = groups[notif.meta.group];
    if (original === void 0) {
      notif.meta.uid = uid$1++;
      notif.meta.badge = 1;
      if (["left", "right", "center"].indexOf(notif.position) !== -1) {
        notificationsList[notif.position].value.splice(
          Math.floor(notificationsList[notif.position].value.length / 2),
          0,
          notif
        );
      } else {
        const action = notif.position.indexOf("top") > -1 ? "unshift" : "push";
        notificationsList[notif.position].value[action](notif);
      }
      if (notif.group !== void 0) {
        groups[notif.meta.group] = notif;
      }
    } else {
      clearTimeout(original.meta.timer);
      if (notif.badgePosition !== void 0) {
        if (badgePositions.includes(notif.badgePosition) === false) {
          return logError("wrong badgePosition", config);
        }
      } else {
        notif.badgePosition = `top-${notif.position.indexOf("left") > -1 ? "right" : "left"}`;
      }
      notif.meta.uid = original.meta.uid;
      notif.meta.badge = original.meta.badge + 1;
      notif.meta.badgeClass = `q-notification__badge q-notification__badge--${notif.badgePosition}` + (notif.badgeColor !== void 0 ? ` bg-${notif.badgeColor}` : "") + (notif.badgeTextColor !== void 0 ? ` text-${notif.badgeTextColor}` : "") + (notif.badgeClass ? ` ${notif.badgeClass}` : "");
      const index2 = notificationsList[notif.position].value.indexOf(original);
      notificationsList[notif.position].value[index2] = groups[notif.meta.group] = notif;
    }
  }
  const dismiss = () => {
    removeNotification(notif);
    Api = void 0;
  };
  if (notif.timeout > 0) {
    notif.meta.timer = setTimeout(() => {
      dismiss();
    }, notif.timeout + 1e3);
  }
  if (notif.group !== void 0) {
    return (props) => {
      if (props !== void 0) {
        logError("trying to update a grouped one which is forbidden", config);
      } else {
        dismiss();
      }
    };
  }
  Api = {
    dismiss,
    config,
    notif
  };
  if (originalApi !== void 0) {
    Object.assign(originalApi, Api);
    return;
  }
  return (props) => {
    if (Api !== void 0) {
      if (props === void 0) {
        Api.dismiss();
      } else {
        const newNotif = Object.assign({}, Api.config, props, {
          group: false,
          position: notif.position
        });
        addNotification(newNotif, $q, Api);
      }
    }
  };
}
function removeNotification(notif) {
  clearTimeout(notif.meta.timer);
  const index2 = notificationsList[notif.position].value.indexOf(notif);
  if (index2 !== -1) {
    if (notif.group !== void 0) {
      delete groups[notif.meta.group];
    }
    const el = notifRefs["" + notif.meta.uid];
    if (el) {
      const { width, height } = getComputedStyle(el);
      el.style.left = `${el.offsetLeft}px`;
      el.style.width = width;
      el.style.height = height;
    }
    notificationsList[notif.position].value.splice(index2, 1);
    if (typeof notif.onDismiss === "function") {
      notif.onDismiss();
    }
  }
}
function hasContent(str) {
  return str !== void 0 && str !== null && emptyRE.test(str) !== true;
}
function logError(error, config) {
  console.error(`Notify: ${error}`, config);
  return false;
}
function getComponent() {
  return createComponent({
    name: "QNotifications",
    devtools: { hide: true },
    setup() {
      return () => h("div", { class: "q-notifications" }, positionList.map((pos) => {
        return h(TransitionGroup, {
          key: pos,
          class: positionClass[pos],
          tag: "div",
          name: `q-notification--${pos}`
        }, () => notificationsList[pos].value.map((notif) => {
          const meta = notif.meta;
          const mainChild = [];
          if (meta.hasMedia === true) {
            if (notif.spinner !== false) {
              mainChild.push(
                h(notif.spinner, {
                  class: "q-notification__spinner q-notification__spinner--" + meta.leftClass,
                  color: notif.spinnerColor,
                  size: notif.spinnerSize
                })
              );
            } else if (notif.icon) {
              mainChild.push(
                h(QIcon, {
                  class: "q-notification__icon q-notification__icon--" + meta.leftClass,
                  name: notif.icon,
                  color: notif.iconColor,
                  size: notif.iconSize,
                  role: "img"
                })
              );
            } else if (notif.avatar) {
              mainChild.push(
                h(QAvatar, {
                  class: "q-notification__avatar q-notification__avatar--" + meta.leftClass
                }, () => h("img", { src: notif.avatar, "aria-hidden": "true" }))
              );
            }
          }
          if (meta.hasText === true) {
            let msgChild;
            const msgData = { class: "q-notification__message col" };
            if (notif.html === true) {
              msgData.innerHTML = notif.caption ? `<div>${notif.message}</div><div class="q-notification__caption">${notif.caption}</div>` : notif.message;
            } else {
              const msgNode = [notif.message];
              msgChild = notif.caption ? [
                h("div", msgNode),
                h("div", { class: "q-notification__caption" }, [notif.caption])
              ] : msgNode;
            }
            mainChild.push(
              h("div", msgData, msgChild)
            );
          }
          const child = [
            h("div", { class: meta.contentClass }, mainChild)
          ];
          notif.progress === true && child.push(
            h("div", {
              key: `${meta.uid}|p|${meta.badge}`,
              class: meta.progressClass,
              style: meta.progressStyle
            })
          );
          notif.actions !== void 0 && child.push(
            h("div", {
              class: meta.actionsClass
            }, notif.actions.map((props) => h(QBtn, props)))
          );
          meta.badge > 1 && child.push(
            h("div", {
              key: `${meta.uid}|${meta.badge}`,
              class: notif.meta.badgeClass,
              style: notif.badgeStyle
            }, [meta.badge])
          );
          return h("div", {
            ref: (el) => {
              notifRefs["" + meta.uid] = el;
            },
            key: meta.uid,
            class: meta.class,
            ...meta.attrs
          }, [
            h("div", { class: meta.wrapperClass }, child)
          ]);
        }));
      }));
    }
  });
}
const Notify = {
  setDefaults(opts) {
    {
      isObject(opts) === true && Object.assign(defaults$1, opts);
    }
  },
  registerType(typeName, typeOpts) {
    if (isObject(typeOpts) === true) {
      notifTypes[typeName] = typeOpts;
    }
  },
  install({ $q, parentApp }) {
    $q.notify = this.create = (opts) => addNotification(opts, $q);
    $q.notify.setDefaults = this.setDefaults;
    $q.notify.registerType = this.registerType;
    if ($q.config.notify !== void 0) {
      this.setDefaults($q.config.notify);
    }
    if (this.__installed !== true) {
      positionList.forEach((pos) => {
        notificationsList[pos] = ref([]);
        const vert = ["left", "center", "right"].includes(pos) === true ? "center" : pos.indexOf("top") > -1 ? "top" : "bottom", align = pos.indexOf("left") > -1 ? "start" : pos.indexOf("right") > -1 ? "end" : "center", classes = ["left", "right"].includes(pos) ? `items-${pos === "left" ? "start" : "end"} justify-center` : pos === "center" ? "flex-center" : `items-${align}`;
        positionClass[pos] = `q-notifications__list q-notifications__list--${vert} fixed column no-wrap ${classes}`;
      });
      const el = createGlobalNode("q-notify");
      createChildApp(getComponent(), parentApp).mount(el);
    }
  }
};
const Quasar = {
  version: "2.10.2",
  install: installQuasar,
  lang: Plugin$1,
  iconSet: Plugin
};
const index$1 = "";
var MediaServer = /* @__PURE__ */ ((MediaServer2) => {
  MediaServer2["Komga"] = "komga";
  MediaServer2["Kavita"] = "kavita";
  return MediaServer2;
})(MediaServer || {});
var Theme = /* @__PURE__ */ ((Theme2) => {
  Theme2["LIGHT"] = "theme.light";
  Theme2["DARK"] = "theme.dark";
  Theme2["SYSTEM"] = "theme.system";
  return Theme2;
})(Theme || {});
function useQuasar() {
  return inject(quasarKey);
}
let id = 0;
const useTabEmits = ["click", "keydown"];
const useTabProps = {
  icon: String,
  label: [Number, String],
  alert: [Boolean, String],
  alertIcon: String,
  name: {
    type: [Number, String],
    default: () => `t_${id++}`
  },
  noCaps: Boolean,
  tabindex: [String, Number],
  disable: Boolean,
  contentClass: String,
  ripple: {
    type: [Boolean, Object],
    default: true
  }
};
function useTab(props, slots, emit, routeData) {
  const $tabs = inject(tabsKey, emptyRenderFn);
  if ($tabs === emptyRenderFn) {
    console.error("QTab/QRouteTab component needs to be child of QTabs");
    return emptyRenderFn;
  }
  const { proxy } = getCurrentInstance();
  const blurTargetRef = ref(null);
  const rootRef = ref(null);
  const tabIndicatorRef = ref(null);
  const ripple = computed(() => props.disable === true || props.ripple === false ? false : Object.assign(
    { keyCodes: [13, 32], early: true },
    props.ripple === true ? {} : props.ripple
  ));
  const isActive = computed(() => $tabs.currentModel.value === props.name);
  const classes = computed(
    () => "q-tab relative-position self-stretch flex flex-center text-center" + (isActive.value === true ? " q-tab--active" + ($tabs.tabProps.value.activeClass ? " " + $tabs.tabProps.value.activeClass : "") + ($tabs.tabProps.value.activeColor ? ` text-${$tabs.tabProps.value.activeColor}` : "") + ($tabs.tabProps.value.activeBgColor ? ` bg-${$tabs.tabProps.value.activeBgColor}` : "") : " q-tab--inactive") + (props.icon && props.label && $tabs.tabProps.value.inlineLabel === false ? " q-tab--full" : "") + (props.noCaps === true || $tabs.tabProps.value.noCaps === true ? " q-tab--no-caps" : "") + (props.disable === true ? " disabled" : " q-focusable q-hoverable cursor-pointer") + (routeData !== void 0 ? routeData.linkClass.value : "")
  );
  const innerClass = computed(
    () => "q-tab__content self-stretch flex-center relative-position q-anchor--skip non-selectable " + ($tabs.tabProps.value.inlineLabel === true ? "row no-wrap q-tab__content--inline" : "column") + (props.contentClass !== void 0 ? ` ${props.contentClass}` : "")
  );
  const tabIndex = computed(() => props.disable === true || $tabs.hasFocus.value === true || isActive.value === false && $tabs.hasActiveTab.value === true ? -1 : props.tabindex || 0);
  function onClick(e, keyboard) {
    if (keyboard !== true && blurTargetRef.value !== null) {
      blurTargetRef.value.focus();
    }
    if (props.disable === true) {
      if (routeData !== void 0 && routeData.hasRouterLink.value === true) {
        stopAndPrevent(e);
      }
      return;
    }
    if (routeData === void 0) {
      $tabs.updateModel({ name: props.name });
      emit("click", e);
      return;
    }
    if (routeData.hasRouterLink.value === true) {
      const go = (opts = {}) => {
        let hardError;
        const reqId = opts.to === void 0 || isDeepEqual(opts.to, props.to) === true ? $tabs.avoidRouteWatcher = uid$2() : null;
        return routeData.navigateToRouterLink(e, { ...opts, returnRouterError: true }).catch((err) => {
          hardError = err;
        }).then((softError) => {
          if (reqId === $tabs.avoidRouteWatcher) {
            $tabs.avoidRouteWatcher = false;
            if (hardError === void 0 && (softError === void 0 || softError.message.startsWith("Avoided redundant navigation") === true)) {
              $tabs.updateModel({ name: props.name });
            }
          }
          if (opts.returnRouterError === true) {
            return hardError !== void 0 ? Promise.reject(hardError) : softError;
          }
        });
      };
      emit("click", e, go);
      e.defaultPrevented !== true && go();
      return;
    }
    emit("click", e);
  }
  function onKeydown2(e) {
    if (isKeyCode(e, [13, 32])) {
      onClick(e, true);
    } else if (shouldIgnoreKey(e) !== true && e.keyCode >= 35 && e.keyCode <= 40 && e.altKey !== true && e.metaKey !== true) {
      $tabs.onKbdNavigate(e.keyCode, proxy.$el) === true && stopAndPrevent(e);
    }
    emit("keydown", e);
  }
  function getContent() {
    const narrow = $tabs.tabProps.value.narrowIndicator, content = [], indicator = h("div", {
      ref: tabIndicatorRef,
      class: [
        "q-tab__indicator",
        $tabs.tabProps.value.indicatorClass
      ]
    });
    props.icon !== void 0 && content.push(
      h(QIcon, {
        class: "q-tab__icon",
        name: props.icon
      })
    );
    props.label !== void 0 && content.push(
      h("div", { class: "q-tab__label" }, props.label)
    );
    props.alert !== false && content.push(
      props.alertIcon !== void 0 ? h(QIcon, {
        class: "q-tab__alert-icon",
        color: props.alert !== true ? props.alert : void 0,
        name: props.alertIcon
      }) : h("div", {
        class: "q-tab__alert" + (props.alert !== true ? ` text-${props.alert}` : "")
      })
    );
    narrow === true && content.push(indicator);
    const node = [
      h("div", { class: "q-focus-helper", tabindex: -1, ref: blurTargetRef }),
      h("div", { class: innerClass.value }, hMergeSlot(slots.default, content))
    ];
    narrow === false && node.push(indicator);
    return node;
  }
  const tabData = {
    name: computed(() => props.name),
    rootRef,
    tabIndicatorRef,
    routeData
  };
  onBeforeUnmount(() => {
    $tabs.unregisterTab(tabData);
  });
  onMounted(() => {
    $tabs.registerTab(tabData);
  });
  function renderTab(tag, customData) {
    const data = {
      ref: rootRef,
      class: classes.value,
      tabindex: tabIndex.value,
      role: "tab",
      "aria-selected": isActive.value === true ? "true" : "false",
      "aria-disabled": props.disable === true ? "true" : void 0,
      onClick,
      onKeydown: onKeydown2,
      ...customData
    };
    return withDirectives(
      h(tag, data, getContent()),
      [[Ripple, ripple.value]]
    );
  }
  return { renderTab, $tabs };
}
const QTab = createComponent({
  name: "QTab",
  props: useTabProps,
  emits: useTabEmits,
  setup(props, { slots, emit }) {
    const { renderTab } = useTab(props, slots, emit);
    return () => renderTab("div");
  }
});
function useCanRender() {
  const canRender = ref(!isRuntimeSsrPreHydration.value);
  if (canRender.value === false) {
    onMounted(() => {
      canRender.value = true;
    });
  }
  return canRender;
}
const hasObserver = typeof ResizeObserver !== "undefined";
const resizeProps = hasObserver === true ? {} : {
  style: "display:block;position:absolute;top:0;left:0;right:0;bottom:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;",
  url: "about:blank"
};
const QResizeObserver = createComponent({
  name: "QResizeObserver",
  props: {
    debounce: {
      type: [String, Number],
      default: 100
    }
  },
  emits: ["resize"],
  setup(props, { emit }) {
    let timer2 = null, targetEl, size2 = { width: -1, height: -1 };
    function trigger2(immediately) {
      if (immediately === true || props.debounce === 0 || props.debounce === "0") {
        emitEvent();
      } else if (timer2 === null) {
        timer2 = setTimeout(emitEvent, props.debounce);
      }
    }
    function emitEvent() {
      clearTimeout(timer2);
      timer2 = null;
      if (targetEl) {
        const { offsetWidth: width, offsetHeight: height } = targetEl;
        if (width !== size2.width || height !== size2.height) {
          size2 = { width, height };
          emit("resize", size2);
        }
      }
    }
    const { proxy } = getCurrentInstance();
    if (hasObserver === true) {
      let observer;
      const init = (stop2) => {
        targetEl = proxy.$el.parentNode;
        if (targetEl) {
          observer = new ResizeObserver(trigger2);
          observer.observe(targetEl);
          emitEvent();
        } else if (stop2 !== true) {
          nextTick(() => {
            init(true);
          });
        }
      };
      onMounted(() => {
        init();
      });
      onBeforeUnmount(() => {
        clearTimeout(timer2);
        if (observer !== void 0) {
          if (observer.disconnect !== void 0) {
            observer.disconnect();
          } else if (targetEl) {
            observer.unobserve(targetEl);
          }
        }
      });
      return noop;
    } else {
      let cleanup2 = function() {
        clearTimeout(timer2);
        if (curDocView !== void 0) {
          if (curDocView.removeEventListener !== void 0) {
            curDocView.removeEventListener("resize", trigger2, listenOpts.passive);
          }
          curDocView = void 0;
        }
      }, onObjLoad2 = function() {
        cleanup2();
        if (targetEl && targetEl.contentDocument) {
          curDocView = targetEl.contentDocument.defaultView;
          curDocView.addEventListener("resize", trigger2, listenOpts.passive);
          emitEvent();
        }
      };
      var cleanup = cleanup2, onObjLoad = onObjLoad2;
      const canRender = useCanRender();
      let curDocView;
      onMounted(() => {
        nextTick(() => {
          targetEl = proxy.$el;
          targetEl && onObjLoad2();
        });
      });
      onBeforeUnmount(cleanup2);
      proxy.trigger = trigger2;
      return () => {
        if (canRender.value === true) {
          return h("object", {
            style: resizeProps.style,
            tabindex: -1,
            type: "text/html",
            data: resizeProps.url,
            "aria-hidden": "true",
            onLoad: onObjLoad2
          });
        }
      };
    }
  }
});
let rtlHasScrollBug = false;
{
  const scroller = document.createElement("div");
  scroller.setAttribute("dir", "rtl");
  Object.assign(scroller.style, {
    width: "1px",
    height: "1px",
    overflow: "auto"
  });
  const spacer = document.createElement("div");
  Object.assign(spacer.style, {
    width: "1000px",
    height: "1px"
  });
  document.body.appendChild(scroller);
  scroller.appendChild(spacer);
  scroller.scrollLeft = -1e3;
  rtlHasScrollBug = scroller.scrollLeft >= 0;
  scroller.remove();
}
function getIndicatorClass(color, top, vertical) {
  const pos = vertical === true ? ["left", "right"] : ["top", "bottom"];
  return `absolute-${top === true ? pos[0] : pos[1]}${color ? ` text-${color}` : ""}`;
}
const alignValues = ["left", "center", "right", "justify"];
const QTabs = createComponent({
  name: "QTabs",
  props: {
    modelValue: [Number, String],
    align: {
      type: String,
      default: "center",
      validator: (v2) => alignValues.includes(v2)
    },
    breakpoint: {
      type: [String, Number],
      default: 600
    },
    vertical: Boolean,
    shrink: Boolean,
    stretch: Boolean,
    activeClass: String,
    activeColor: String,
    activeBgColor: String,
    indicatorColor: String,
    leftIcon: String,
    rightIcon: String,
    outsideArrows: Boolean,
    mobileArrows: Boolean,
    switchIndicator: Boolean,
    narrowIndicator: Boolean,
    inlineLabel: Boolean,
    noCaps: Boolean,
    dense: Boolean,
    contentClass: String,
    "onUpdate:modelValue": [Function, Array]
  },
  setup(props, { slots, emit }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const { registerTick: registerScrollTick } = useTick();
    const { registerTick: registerUpdateArrowsTick } = useTick();
    const { registerTick: registerAnimateTick } = useTick();
    const { registerTimeout: registerFocusTimeout, removeTimeout: removeFocusTimeout } = useTimeout();
    const { registerTimeout: registerScrollToTabTimeout, removeTimeout: removeScrollToTabTimeout } = useTimeout();
    const rootRef = ref(null);
    const contentRef = ref(null);
    const currentModel = ref(props.modelValue);
    const scrollable = ref(false);
    const leftArrow = ref(true);
    const rightArrow = ref(false);
    const justify = ref(false);
    const arrowsEnabled = computed(
      () => $q.platform.is.desktop === true || props.mobileArrows === true
    );
    const tabDataList = [];
    const tabDataListLen = ref(0);
    const hasFocus = ref(false);
    let animateTimer, scrollTimer, unwatchRoute;
    let localUpdateArrows = arrowsEnabled.value === true ? updateArrowsFn : noop;
    const tabProps = computed(() => ({
      activeClass: props.activeClass,
      activeColor: props.activeColor,
      activeBgColor: props.activeBgColor,
      indicatorClass: getIndicatorClass(
        props.indicatorColor,
        props.switchIndicator,
        props.vertical
      ),
      narrowIndicator: props.narrowIndicator,
      inlineLabel: props.inlineLabel,
      noCaps: props.noCaps
    }));
    const hasActiveTab = computed(() => {
      const len = tabDataListLen.value;
      const val = currentModel.value;
      for (let i = 0; i < len; i++) {
        if (tabDataList[i].name.value === val) {
          return true;
        }
      }
      return false;
    });
    const alignClass = computed(() => {
      const align = scrollable.value === true ? "left" : justify.value === true ? "justify" : props.align;
      return `q-tabs__content--align-${align}`;
    });
    const classes = computed(
      () => `q-tabs row no-wrap items-center q-tabs--${scrollable.value === true ? "" : "not-"}scrollable q-tabs--${props.vertical === true ? "vertical" : "horizontal"} q-tabs__arrows--${arrowsEnabled.value === true && props.outsideArrows === true ? "outside" : "inside"}` + (props.dense === true ? " q-tabs--dense" : "") + (props.shrink === true ? " col-shrink" : "") + (props.stretch === true ? " self-stretch" : "")
    );
    const innerClass = computed(
      () => "q-tabs__content row no-wrap items-center self-stretch hide-scrollbar relative-position " + alignClass.value + (props.contentClass !== void 0 ? ` ${props.contentClass}` : "") + ($q.platform.is.mobile === true ? " scroll" : "")
    );
    const domProps = computed(() => props.vertical === true ? { container: "height", content: "offsetHeight", scroll: "scrollHeight" } : { container: "width", content: "offsetWidth", scroll: "scrollWidth" });
    const isRTL = computed(() => props.vertical !== true && $q.lang.rtl === true);
    const rtlPosCorrection = computed(() => rtlHasScrollBug === false && isRTL.value === true);
    watch(isRTL, localUpdateArrows);
    watch(() => props.modelValue, (name) => {
      updateModel({ name, setCurrent: true, skipEmit: true });
    });
    watch(() => props.outsideArrows, () => {
      recalculateScroll();
    });
    watch(arrowsEnabled, (v2) => {
      localUpdateArrows = v2 === true ? updateArrowsFn : noop;
      recalculateScroll();
    });
    function updateModel({ name, setCurrent, skipEmit, fromRoute }) {
      if (currentModel.value !== name) {
        if (skipEmit !== true && props["onUpdate:modelValue"] !== void 0) {
          emit("update:modelValue", name);
        }
        if (setCurrent === true || props["onUpdate:modelValue"] === void 0) {
          animate(currentModel.value, name);
          currentModel.value = name;
        }
      }
    }
    function recalculateScroll() {
      registerScrollTick(() => {
        updateContainer({
          width: rootRef.value.offsetWidth,
          height: rootRef.value.offsetHeight
        });
      });
    }
    function updateContainer(domSize) {
      if (domProps.value === void 0 || contentRef.value === null) {
        return;
      }
      const size2 = domSize[domProps.value.container], scrollSize = Math.min(
        contentRef.value[domProps.value.scroll],
        Array.prototype.reduce.call(
          contentRef.value.children,
          (acc, el) => acc + (el[domProps.value.content] || 0),
          0
        )
      ), scroll = size2 > 0 && scrollSize > size2;
      scrollable.value = scroll;
      scroll === true && registerUpdateArrowsTick(localUpdateArrows);
      justify.value = size2 < parseInt(props.breakpoint, 10);
    }
    function animate(oldName, newName) {
      const oldTab = oldName !== void 0 && oldName !== null && oldName !== "" ? tabDataList.find((tab) => tab.name.value === oldName) : null, newTab = newName !== void 0 && newName !== null && newName !== "" ? tabDataList.find((tab) => tab.name.value === newName) : null;
      if (oldTab && newTab) {
        const oldEl = oldTab.tabIndicatorRef.value, newEl = newTab.tabIndicatorRef.value;
        clearTimeout(animateTimer);
        oldEl.style.transition = "none";
        oldEl.style.transform = "none";
        newEl.style.transition = "none";
        newEl.style.transform = "none";
        const oldPos = oldEl.getBoundingClientRect(), newPos = newEl.getBoundingClientRect();
        newEl.style.transform = props.vertical === true ? `translate3d(0,${oldPos.top - newPos.top}px,0) scale3d(1,${newPos.height ? oldPos.height / newPos.height : 1},1)` : `translate3d(${oldPos.left - newPos.left}px,0,0) scale3d(${newPos.width ? oldPos.width / newPos.width : 1},1,1)`;
        registerAnimateTick(() => {
          animateTimer = setTimeout(() => {
            newEl.style.transition = "transform .25s cubic-bezier(.4, 0, .2, 1)";
            newEl.style.transform = "none";
          }, 70);
        });
      }
      if (newTab && scrollable.value === true) {
        scrollToTabEl(newTab.rootRef.value);
      }
    }
    function scrollToTabEl(el) {
      const { left, width, top, height } = contentRef.value.getBoundingClientRect(), newPos = el.getBoundingClientRect();
      let offset = props.vertical === true ? newPos.top - top : newPos.left - left;
      if (offset < 0) {
        contentRef.value[props.vertical === true ? "scrollTop" : "scrollLeft"] += Math.floor(offset);
        localUpdateArrows();
        return;
      }
      offset += props.vertical === true ? newPos.height - height : newPos.width - width;
      if (offset > 0) {
        contentRef.value[props.vertical === true ? "scrollTop" : "scrollLeft"] += Math.ceil(offset);
        localUpdateArrows();
      }
    }
    function updateArrowsFn() {
      const content = contentRef.value;
      if (content !== null) {
        const rect = content.getBoundingClientRect(), pos = props.vertical === true ? content.scrollTop : Math.abs(content.scrollLeft);
        if (isRTL.value === true) {
          leftArrow.value = Math.ceil(pos + rect.width) < content.scrollWidth - 1;
          rightArrow.value = pos > 0;
        } else {
          leftArrow.value = pos > 0;
          rightArrow.value = props.vertical === true ? Math.ceil(pos + rect.height) < content.scrollHeight : Math.ceil(pos + rect.width) < content.scrollWidth;
        }
      }
    }
    function animScrollTo(value2) {
      stopAnimScroll();
      scrollTimer = setInterval(() => {
        if (scrollTowards(value2) === true) {
          stopAnimScroll();
        }
      }, 5);
    }
    function scrollToStart() {
      animScrollTo(rtlPosCorrection.value === true ? Number.MAX_SAFE_INTEGER : 0);
    }
    function scrollToEnd() {
      animScrollTo(rtlPosCorrection.value === true ? 0 : Number.MAX_SAFE_INTEGER);
    }
    function stopAnimScroll() {
      clearInterval(scrollTimer);
    }
    function onKbdNavigate(keyCode, fromEl) {
      const tabs = Array.prototype.filter.call(
        contentRef.value.children,
        (el) => el === fromEl || el.matches && el.matches(".q-tab.q-focusable") === true
      );
      const len = tabs.length;
      if (len === 0) {
        return;
      }
      if (keyCode === 36) {
        scrollToTabEl(tabs[0]);
        tabs[0].focus();
        return true;
      }
      if (keyCode === 35) {
        scrollToTabEl(tabs[len - 1]);
        tabs[len - 1].focus();
        return true;
      }
      const dirPrev = keyCode === (props.vertical === true ? 38 : 37);
      const dirNext = keyCode === (props.vertical === true ? 40 : 39);
      const dir = dirPrev === true ? -1 : dirNext === true ? 1 : void 0;
      if (dir !== void 0) {
        const rtlDir = isRTL.value === true ? -1 : 1;
        const index2 = tabs.indexOf(fromEl) + dir * rtlDir;
        if (index2 >= 0 && index2 < len) {
          scrollToTabEl(tabs[index2]);
          tabs[index2].focus({ preventScroll: true });
        }
        return true;
      }
    }
    const posFn = computed(() => rtlPosCorrection.value === true ? { get: (content) => Math.abs(content.scrollLeft), set: (content, pos) => {
      content.scrollLeft = -pos;
    } } : props.vertical === true ? { get: (content) => content.scrollTop, set: (content, pos) => {
      content.scrollTop = pos;
    } } : { get: (content) => content.scrollLeft, set: (content, pos) => {
      content.scrollLeft = pos;
    } });
    function scrollTowards(value2) {
      const content = contentRef.value, { get: get2, set: set2 } = posFn.value;
      let done = false, pos = get2(content);
      const direction = value2 < pos ? -1 : 1;
      pos += direction * 5;
      if (pos < 0) {
        done = true;
        pos = 0;
      } else if (direction === -1 && pos <= value2 || direction === 1 && pos >= value2) {
        done = true;
        pos = value2;
      }
      set2(content, pos);
      localUpdateArrows();
      return done;
    }
    function hasQueryIncluded(targetQuery, matchingQuery) {
      for (const key in targetQuery) {
        if (targetQuery[key] !== matchingQuery[key]) {
          return false;
        }
      }
      return true;
    }
    function updateActiveRoute() {
      let name = null, bestScore = { matchedLen: 0, queryDiff: 9999, hrefLen: 0 };
      const list = tabDataList.filter((tab) => tab.routeData !== void 0 && tab.routeData.hasRouterLink.value === true);
      const { hash: currentHash, query: currentQuery } = proxy.$route;
      const currentQueryLen = Object.keys(currentQuery).length;
      for (const tab of list) {
        const exact = tab.routeData.exact.value === true;
        if (tab.routeData[exact === true ? "linkIsExactActive" : "linkIsActive"].value !== true) {
          continue;
        }
        const { hash, query, matched, href } = tab.routeData.resolvedLink.value;
        const queryLen = Object.keys(query).length;
        if (exact === true) {
          if (hash !== currentHash) {
            continue;
          }
          if (queryLen !== currentQueryLen || hasQueryIncluded(currentQuery, query) === false) {
            continue;
          }
          name = tab.name.value;
          break;
        }
        if (hash !== "" && hash !== currentHash) {
          continue;
        }
        if (queryLen !== 0 && hasQueryIncluded(query, currentQuery) === false) {
          continue;
        }
        const newScore = {
          matchedLen: matched.length,
          queryDiff: currentQueryLen - queryLen,
          hrefLen: href.length - hash.length
        };
        if (newScore.matchedLen > bestScore.matchedLen) {
          name = tab.name.value;
          bestScore = newScore;
          continue;
        } else if (newScore.matchedLen !== bestScore.matchedLen) {
          continue;
        }
        if (newScore.queryDiff < bestScore.queryDiff) {
          name = tab.name.value;
          bestScore = newScore;
        } else if (newScore.queryDiff !== bestScore.queryDiff) {
          continue;
        }
        if (newScore.hrefLen > bestScore.hrefLen) {
          name = tab.name.value;
          bestScore = newScore;
        }
      }
      if (name === null && tabDataList.some((tab) => tab.routeData === void 0 && tab.name.value === currentModel.value) === true) {
        return;
      }
      updateModel({ name, setCurrent: true });
    }
    function onFocusin(e) {
      removeFocusTimeout();
      if (hasFocus.value !== true && rootRef.value !== null && e.target && typeof e.target.closest === "function") {
        const tab = e.target.closest(".q-tab");
        if (tab && rootRef.value.contains(tab) === true) {
          hasFocus.value = true;
          scrollable.value === true && scrollToTabEl(tab);
        }
      }
    }
    function onFocusout() {
      registerFocusTimeout(() => {
        hasFocus.value = false;
      }, 30);
    }
    function verifyRouteModel() {
      if ($tabs.avoidRouteWatcher === false) {
        registerScrollToTabTimeout(updateActiveRoute);
      } else {
        removeScrollToTabTimeout();
      }
    }
    function watchRoute() {
      if (unwatchRoute === void 0) {
        const unwatch = watch(() => proxy.$route.fullPath, verifyRouteModel);
        unwatchRoute = () => {
          unwatch();
          unwatchRoute = void 0;
        };
      }
    }
    function registerTab(tabData) {
      tabDataList.push(tabData);
      tabDataListLen.value++;
      recalculateScroll();
      if (tabData.routeData === void 0 || proxy.$route === void 0) {
        registerScrollToTabTimeout(() => {
          if (scrollable.value === true) {
            const value2 = currentModel.value;
            const newTab = value2 !== void 0 && value2 !== null && value2 !== "" ? tabDataList.find((tab) => tab.name.value === value2) : null;
            newTab && scrollToTabEl(newTab.rootRef.value);
          }
        });
      } else {
        watchRoute();
        if (tabData.routeData.hasRouterLink.value === true) {
          verifyRouteModel();
        }
      }
    }
    function unregisterTab(tabData) {
      tabDataList.splice(tabDataList.indexOf(tabData), 1);
      tabDataListLen.value--;
      recalculateScroll();
      if (unwatchRoute !== void 0 && tabData.routeData !== void 0) {
        if (tabDataList.every((tab) => tab.routeData === void 0) === true) {
          unwatchRoute();
        }
        verifyRouteModel();
      }
    }
    const $tabs = {
      currentModel,
      tabProps,
      hasFocus,
      hasActiveTab,
      registerTab,
      unregisterTab,
      verifyRouteModel,
      updateModel,
      onKbdNavigate,
      avoidRouteWatcher: false
    };
    provide(tabsKey, $tabs);
    function cleanup() {
      clearTimeout(animateTimer);
      stopAnimScroll();
      unwatchRoute !== void 0 && unwatchRoute();
    }
    let hadRouteWatcher;
    onBeforeUnmount(cleanup);
    onDeactivated(() => {
      hadRouteWatcher = unwatchRoute !== void 0;
      cleanup();
    });
    onActivated(() => {
      hadRouteWatcher === true && watchRoute();
      recalculateScroll();
    });
    return () => {
      const child = [
        h(QResizeObserver, { onResize: updateContainer }),
        h("div", {
          ref: contentRef,
          class: innerClass.value,
          onScroll: localUpdateArrows
        }, hSlot(slots.default))
      ];
      arrowsEnabled.value === true && child.push(
        h(QIcon, {
          class: "q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon" + (leftArrow.value === true ? "" : " q-tabs__arrow--faded"),
          name: props.leftIcon || $q.iconSet.tabs[props.vertical === true ? "up" : "left"],
          onMousedownPassive: scrollToStart,
          onTouchstartPassive: scrollToStart,
          onMouseupPassive: stopAnimScroll,
          onMouseleavePassive: stopAnimScroll,
          onTouchendPassive: stopAnimScroll
        }),
        h(QIcon, {
          class: "q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon" + (rightArrow.value === true ? "" : " q-tabs__arrow--faded"),
          name: props.rightIcon || $q.iconSet.tabs[props.vertical === true ? "down" : "right"],
          onMousedownPassive: scrollToEnd,
          onTouchstartPassive: scrollToEnd,
          onMouseupPassive: stopAnimScroll,
          onMouseleavePassive: stopAnimScroll,
          onTouchendPassive: stopAnimScroll
        })
      );
      return h("div", {
        ref: rootRef,
        class: classes.value,
        role: "tablist",
        onFocusin,
        onFocusout
      }, child);
    };
  }
});
const modifiersAll = {
  left: true,
  right: true,
  up: true,
  down: true,
  horizontal: true,
  vertical: true
};
const directionList = Object.keys(modifiersAll);
modifiersAll.all = true;
function getModifierDirections(mod) {
  const dir = {};
  for (const direction of directionList) {
    if (mod[direction] === true) {
      dir[direction] = true;
    }
  }
  if (Object.keys(dir).length === 0) {
    return modifiersAll;
  }
  if (dir.horizontal === true) {
    dir.left = dir.right = true;
  } else if (dir.left === true && dir.right === true) {
    dir.horizontal = true;
  }
  if (dir.vertical === true) {
    dir.up = dir.down = true;
  } else if (dir.up === true && dir.down === true) {
    dir.vertical = true;
  }
  if (dir.horizontal === true && dir.vertical === true) {
    dir.all = true;
  }
  return dir;
}
function shouldStart(evt, ctx) {
  return ctx.event === void 0 && evt.target !== void 0 && evt.target.draggable !== true && typeof ctx.handler === "function" && evt.target.nodeName.toUpperCase() !== "INPUT" && (evt.qClonedBy === void 0 || evt.qClonedBy.indexOf(ctx.uid) === -1);
}
function clearSelection() {
  if (window.getSelection !== void 0) {
    const selection = window.getSelection();
    if (selection.empty !== void 0) {
      selection.empty();
    } else if (selection.removeAllRanges !== void 0) {
      selection.removeAllRanges();
      Platform.is.mobile !== true && selection.addRange(document.createRange());
    }
  } else if (document.selection !== void 0) {
    document.selection.empty();
  }
}
function parseArg(arg) {
  const data = [0.06, 6, 50];
  if (typeof arg === "string" && arg.length) {
    arg.split(":").forEach((val, index2) => {
      const v2 = parseFloat(val);
      v2 && (data[index2] = v2);
    });
  }
  return data;
}
const TouchSwipe = createDirective(
  {
    name: "touch-swipe",
    beforeMount(el, { value: value2, arg, modifiers }) {
      if (modifiers.mouse !== true && client.has.touch !== true) {
        return;
      }
      const mouseCapture = modifiers.mouseCapture === true ? "Capture" : "";
      const ctx = {
        handler: value2,
        sensitivity: parseArg(arg),
        direction: getModifierDirections(modifiers),
        noop,
        mouseStart(evt) {
          if (shouldStart(evt, ctx) && leftClick(evt)) {
            addEvt(ctx, "temp", [
              [document, "mousemove", "move", `notPassive${mouseCapture}`],
              [document, "mouseup", "end", "notPassiveCapture"]
            ]);
            ctx.start(evt, true);
          }
        },
        touchStart(evt) {
          if (shouldStart(evt, ctx)) {
            const target2 = evt.target;
            addEvt(ctx, "temp", [
              [target2, "touchmove", "move", "notPassiveCapture"],
              [target2, "touchcancel", "end", "notPassiveCapture"],
              [target2, "touchend", "end", "notPassiveCapture"]
            ]);
            ctx.start(evt);
          }
        },
        start(evt, mouseEvent) {
          client.is.firefox === true && preventDraggable(el, true);
          const pos = position(evt);
          ctx.event = {
            x: pos.left,
            y: pos.top,
            time: Date.now(),
            mouse: mouseEvent === true,
            dir: false
          };
        },
        move(evt) {
          if (ctx.event === void 0) {
            return;
          }
          if (ctx.event.dir !== false) {
            stopAndPrevent(evt);
            return;
          }
          const time = Date.now() - ctx.event.time;
          if (time === 0) {
            return;
          }
          const pos = position(evt), distX = pos.left - ctx.event.x, absX = Math.abs(distX), distY = pos.top - ctx.event.y, absY = Math.abs(distY);
          if (ctx.event.mouse !== true) {
            if (absX < ctx.sensitivity[1] && absY < ctx.sensitivity[1]) {
              ctx.end(evt);
              return;
            }
          } else if (absX < ctx.sensitivity[2] && absY < ctx.sensitivity[2]) {
            return;
          }
          const velX = absX / time, velY = absY / time;
          if (ctx.direction.vertical === true && absX < absY && absX < 100 && velY > ctx.sensitivity[0]) {
            ctx.event.dir = distY < 0 ? "up" : "down";
          }
          if (ctx.direction.horizontal === true && absX > absY && absY < 100 && velX > ctx.sensitivity[0]) {
            ctx.event.dir = distX < 0 ? "left" : "right";
          }
          if (ctx.direction.up === true && absX < absY && distY < 0 && absX < 100 && velY > ctx.sensitivity[0]) {
            ctx.event.dir = "up";
          }
          if (ctx.direction.down === true && absX < absY && distY > 0 && absX < 100 && velY > ctx.sensitivity[0]) {
            ctx.event.dir = "down";
          }
          if (ctx.direction.left === true && absX > absY && distX < 0 && absY < 100 && velX > ctx.sensitivity[0]) {
            ctx.event.dir = "left";
          }
          if (ctx.direction.right === true && absX > absY && distX > 0 && absY < 100 && velX > ctx.sensitivity[0]) {
            ctx.event.dir = "right";
          }
          if (ctx.event.dir !== false) {
            stopAndPrevent(evt);
            if (ctx.event.mouse === true) {
              document.body.classList.add("no-pointer-events--children");
              document.body.classList.add("non-selectable");
              clearSelection();
              ctx.styleCleanup = (withDelay) => {
                ctx.styleCleanup = void 0;
                document.body.classList.remove("non-selectable");
                const remove2 = () => {
                  document.body.classList.remove("no-pointer-events--children");
                };
                if (withDelay === true) {
                  setTimeout(remove2, 50);
                } else {
                  remove2();
                }
              };
            }
            ctx.handler({
              evt,
              touch: ctx.event.mouse !== true,
              mouse: ctx.event.mouse,
              direction: ctx.event.dir,
              duration: time,
              distance: {
                x: absX,
                y: absY
              }
            });
          } else {
            ctx.end(evt);
          }
        },
        end(evt) {
          if (ctx.event === void 0) {
            return;
          }
          cleanEvt(ctx, "temp");
          client.is.firefox === true && preventDraggable(el, false);
          ctx.styleCleanup !== void 0 && ctx.styleCleanup(true);
          evt !== void 0 && ctx.event.dir !== false && stopAndPrevent(evt);
          ctx.event = void 0;
        }
      };
      el.__qtouchswipe = ctx;
      if (modifiers.mouse === true) {
        const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true ? "Capture" : "";
        addEvt(ctx, "main", [
          [el, "mousedown", "mouseStart", `passive${capture}`]
        ]);
      }
      client.has.touch === true && addEvt(ctx, "main", [
        [el, "touchstart", "touchStart", `passive${modifiers.capture === true ? "Capture" : ""}`],
        [el, "touchmove", "noop", "notPassiveCapture"]
      ]);
    },
    updated(el, bindings) {
      const ctx = el.__qtouchswipe;
      if (ctx !== void 0) {
        if (bindings.oldValue !== bindings.value) {
          typeof bindings.value !== "function" && ctx.end();
          ctx.handler = bindings.value;
        }
        ctx.direction = getModifierDirections(bindings.modifiers);
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qtouchswipe;
      if (ctx !== void 0) {
        cleanEvt(ctx, "main");
        cleanEvt(ctx, "temp");
        client.is.firefox === true && preventDraggable(el, false);
        ctx.styleCleanup !== void 0 && ctx.styleCleanup();
        delete el.__qtouchswipe;
      }
    }
  }
);
function useCache() {
  const cache = /* @__PURE__ */ new Map();
  return {
    getCache: function(key, obj) {
      return cache[key] === void 0 ? cache[key] = obj : cache[key];
    },
    getCacheWithFn: function(key, fn) {
      return cache[key] === void 0 ? cache[key] = fn() : cache[key];
    }
  };
}
const usePanelChildProps = {
  name: { required: true },
  disable: Boolean
};
const PanelWrapper = {
  setup(_, { slots }) {
    return () => h("div", {
      class: "q-panel scroll",
      role: "tabpanel"
    }, hSlot(slots.default));
  }
};
const usePanelProps = {
  modelValue: {
    required: true
  },
  animated: Boolean,
  infinite: Boolean,
  swipeable: Boolean,
  vertical: Boolean,
  transitionPrev: String,
  transitionNext: String,
  transitionDuration: {
    type: [String, Number],
    default: 300
  },
  keepAlive: Boolean,
  keepAliveInclude: [String, Array, RegExp],
  keepAliveExclude: [String, Array, RegExp],
  keepAliveMax: Number
};
const usePanelEmits = ["update:modelValue", "beforeTransition", "transition"];
function usePanel() {
  const { props, emit, proxy } = getCurrentInstance();
  const { getCacheWithFn } = useCache();
  let panels, forcedPanelTransition;
  const panelIndex = ref(null);
  const panelTransition = ref(null);
  function onSwipe(evt) {
    const dir = props.vertical === true ? "up" : "left";
    goToPanelByOffset((proxy.$q.lang.rtl === true ? -1 : 1) * (evt.direction === dir ? 1 : -1));
  }
  const panelDirectives = computed(() => {
    return [[
      TouchSwipe,
      onSwipe,
      void 0,
      {
        horizontal: props.vertical !== true,
        vertical: props.vertical,
        mouse: true
      }
    ]];
  });
  const transitionPrev = computed(
    () => props.transitionPrev || `slide-${props.vertical === true ? "down" : "right"}`
  );
  const transitionNext = computed(
    () => props.transitionNext || `slide-${props.vertical === true ? "up" : "left"}`
  );
  const transitionStyle = computed(
    () => `--q-transition-duration: ${props.transitionDuration}ms`
  );
  const contentKey = computed(() => typeof props.modelValue === "string" || typeof props.modelValue === "number" ? props.modelValue : String(props.modelValue));
  const keepAliveProps = computed(() => ({
    include: props.keepAliveInclude,
    exclude: props.keepAliveExclude,
    max: props.keepAliveMax
  }));
  const needsUniqueKeepAliveWrapper = computed(
    () => props.keepAliveInclude !== void 0 || props.keepAliveExclude !== void 0
  );
  watch(() => props.modelValue, (newVal, oldVal) => {
    const index2 = isValidPanelName(newVal) === true ? getPanelIndex(newVal) : -1;
    if (forcedPanelTransition !== true) {
      updatePanelTransition(
        index2 === -1 ? 0 : index2 < getPanelIndex(oldVal) ? -1 : 1
      );
    }
    if (panelIndex.value !== index2) {
      panelIndex.value = index2;
      emit("beforeTransition", newVal, oldVal);
      nextTick(() => {
        emit("transition", newVal, oldVal);
      });
    }
  });
  function nextPanel() {
    goToPanelByOffset(1);
  }
  function previousPanel() {
    goToPanelByOffset(-1);
  }
  function goToPanel(name) {
    emit("update:modelValue", name);
  }
  function isValidPanelName(name) {
    return name !== void 0 && name !== null && name !== "";
  }
  function getPanelIndex(name) {
    return panels.findIndex((panel) => {
      return panel.props.name === name && panel.props.disable !== "" && panel.props.disable !== true;
    });
  }
  function getEnabledPanels() {
    return panels.filter((panel) => {
      return panel.props.disable !== "" && panel.props.disable !== true;
    });
  }
  function updatePanelTransition(direction) {
    const val = direction !== 0 && props.animated === true && panelIndex.value !== -1 ? "q-transition--" + (direction === -1 ? transitionPrev.value : transitionNext.value) : null;
    if (panelTransition.value !== val) {
      panelTransition.value = val;
    }
  }
  function goToPanelByOffset(direction, startIndex = panelIndex.value) {
    let index2 = startIndex + direction;
    while (index2 > -1 && index2 < panels.length) {
      const opt = panels[index2];
      if (opt !== void 0 && opt.props.disable !== "" && opt.props.disable !== true) {
        updatePanelTransition(direction);
        forcedPanelTransition = true;
        emit("update:modelValue", opt.props.name);
        setTimeout(() => {
          forcedPanelTransition = false;
        });
        return;
      }
      index2 += direction;
    }
    if (props.infinite === true && panels.length > 0 && startIndex !== -1 && startIndex !== panels.length) {
      goToPanelByOffset(direction, direction === -1 ? panels.length : -1);
    }
  }
  function updatePanelIndex() {
    const index2 = getPanelIndex(props.modelValue);
    if (panelIndex.value !== index2) {
      panelIndex.value = index2;
    }
    return true;
  }
  function getPanelContentChild() {
    const panel = isValidPanelName(props.modelValue) === true && updatePanelIndex() && panels[panelIndex.value];
    return props.keepAlive === true ? [
      h(KeepAlive, keepAliveProps.value, [
        h(
          needsUniqueKeepAliveWrapper.value === true ? getCacheWithFn(contentKey.value, () => ({ ...PanelWrapper, name: contentKey.value })) : PanelWrapper,
          { key: contentKey.value, style: transitionStyle.value },
          () => panel
        )
      ])
    ] : [
      h("div", {
        class: "q-panel scroll",
        style: transitionStyle.value,
        key: contentKey.value,
        role: "tabpanel"
      }, [panel])
    ];
  }
  function getPanelContent() {
    if (panels.length === 0) {
      return;
    }
    return props.animated === true ? [h(Transition, { name: panelTransition.value }, getPanelContentChild)] : getPanelContentChild();
  }
  function updatePanelsList(slots) {
    panels = getNormalizedVNodes(
      hSlot(slots.default, [])
    ).filter(
      (panel) => panel.props !== null && panel.props.slot === void 0 && isValidPanelName(panel.props.name) === true
    );
    return panels.length;
  }
  function getPanels() {
    return panels;
  }
  Object.assign(proxy, {
    next: nextPanel,
    previous: previousPanel,
    goTo: goToPanel
  });
  return {
    panelIndex,
    panelDirectives,
    updatePanelsList,
    updatePanelIndex,
    getPanelContent,
    getEnabledPanels,
    getPanels,
    isValidPanelName,
    keepAliveProps,
    needsUniqueKeepAliveWrapper,
    goToPanelByOffset,
    goToPanel,
    nextPanel,
    previousPanel
  };
}
const QTabPanel = createComponent({
  name: "QTabPanel",
  props: usePanelChildProps,
  setup(_, { slots }) {
    return () => h("div", { class: "q-tab-panel", role: "tabpanel" }, hSlot(slots.default));
  }
});
const QTabPanels = createComponent({
  name: "QTabPanels",
  props: {
    ...usePanelProps,
    ...useDarkProps
  },
  emits: usePanelEmits,
  setup(props, { slots }) {
    const vm = getCurrentInstance();
    const isDark = useDark(props, vm.proxy.$q);
    const { updatePanelsList, getPanelContent, panelDirectives } = usePanel();
    const classes = computed(
      () => "q-tab-panels q-panel-parent" + (isDark.value === true ? " q-tab-panels--dark q-dark" : "")
    );
    return () => {
      updatePanelsList(slots);
      return hDir(
        "div",
        { class: classes.value },
        getPanelContent(),
        "pan",
        props.swipeable,
        () => panelDirectives.value
      );
    };
  }
});
function getChanges(evt, ctx, isFinal) {
  const pos = position(evt);
  let dir, distX = pos.left - ctx.event.x, distY = pos.top - ctx.event.y, absX = Math.abs(distX), absY = Math.abs(distY);
  const direction = ctx.direction;
  if (direction.horizontal === true && direction.vertical !== true) {
    dir = distX < 0 ? "left" : "right";
  } else if (direction.horizontal !== true && direction.vertical === true) {
    dir = distY < 0 ? "up" : "down";
  } else if (direction.up === true && distY < 0) {
    dir = "up";
    if (absX > absY) {
      if (direction.left === true && distX < 0) {
        dir = "left";
      } else if (direction.right === true && distX > 0) {
        dir = "right";
      }
    }
  } else if (direction.down === true && distY > 0) {
    dir = "down";
    if (absX > absY) {
      if (direction.left === true && distX < 0) {
        dir = "left";
      } else if (direction.right === true && distX > 0) {
        dir = "right";
      }
    }
  } else if (direction.left === true && distX < 0) {
    dir = "left";
    if (absX < absY) {
      if (direction.up === true && distY < 0) {
        dir = "up";
      } else if (direction.down === true && distY > 0) {
        dir = "down";
      }
    }
  } else if (direction.right === true && distX > 0) {
    dir = "right";
    if (absX < absY) {
      if (direction.up === true && distY < 0) {
        dir = "up";
      } else if (direction.down === true && distY > 0) {
        dir = "down";
      }
    }
  }
  let synthetic = false;
  if (dir === void 0 && isFinal === false) {
    if (ctx.event.isFirst === true || ctx.event.lastDir === void 0) {
      return {};
    }
    dir = ctx.event.lastDir;
    synthetic = true;
    if (dir === "left" || dir === "right") {
      pos.left -= distX;
      absX = 0;
      distX = 0;
    } else {
      pos.top -= distY;
      absY = 0;
      distY = 0;
    }
  }
  return {
    synthetic,
    payload: {
      evt,
      touch: ctx.event.mouse !== true,
      mouse: ctx.event.mouse === true,
      position: pos,
      direction: dir,
      isFirst: ctx.event.isFirst,
      isFinal: isFinal === true,
      duration: Date.now() - ctx.event.time,
      distance: {
        x: absX,
        y: absY
      },
      offset: {
        x: distX,
        y: distY
      },
      delta: {
        x: pos.left - ctx.event.lastX,
        y: pos.top - ctx.event.lastY
      }
    }
  };
}
let uid = 0;
const TouchPan = createDirective(
  {
    name: "touch-pan",
    beforeMount(el, { value: value2, modifiers }) {
      if (modifiers.mouse !== true && client.has.touch !== true) {
        return;
      }
      function handleEvent2(evt, mouseEvent) {
        if (modifiers.mouse === true && mouseEvent === true) {
          stopAndPrevent(evt);
        } else {
          modifiers.stop === true && stop(evt);
          modifiers.prevent === true && prevent(evt);
        }
      }
      const ctx = {
        uid: "qvtp_" + uid++,
        handler: value2,
        modifiers,
        direction: getModifierDirections(modifiers),
        noop,
        mouseStart(evt) {
          if (shouldStart(evt, ctx) && leftClick(evt)) {
            addEvt(ctx, "temp", [
              [document, "mousemove", "move", "notPassiveCapture"],
              [document, "mouseup", "end", "passiveCapture"]
            ]);
            ctx.start(evt, true);
          }
        },
        touchStart(evt) {
          if (shouldStart(evt, ctx)) {
            const target2 = evt.target;
            addEvt(ctx, "temp", [
              [target2, "touchmove", "move", "notPassiveCapture"],
              [target2, "touchcancel", "end", "passiveCapture"],
              [target2, "touchend", "end", "passiveCapture"]
            ]);
            ctx.start(evt);
          }
        },
        start(evt, mouseEvent) {
          client.is.firefox === true && preventDraggable(el, true);
          ctx.lastEvt = evt;
          if (mouseEvent === true || modifiers.stop === true) {
            if (ctx.direction.all !== true && (mouseEvent !== true || ctx.modifiers.mouseAllDir !== true && ctx.modifiers.mousealldir !== true)) {
              const clone2 = evt.type.indexOf("mouse") > -1 ? new MouseEvent(evt.type, evt) : new TouchEvent(evt.type, evt);
              evt.defaultPrevented === true && prevent(clone2);
              evt.cancelBubble === true && stop(clone2);
              Object.assign(clone2, {
                qKeyEvent: evt.qKeyEvent,
                qClickOutside: evt.qClickOutside,
                qAnchorHandled: evt.qAnchorHandled,
                qClonedBy: evt.qClonedBy === void 0 ? [ctx.uid] : evt.qClonedBy.concat(ctx.uid)
              });
              ctx.initialEvent = {
                target: evt.target,
                event: clone2
              };
            }
            stop(evt);
          }
          const { left, top } = position(evt);
          ctx.event = {
            x: left,
            y: top,
            time: Date.now(),
            mouse: mouseEvent === true,
            detected: false,
            isFirst: true,
            isFinal: false,
            lastX: left,
            lastY: top
          };
        },
        move(evt) {
          if (ctx.event === void 0) {
            return;
          }
          const pos = position(evt), distX = pos.left - ctx.event.x, distY = pos.top - ctx.event.y;
          if (distX === 0 && distY === 0) {
            return;
          }
          ctx.lastEvt = evt;
          const isMouseEvt = ctx.event.mouse === true;
          const start = () => {
            handleEvent2(evt, isMouseEvt);
            let cursor;
            if (modifiers.preserveCursor !== true && modifiers.preservecursor !== true) {
              cursor = document.documentElement.style.cursor || "";
              document.documentElement.style.cursor = "grabbing";
            }
            isMouseEvt === true && document.body.classList.add("no-pointer-events--children");
            document.body.classList.add("non-selectable");
            clearSelection();
            ctx.styleCleanup = (withDelayedFn) => {
              ctx.styleCleanup = void 0;
              if (cursor !== void 0) {
                document.documentElement.style.cursor = cursor;
              }
              document.body.classList.remove("non-selectable");
              if (isMouseEvt === true) {
                const remove2 = () => {
                  document.body.classList.remove("no-pointer-events--children");
                };
                if (withDelayedFn !== void 0) {
                  setTimeout(() => {
                    remove2();
                    withDelayedFn();
                  }, 50);
                } else {
                  remove2();
                }
              } else if (withDelayedFn !== void 0) {
                withDelayedFn();
              }
            };
          };
          if (ctx.event.detected === true) {
            ctx.event.isFirst !== true && handleEvent2(evt, ctx.event.mouse);
            const { payload, synthetic } = getChanges(evt, ctx, false);
            if (payload !== void 0) {
              if (ctx.handler(payload) === false) {
                ctx.end(evt);
              } else {
                if (ctx.styleCleanup === void 0 && ctx.event.isFirst === true) {
                  start();
                }
                ctx.event.lastX = payload.position.left;
                ctx.event.lastY = payload.position.top;
                ctx.event.lastDir = synthetic === true ? void 0 : payload.direction;
                ctx.event.isFirst = false;
              }
            }
            return;
          }
          if (ctx.direction.all === true || isMouseEvt === true && (ctx.modifiers.mouseAllDir === true || ctx.modifiers.mousealldir === true)) {
            start();
            ctx.event.detected = true;
            ctx.move(evt);
            return;
          }
          const absX = Math.abs(distX), absY = Math.abs(distY);
          if (absX !== absY) {
            if (ctx.direction.horizontal === true && absX > absY || ctx.direction.vertical === true && absX < absY || ctx.direction.up === true && absX < absY && distY < 0 || ctx.direction.down === true && absX < absY && distY > 0 || ctx.direction.left === true && absX > absY && distX < 0 || ctx.direction.right === true && absX > absY && distX > 0) {
              ctx.event.detected = true;
              ctx.move(evt);
            } else {
              ctx.end(evt, true);
            }
          }
        },
        end(evt, abort) {
          if (ctx.event === void 0) {
            return;
          }
          cleanEvt(ctx, "temp");
          client.is.firefox === true && preventDraggable(el, false);
          if (abort === true) {
            ctx.styleCleanup !== void 0 && ctx.styleCleanup();
            if (ctx.event.detected !== true && ctx.initialEvent !== void 0) {
              ctx.initialEvent.target.dispatchEvent(ctx.initialEvent.event);
            }
          } else if (ctx.event.detected === true) {
            ctx.event.isFirst === true && ctx.handler(getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx).payload);
            const { payload } = getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx, true);
            const fn = () => {
              ctx.handler(payload);
            };
            if (ctx.styleCleanup !== void 0) {
              ctx.styleCleanup(fn);
            } else {
              fn();
            }
          }
          ctx.event = void 0;
          ctx.initialEvent = void 0;
          ctx.lastEvt = void 0;
        }
      };
      el.__qtouchpan = ctx;
      if (modifiers.mouse === true) {
        const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true ? "Capture" : "";
        addEvt(ctx, "main", [
          [el, "mousedown", "mouseStart", `passive${capture}`]
        ]);
      }
      client.has.touch === true && addEvt(ctx, "main", [
        [el, "touchstart", "touchStart", `passive${modifiers.capture === true ? "Capture" : ""}`],
        [el, "touchmove", "noop", "notPassiveCapture"]
      ]);
    },
    updated(el, bindings) {
      const ctx = el.__qtouchpan;
      if (ctx !== void 0) {
        if (bindings.oldValue !== bindings.value) {
          typeof value !== "function" && ctx.end();
          ctx.handler = bindings.value;
        }
        ctx.direction = getModifierDirections(bindings.modifiers);
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qtouchpan;
      if (ctx !== void 0) {
        ctx.event !== void 0 && ctx.end();
        cleanEvt(ctx, "main");
        cleanEvt(ctx, "temp");
        client.is.firefox === true && preventDraggable(el, false);
        ctx.styleCleanup !== void 0 && ctx.styleCleanup();
        delete el.__qtouchpan;
      }
    }
  }
);
const QSplitter = createComponent({
  name: "QSplitter",
  props: {
    ...useDarkProps,
    modelValue: {
      type: Number,
      required: true
    },
    reverse: Boolean,
    unit: {
      type: String,
      default: "%",
      validator: (v2) => ["%", "px"].includes(v2)
    },
    limits: {
      type: Array,
      validator: (v2) => {
        if (v2.length !== 2)
          return false;
        if (typeof v2[0] !== "number" || typeof v2[1] !== "number")
          return false;
        return v2[0] >= 0 && v2[0] <= v2[1];
      }
    },
    emitImmediately: Boolean,
    horizontal: Boolean,
    disable: Boolean,
    beforeClass: [Array, String, Object],
    afterClass: [Array, String, Object],
    separatorClass: [Array, String, Object],
    separatorStyle: [Array, String, Object]
  },
  emits: ["update:modelValue"],
  setup(props, { slots, emit }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = useDark(props, $q);
    const rootRef = ref(null);
    const sideRefs = {
      before: ref(null),
      after: ref(null)
    };
    const classes = computed(
      () => `q-splitter no-wrap ${props.horizontal === true ? "q-splitter--horizontal column" : "q-splitter--vertical row"} q-splitter--${props.disable === true ? "disabled" : "workable"}` + (isDark.value === true ? " q-splitter--dark" : "")
    );
    const propName = computed(() => props.horizontal === true ? "height" : "width");
    const side = computed(() => props.reverse !== true ? "before" : "after");
    const computedLimits = computed(() => props.limits !== void 0 ? props.limits : props.unit === "%" ? [10, 90] : [50, Infinity]);
    function getCSSValue(value2) {
      return (props.unit === "%" ? value2 : Math.round(value2)) + props.unit;
    }
    const styles = computed(() => ({
      [side.value]: {
        [propName.value]: getCSSValue(props.modelValue)
      }
    }));
    let __dir, __maxValue, __value, __multiplier, __normalized;
    function pan(evt) {
      if (evt.isFirst === true) {
        const size2 = rootRef.value.getBoundingClientRect()[propName.value];
        __dir = props.horizontal === true ? "up" : "left";
        __maxValue = props.unit === "%" ? 100 : size2;
        __value = Math.min(__maxValue, computedLimits.value[1], Math.max(computedLimits.value[0], props.modelValue));
        __multiplier = (props.reverse !== true ? 1 : -1) * (props.horizontal === true ? 1 : $q.lang.rtl === true ? -1 : 1) * (props.unit === "%" ? size2 === 0 ? 0 : 100 / size2 : 1);
        rootRef.value.classList.add("q-splitter--active");
        return;
      }
      if (evt.isFinal === true) {
        if (__normalized !== props.modelValue) {
          emit("update:modelValue", __normalized);
        }
        rootRef.value.classList.remove("q-splitter--active");
        return;
      }
      const val = __value + __multiplier * (evt.direction === __dir ? -1 : 1) * evt.distance[props.horizontal === true ? "y" : "x"];
      __normalized = Math.min(__maxValue, computedLimits.value[1], Math.max(computedLimits.value[0], val));
      sideRefs[side.value].value.style[propName.value] = getCSSValue(__normalized);
      if (props.emitImmediately === true && props.modelValue !== __normalized) {
        emit("update:modelValue", __normalized);
      }
    }
    const sepDirective = computed(() => {
      return [[
        TouchPan,
        pan,
        void 0,
        {
          [props.horizontal === true ? "vertical" : "horizontal"]: true,
          prevent: true,
          stop: true,
          mouse: true,
          mouseAllDir: true
        }
      ]];
    });
    function normalize(val, limits) {
      if (val < limits[0]) {
        emit("update:modelValue", limits[0]);
      } else if (val > limits[1]) {
        emit("update:modelValue", limits[1]);
      }
    }
    watch(() => props.modelValue, (v2) => {
      normalize(v2, computedLimits.value);
    });
    watch(() => props.limits, () => {
      nextTick(() => {
        normalize(props.modelValue, computedLimits.value);
      });
    });
    return () => {
      const child = [
        h("div", {
          ref: sideRefs.before,
          class: [
            "q-splitter__panel q-splitter__before" + (props.reverse === true ? " col" : ""),
            props.beforeClass
          ],
          style: styles.value.before
        }, hSlot(slots.before)),
        h("div", {
          class: [
            "q-splitter__separator",
            props.separatorClass
          ],
          style: props.separatorStyle,
          "aria-disabled": props.disable === true ? "true" : void 0
        }, [
          hDir(
            "div",
            { class: "q-splitter__separator-area absolute-full" },
            hSlot(slots.separator),
            "sep",
            props.disable !== true,
            () => sepDirective.value
          )
        ]),
        h("div", {
          ref: sideRefs.after,
          class: [
            "q-splitter__panel q-splitter__after" + (props.reverse === true ? "" : " col"),
            props.afterClass
          ],
          style: styles.value.after
        }, hSlot(slots.after))
      ];
      return h("div", {
        class: classes.value,
        ref: rootRef
      }, hMergeSlot(slots.default, child));
    };
  }
});
const trueFn = () => true;
function getEmitsObject(emitsArray) {
  const emitsObject = {};
  emitsArray.forEach((val) => {
    emitsObject[val] = trueFn;
  });
  return emitsObject;
}
function useDialogPluginComponent() {
  const { emit, proxy } = getCurrentInstance();
  const dialogRef = ref(null);
  function show() {
    dialogRef.value.show();
  }
  function hide() {
    dialogRef.value.hide();
  }
  function onDialogOK(payload) {
    emit("ok", payload);
    hide();
  }
  function onDialogHide() {
    emit("hide");
  }
  Object.assign(proxy, { show, hide });
  return {
    dialogRef,
    onDialogHide,
    onDialogOK,
    onDialogCancel: hide
  };
}
const emits = ["ok", "hide"];
useDialogPluginComponent.emits = emits;
useDialogPluginComponent.emitsObject = getEmitsObject(emits);
function errorNotification(error, quasar) {
  let text;
  if (error instanceof Error)
    text = error.message;
  else
    text = String(error);
  quasar.notify({
    message: text,
    color: "negative",
    closeBtn: true,
    timeout: 5e3
  });
}
const QField = createComponent({
  name: "QField",
  inheritAttrs: false,
  props: useFieldProps,
  emits: useFieldEmits,
  setup() {
    return useField(useFieldState());
  }
});
const defaultSizes = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
};
const QChip = createComponent({
  name: "QChip",
  props: {
    ...useDarkProps,
    ...useSizeProps,
    dense: Boolean,
    icon: String,
    iconRight: String,
    iconRemove: String,
    iconSelected: String,
    label: [String, Number],
    color: String,
    textColor: String,
    modelValue: {
      type: Boolean,
      default: true
    },
    selected: {
      type: Boolean,
      default: null
    },
    square: Boolean,
    outline: Boolean,
    clickable: Boolean,
    removable: Boolean,
    removeAriaLabel: String,
    tabindex: [String, Number],
    disable: Boolean,
    ripple: {
      type: [Boolean, Object],
      default: true
    }
  },
  emits: ["update:modelValue", "update:selected", "remove", "click"],
  setup(props, { slots, emit }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = useDark(props, $q);
    const sizeStyle = useSize(props, defaultSizes);
    const hasLeftIcon = computed(() => props.selected === true || props.icon !== void 0);
    const leftIcon = computed(() => props.selected === true ? props.iconSelected || $q.iconSet.chip.selected : props.icon);
    const removeIcon = computed(() => props.iconRemove || $q.iconSet.chip.remove);
    const isClickable = computed(
      () => props.disable === false && (props.clickable === true || props.selected !== null)
    );
    const classes = computed(() => {
      const text = props.outline === true ? props.color || props.textColor : props.textColor;
      return "q-chip row inline no-wrap items-center" + (props.outline === false && props.color !== void 0 ? ` bg-${props.color}` : "") + (text ? ` text-${text} q-chip--colored` : "") + (props.disable === true ? " disabled" : "") + (props.dense === true ? " q-chip--dense" : "") + (props.outline === true ? " q-chip--outline" : "") + (props.selected === true ? " q-chip--selected" : "") + (isClickable.value === true ? " q-chip--clickable cursor-pointer non-selectable q-hoverable" : "") + (props.square === true ? " q-chip--square" : "") + (isDark.value === true ? " q-chip--dark q-dark" : "");
    });
    const attributes = computed(() => {
      const chip = props.disable === true ? { tabindex: -1, "aria-disabled": "true" } : { tabindex: props.tabindex || 0 };
      const remove2 = {
        ...chip,
        role: "button",
        "aria-hidden": "false",
        "aria-label": props.removeAriaLabel || $q.lang.label.remove
      };
      return { chip, remove: remove2 };
    });
    function onKeyup2(e) {
      e.keyCode === 13 && onClick(e);
    }
    function onClick(e) {
      if (!props.disable) {
        emit("update:selected", !props.selected);
        emit("click", e);
      }
    }
    function onRemove(e) {
      if (e.keyCode === void 0 || e.keyCode === 13) {
        stopAndPrevent(e);
        if (props.disable === false) {
          emit("update:modelValue", false);
          emit("remove");
        }
      }
    }
    function getContent() {
      const child = [];
      isClickable.value === true && child.push(
        h("div", { class: "q-focus-helper" })
      );
      hasLeftIcon.value === true && child.push(
        h(QIcon, {
          class: "q-chip__icon q-chip__icon--left",
          name: leftIcon.value
        })
      );
      const label = props.label !== void 0 ? [h("div", { class: "ellipsis" }, [props.label])] : void 0;
      child.push(
        h("div", {
          class: "q-chip__content col row no-wrap items-center q-anchor--skip"
        }, hMergeSlotSafely(slots.default, label))
      );
      props.iconRight && child.push(
        h(QIcon, {
          class: "q-chip__icon q-chip__icon--right",
          name: props.iconRight
        })
      );
      props.removable === true && child.push(
        h(QIcon, {
          class: "q-chip__icon q-chip__icon--remove cursor-pointer",
          name: removeIcon.value,
          ...attributes.value.remove,
          onClick: onRemove,
          onKeyup: onRemove
        })
      );
      return child;
    }
    return () => {
      if (props.modelValue === false) {
        return;
      }
      const data = {
        class: classes.value,
        style: sizeStyle.value
      };
      isClickable.value === true && Object.assign(
        data,
        attributes.value.chip,
        { onClick, onKeyup: onKeyup2 }
      );
      return hDir(
        "div",
        data,
        getContent(),
        "ripple",
        props.ripple !== false && props.disable !== true,
        () => [[Ripple, props.ripple]]
      );
    };
  }
});
const QItem = createComponent({
  name: "QItem",
  props: {
    ...useDarkProps,
    ...useRouterLinkProps,
    tag: {
      type: String,
      default: "div"
    },
    active: {
      type: Boolean,
      default: null
    },
    clickable: Boolean,
    dense: Boolean,
    insetLevel: Number,
    tabindex: [String, Number],
    focused: Boolean,
    manualFocus: Boolean
  },
  emits: ["click", "keyup"],
  setup(props, { slots, emit }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = useDark(props, $q);
    const { hasLink, linkAttrs, linkClass, linkTag, navigateOnClick } = useRouterLink();
    const rootRef = ref(null);
    const blurTargetRef = ref(null);
    const isActionable = computed(
      () => props.clickable === true || hasLink.value === true || props.tag === "label"
    );
    const isClickable = computed(
      () => props.disable !== true && isActionable.value === true
    );
    const classes = computed(
      () => "q-item q-item-type row no-wrap" + (props.dense === true ? " q-item--dense" : "") + (isDark.value === true ? " q-item--dark" : "") + (hasLink.value === true && props.active === null ? linkClass.value : props.active === true ? ` q-item--active${props.activeClass !== void 0 ? ` ${props.activeClass}` : ""}` : "") + (props.disable === true ? " disabled" : "") + (isClickable.value === true ? " q-item--clickable q-link cursor-pointer " + (props.manualFocus === true ? "q-manual-focusable" : "q-focusable q-hoverable") + (props.focused === true ? " q-manual-focusable--focused" : "") : "")
    );
    const style = computed(() => {
      if (props.insetLevel === void 0) {
        return null;
      }
      const dir = $q.lang.rtl === true ? "Right" : "Left";
      return {
        ["padding" + dir]: 16 + props.insetLevel * 56 + "px"
      };
    });
    function onClick(e) {
      if (isClickable.value === true) {
        if (blurTargetRef.value !== null) {
          if (e.qKeyEvent !== true && document.activeElement === rootRef.value) {
            blurTargetRef.value.focus();
          } else if (document.activeElement === blurTargetRef.value) {
            rootRef.value.focus();
          }
        }
        navigateOnClick(e);
      }
    }
    function onKeyup2(e) {
      if (isClickable.value === true && isKeyCode(e, 13) === true) {
        stopAndPrevent(e);
        e.qKeyEvent = true;
        const evt = new MouseEvent("click", e);
        evt.qKeyEvent = true;
        rootRef.value.dispatchEvent(evt);
      }
      emit("keyup", e);
    }
    function getContent() {
      const child = hUniqueSlot(slots.default, []);
      isClickable.value === true && child.unshift(
        h("div", { class: "q-focus-helper", tabindex: -1, ref: blurTargetRef })
      );
      return child;
    }
    return () => {
      const data = {
        ref: rootRef,
        class: classes.value,
        style: style.value,
        role: "listitem",
        onClick,
        onKeyup: onKeyup2
      };
      if (isClickable.value === true) {
        data.tabindex = props.tabindex || "0";
        Object.assign(data, linkAttrs.value);
      } else if (isActionable.value === true) {
        data["aria-disabled"] = "true";
      }
      return h(
        linkTag.value,
        data,
        getContent()
      );
    };
  }
});
const QItemSection = createComponent({
  name: "QItemSection",
  props: {
    avatar: Boolean,
    thumbnail: Boolean,
    side: Boolean,
    top: Boolean,
    noWrap: Boolean
  },
  setup(props, { slots }) {
    const classes = computed(
      () => `q-item__section column q-item__section--${props.avatar === true || props.side === true || props.thumbnail === true ? "side" : "main"}` + (props.top === true ? " q-item__section--top justify-start" : " justify-center") + (props.avatar === true ? " q-item__section--avatar" : "") + (props.thumbnail === true ? " q-item__section--thumbnail" : "") + (props.noWrap === true ? " q-item__section--nowrap" : "")
    );
    return () => h("div", { class: classes.value }, hSlot(slots.default));
  }
});
const QItemLabel = createComponent({
  name: "QItemLabel",
  props: {
    overline: Boolean,
    caption: Boolean,
    header: Boolean,
    lines: [Number, String]
  },
  setup(props, { slots }) {
    const parsedLines = computed(() => parseInt(props.lines, 10));
    const classes = computed(
      () => "q-item__label" + (props.overline === true ? " q-item__label--overline text-overline" : "") + (props.caption === true ? " q-item__label--caption text-caption" : "") + (props.header === true ? " q-item__label--header" : "") + (parsedLines.value === 1 ? " ellipsis" : "")
    );
    const style = computed(() => {
      return props.lines !== void 0 && parsedLines.value > 1 ? {
        overflow: "hidden",
        display: "-webkit-box",
        "-webkit-box-orient": "vertical",
        "-webkit-line-clamp": parsedLines.value
      } : null;
    });
    return () => h("div", {
      style: style.value,
      class: classes.value
    }, hSlot(slots.default));
  }
});
const useAnchorProps = {
  target: {
    default: true
  },
  noParentEvent: Boolean,
  contextMenu: Boolean
};
function useAnchor({
  showing,
  avoidEmit,
  configureAnchorEl
}) {
  const { props, proxy, emit } = getCurrentInstance();
  const anchorEl = ref(null);
  let touchTimer;
  function canShow(evt) {
    return anchorEl.value === null ? false : evt === void 0 || evt.touches === void 0 || evt.touches.length <= 1;
  }
  const anchorEvents = {};
  if (configureAnchorEl === void 0) {
    Object.assign(anchorEvents, {
      hide(evt) {
        proxy.hide(evt);
      },
      toggle(evt) {
        proxy.toggle(evt);
        evt.qAnchorHandled = true;
      },
      toggleKey(evt) {
        isKeyCode(evt, 13) === true && anchorEvents.toggle(evt);
      },
      contextClick(evt) {
        proxy.hide(evt);
        prevent(evt);
        nextTick(() => {
          proxy.show(evt);
          evt.qAnchorHandled = true;
        });
      },
      prevent,
      mobileTouch(evt) {
        anchorEvents.mobileCleanup(evt);
        if (canShow(evt) !== true) {
          return;
        }
        proxy.hide(evt);
        anchorEl.value.classList.add("non-selectable");
        const target2 = evt.target;
        addEvt(anchorEvents, "anchor", [
          [target2, "touchmove", "mobileCleanup", "passive"],
          [target2, "touchend", "mobileCleanup", "passive"],
          [target2, "touchcancel", "mobileCleanup", "passive"],
          [anchorEl.value, "contextmenu", "prevent", "notPassive"]
        ]);
        touchTimer = setTimeout(() => {
          proxy.show(evt);
          evt.qAnchorHandled = true;
        }, 300);
      },
      mobileCleanup(evt) {
        anchorEl.value.classList.remove("non-selectable");
        clearTimeout(touchTimer);
        if (showing.value === true && evt !== void 0) {
          clearSelection();
        }
      }
    });
    configureAnchorEl = function(context = props.contextMenu) {
      if (props.noParentEvent === true || anchorEl.value === null) {
        return;
      }
      let evts;
      if (context === true) {
        if (proxy.$q.platform.is.mobile === true) {
          evts = [
            [anchorEl.value, "touchstart", "mobileTouch", "passive"]
          ];
        } else {
          evts = [
            [anchorEl.value, "mousedown", "hide", "passive"],
            [anchorEl.value, "contextmenu", "contextClick", "notPassive"]
          ];
        }
      } else {
        evts = [
          [anchorEl.value, "click", "toggle", "passive"],
          [anchorEl.value, "keyup", "toggleKey", "passive"]
        ];
      }
      addEvt(anchorEvents, "anchor", evts);
    };
  }
  function unconfigureAnchorEl() {
    cleanEvt(anchorEvents, "anchor");
  }
  function setAnchorEl(el) {
    anchorEl.value = el;
    while (anchorEl.value.classList.contains("q-anchor--skip")) {
      anchorEl.value = anchorEl.value.parentNode;
    }
    configureAnchorEl();
  }
  function pickAnchorEl() {
    if (props.target === false || props.target === "" || proxy.$el.parentNode === null) {
      anchorEl.value = null;
    } else if (props.target === true) {
      setAnchorEl(proxy.$el.parentNode);
    } else {
      let el = props.target;
      if (typeof props.target === "string") {
        try {
          el = document.querySelector(props.target);
        } catch (err) {
          el = void 0;
        }
      }
      if (el !== void 0 && el !== null) {
        anchorEl.value = el.$el || el;
        configureAnchorEl();
      } else {
        anchorEl.value = null;
        console.error(`Anchor: target "${props.target}" not found`);
      }
    }
  }
  watch(() => props.contextMenu, (val) => {
    if (anchorEl.value !== null) {
      unconfigureAnchorEl();
      configureAnchorEl(val);
    }
  });
  watch(() => props.target, () => {
    if (anchorEl.value !== null) {
      unconfigureAnchorEl();
    }
    pickAnchorEl();
  });
  watch(() => props.noParentEvent, (val) => {
    if (anchorEl.value !== null) {
      if (val === true) {
        unconfigureAnchorEl();
      } else {
        configureAnchorEl();
      }
    }
  });
  onMounted(() => {
    pickAnchorEl();
    if (avoidEmit !== true && props.modelValue === true && anchorEl.value === null) {
      emit("update:modelValue", false);
    }
  });
  onBeforeUnmount(() => {
    clearTimeout(touchTimer);
    unconfigureAnchorEl();
  });
  return {
    anchorEl,
    canShow,
    anchorEvents
  };
}
function useScrollTarget(props, configureScrollTarget) {
  const localScrollTarget = ref(null);
  let scrollFn;
  function changeScrollEvent(scrollTarget, fn) {
    const fnProp = `${fn !== void 0 ? "add" : "remove"}EventListener`;
    const fnHandler = fn !== void 0 ? fn : scrollFn;
    if (scrollTarget !== window) {
      scrollTarget[fnProp]("scroll", fnHandler, listenOpts.passive);
    }
    window[fnProp]("scroll", fnHandler, listenOpts.passive);
    scrollFn = fn;
  }
  function unconfigureScrollTarget() {
    if (localScrollTarget.value !== null) {
      changeScrollEvent(localScrollTarget.value);
      localScrollTarget.value = null;
    }
  }
  const noParentEventWatcher = watch(() => props.noParentEvent, () => {
    if (localScrollTarget.value !== null) {
      unconfigureScrollTarget();
      configureScrollTarget();
    }
  });
  onBeforeUnmount(noParentEventWatcher);
  return {
    localScrollTarget,
    unconfigureScrollTarget,
    changeScrollEvent
  };
}
let timer;
const { notPassiveCapture } = listenOpts, registeredList = [];
function globalHandler(evt) {
  clearTimeout(timer);
  const target2 = evt.target;
  if (target2 === void 0 || target2.nodeType === 8 || target2.classList.contains("no-pointer-events") === true) {
    return;
  }
  let portalIndex = portalProxyList.length - 1;
  while (portalIndex >= 0) {
    const proxy = portalProxyList[portalIndex].$;
    if (proxy.type.name !== "QDialog") {
      break;
    }
    if (proxy.props.seamless !== true) {
      return;
    }
    portalIndex--;
  }
  for (let i = registeredList.length - 1; i >= 0; i--) {
    const state = registeredList[i];
    if ((state.anchorEl.value === null || state.anchorEl.value.contains(target2) === false) && (target2 === document.body || state.innerRef.value !== null && state.innerRef.value.contains(target2) === false)) {
      evt.qClickOutside = true;
      state.onClickOutside(evt);
    } else {
      return;
    }
  }
}
function addClickOutside(clickOutsideProps) {
  registeredList.push(clickOutsideProps);
  if (registeredList.length === 1) {
    document.addEventListener("mousedown", globalHandler, notPassiveCapture);
    document.addEventListener("touchstart", globalHandler, notPassiveCapture);
  }
}
function removeClickOutside(clickOutsideProps) {
  const index2 = registeredList.findIndex((h2) => h2 === clickOutsideProps);
  if (index2 > -1) {
    registeredList.splice(index2, 1);
    if (registeredList.length === 0) {
      clearTimeout(timer);
      document.removeEventListener("mousedown", globalHandler, notPassiveCapture);
      document.removeEventListener("touchstart", globalHandler, notPassiveCapture);
    }
  }
}
let vpLeft, vpTop;
function validatePosition(pos) {
  const parts = pos.split(" ");
  if (parts.length !== 2) {
    return false;
  }
  if (["top", "center", "bottom"].includes(parts[0]) !== true) {
    console.error("Anchor/Self position must start with one of top/center/bottom");
    return false;
  }
  if (["left", "middle", "right", "start", "end"].includes(parts[1]) !== true) {
    console.error("Anchor/Self position must end with one of left/middle/right/start/end");
    return false;
  }
  return true;
}
function validateOffset(val) {
  if (!val) {
    return true;
  }
  if (val.length !== 2) {
    return false;
  }
  if (typeof val[0] !== "number" || typeof val[1] !== "number") {
    return false;
  }
  return true;
}
const horizontalPos = {
  "start#ltr": "left",
  "start#rtl": "right",
  "end#ltr": "right",
  "end#rtl": "left"
};
["left", "middle", "right"].forEach((pos) => {
  horizontalPos[`${pos}#ltr`] = pos;
  horizontalPos[`${pos}#rtl`] = pos;
});
function parsePosition(pos, rtl) {
  const parts = pos.split(" ");
  return {
    vertical: parts[0],
    horizontal: horizontalPos[`${parts[1]}#${rtl === true ? "rtl" : "ltr"}`]
  };
}
function getAnchorProps(el, offset) {
  let { top, left, right, bottom, width, height } = el.getBoundingClientRect();
  if (offset !== void 0) {
    top -= offset[1];
    left -= offset[0];
    bottom += offset[1];
    right += offset[0];
    width += offset[0];
    height += offset[1];
  }
  return {
    top,
    left,
    right,
    bottom,
    width,
    height,
    middle: left + (right - left) / 2,
    center: top + (bottom - top) / 2
  };
}
function getTargetProps(el) {
  return {
    top: 0,
    center: el.offsetHeight / 2,
    bottom: el.offsetHeight,
    left: 0,
    middle: el.offsetWidth / 2,
    right: el.offsetWidth
  };
}
function setPosition(cfg) {
  if (client.is.ios === true && window.visualViewport !== void 0) {
    const el = document.body.style;
    const { offsetLeft: left, offsetTop: top } = window.visualViewport;
    if (left !== vpLeft) {
      el.setProperty("--q-pe-left", left + "px");
      vpLeft = left;
    }
    if (top !== vpTop) {
      el.setProperty("--q-pe-top", top + "px");
      vpTop = top;
    }
  }
  let anchorProps;
  const { scrollLeft, scrollTop } = cfg.el;
  if (cfg.absoluteOffset === void 0) {
    anchorProps = getAnchorProps(cfg.anchorEl, cfg.cover === true ? [0, 0] : cfg.offset);
  } else {
    const { top: anchorTop, left: anchorLeft } = cfg.anchorEl.getBoundingClientRect(), top = anchorTop + cfg.absoluteOffset.top, left = anchorLeft + cfg.absoluteOffset.left;
    anchorProps = { top, left, width: 1, height: 1, right: left + 1, center: top, middle: left, bottom: top + 1 };
  }
  let elStyle = {
    maxHeight: cfg.maxHeight,
    maxWidth: cfg.maxWidth,
    visibility: "visible"
  };
  if (cfg.fit === true || cfg.cover === true) {
    elStyle.minWidth = anchorProps.width + "px";
    if (cfg.cover === true) {
      elStyle.minHeight = anchorProps.height + "px";
    }
  }
  Object.assign(cfg.el.style, elStyle);
  const targetProps = getTargetProps(cfg.el), props = {
    top: anchorProps[cfg.anchorOrigin.vertical] - targetProps[cfg.selfOrigin.vertical],
    left: anchorProps[cfg.anchorOrigin.horizontal] - targetProps[cfg.selfOrigin.horizontal]
  };
  applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);
  elStyle = {
    top: props.top + "px",
    left: props.left + "px"
  };
  if (props.maxHeight !== void 0) {
    elStyle.maxHeight = props.maxHeight + "px";
    if (anchorProps.height > props.maxHeight) {
      elStyle.minHeight = elStyle.maxHeight;
    }
  }
  if (props.maxWidth !== void 0) {
    elStyle.maxWidth = props.maxWidth + "px";
    if (anchorProps.width > props.maxWidth) {
      elStyle.minWidth = elStyle.maxWidth;
    }
  }
  Object.assign(cfg.el.style, elStyle);
  if (cfg.el.scrollTop !== scrollTop) {
    cfg.el.scrollTop = scrollTop;
  }
  if (cfg.el.scrollLeft !== scrollLeft) {
    cfg.el.scrollLeft = scrollLeft;
  }
}
function applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin) {
  const currentHeight = targetProps.bottom, currentWidth = targetProps.right, margin = getScrollbarWidth(), innerHeight = window.innerHeight - margin, innerWidth = document.body.clientWidth;
  if (props.top < 0 || props.top + currentHeight > innerHeight) {
    if (selfOrigin.vertical === "center") {
      props.top = anchorProps[anchorOrigin.vertical] > innerHeight / 2 ? Math.max(0, innerHeight - currentHeight) : 0;
      props.maxHeight = Math.min(currentHeight, innerHeight);
    } else if (anchorProps[anchorOrigin.vertical] > innerHeight / 2) {
      const anchorY = Math.min(
        innerHeight,
        anchorOrigin.vertical === "center" ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top
      );
      props.maxHeight = Math.min(currentHeight, anchorY);
      props.top = Math.max(0, anchorY - currentHeight);
    } else {
      props.top = Math.max(
        0,
        anchorOrigin.vertical === "center" ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom
      );
      props.maxHeight = Math.min(currentHeight, innerHeight - props.top);
    }
  }
  if (props.left < 0 || props.left + currentWidth > innerWidth) {
    props.maxWidth = Math.min(currentWidth, innerWidth);
    if (selfOrigin.horizontal === "middle") {
      props.left = anchorProps[anchorOrigin.horizontal] > innerWidth / 2 ? Math.max(0, innerWidth - currentWidth) : 0;
    } else if (anchorProps[anchorOrigin.horizontal] > innerWidth / 2) {
      const anchorX = Math.min(
        innerWidth,
        anchorOrigin.horizontal === "middle" ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left
      );
      props.maxWidth = Math.min(currentWidth, anchorX);
      props.left = Math.max(0, anchorX - props.maxWidth);
    } else {
      props.left = Math.max(
        0,
        anchorOrigin.horizontal === "middle" ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right
      );
      props.maxWidth = Math.min(currentWidth, innerWidth - props.left);
    }
  }
}
const QMenu = createComponent({
  name: "QMenu",
  inheritAttrs: false,
  props: {
    ...useAnchorProps,
    ...useModelToggleProps,
    ...useDarkProps,
    ...useTransitionProps,
    persistent: Boolean,
    autoClose: Boolean,
    separateClosePopup: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    fit: Boolean,
    cover: Boolean,
    square: Boolean,
    anchor: {
      type: String,
      validator: validatePosition
    },
    self: {
      type: String,
      validator: validatePosition
    },
    offset: {
      type: Array,
      validator: validateOffset
    },
    scrollTarget: {
      default: void 0
    },
    touchPosition: Boolean,
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    }
  },
  emits: [
    ...useModelToggleEmits,
    "click",
    "escapeKey"
  ],
  setup(props, { slots, emit, attrs }) {
    let refocusTarget = null, absoluteOffset, unwatchPosition, avoidAutoClose;
    const vm = getCurrentInstance();
    const { proxy } = vm;
    const { $q } = proxy;
    const innerRef = ref(null);
    const showing = ref(false);
    const hideOnRouteChange = computed(
      () => props.persistent !== true && props.noRouteDismiss !== true
    );
    const isDark = useDark(props, $q);
    const { registerTick, removeTick } = useTick();
    const { registerTimeout } = useTimeout();
    const { transitionProps, transitionStyle } = useTransition(props);
    const { localScrollTarget, changeScrollEvent, unconfigureScrollTarget } = useScrollTarget(props, configureScrollTarget);
    const { anchorEl, canShow } = useAnchor({ showing });
    const { hide } = useModelToggle({
      showing,
      canShow,
      handleShow,
      handleHide,
      hideOnRouteChange,
      processOnMount: true
    });
    const { showPortal, hidePortal, renderPortal } = usePortal(vm, innerRef, renderPortalContent);
    const clickOutsideProps = {
      anchorEl,
      innerRef,
      onClickOutside(e) {
        if (props.persistent !== true && showing.value === true) {
          hide(e);
          if (e.type === "touchstart" || e.target.classList.contains("q-dialog__backdrop")) {
            stopAndPrevent(e);
          }
          return true;
        }
      }
    };
    const anchorOrigin = computed(
      () => parsePosition(
        props.anchor || (props.cover === true ? "center middle" : "bottom start"),
        $q.lang.rtl
      )
    );
    const selfOrigin = computed(() => props.cover === true ? anchorOrigin.value : parsePosition(props.self || "top start", $q.lang.rtl));
    const menuClass = computed(
      () => (props.square === true ? " q-menu--square" : "") + (isDark.value === true ? " q-menu--dark q-dark" : "")
    );
    const onEvents = computed(() => props.autoClose === true ? { onClick: onAutoClose } : {});
    const handlesFocus = computed(
      () => showing.value === true && props.persistent !== true
    );
    watch(handlesFocus, (val) => {
      if (val === true) {
        addEscapeKey(onEscapeKey);
        addClickOutside(clickOutsideProps);
      } else {
        removeEscapeKey(onEscapeKey);
        removeClickOutside(clickOutsideProps);
      }
    });
    function focus() {
      addFocusFn(() => {
        let node = innerRef.value;
        if (node && node.contains(document.activeElement) !== true) {
          node = node.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || node.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || node.querySelector("[autofocus], [data-autofocus]") || node;
          node.focus({ preventScroll: true });
        }
      });
    }
    function handleShow(evt) {
      refocusTarget = props.noRefocus === false ? document.activeElement : null;
      addFocusout(onFocusout);
      showPortal();
      configureScrollTarget();
      absoluteOffset = void 0;
      if (evt !== void 0 && (props.touchPosition || props.contextMenu)) {
        const pos = position(evt);
        if (pos.left !== void 0) {
          const { top, left } = anchorEl.value.getBoundingClientRect();
          absoluteOffset = { left: pos.left - left, top: pos.top - top };
        }
      }
      if (unwatchPosition === void 0) {
        unwatchPosition = watch(
          () => $q.screen.width + "|" + $q.screen.height + "|" + props.self + "|" + props.anchor + "|" + $q.lang.rtl,
          updatePosition
        );
      }
      if (props.noFocus !== true) {
        document.activeElement.blur();
      }
      registerTick(() => {
        updatePosition();
        props.noFocus !== true && focus();
      });
      registerTimeout(() => {
        if ($q.platform.is.ios === true) {
          avoidAutoClose = props.autoClose;
          innerRef.value.click();
        }
        updatePosition();
        showPortal(true);
        emit("show", evt);
      }, props.transitionDuration);
    }
    function handleHide(evt) {
      removeTick();
      hidePortal();
      anchorCleanup(true);
      if (refocusTarget !== null && (evt === void 0 || evt.qClickOutside !== true)) {
        ((evt && evt.type.indexOf("key") === 0 ? refocusTarget.closest('[tabindex]:not([tabindex^="-"])') : void 0) || refocusTarget).focus();
        refocusTarget = null;
      }
      registerTimeout(() => {
        hidePortal(true);
        emit("hide", evt);
      }, props.transitionDuration);
    }
    function anchorCleanup(hiding) {
      absoluteOffset = void 0;
      if (unwatchPosition !== void 0) {
        unwatchPosition();
        unwatchPosition = void 0;
      }
      if (hiding === true || showing.value === true) {
        removeFocusout(onFocusout);
        unconfigureScrollTarget();
        removeClickOutside(clickOutsideProps);
        removeEscapeKey(onEscapeKey);
      }
      if (hiding !== true) {
        refocusTarget = null;
      }
    }
    function configureScrollTarget() {
      if (anchorEl.value !== null || props.scrollTarget !== void 0) {
        localScrollTarget.value = getScrollTarget(anchorEl.value, props.scrollTarget);
        changeScrollEvent(localScrollTarget.value, updatePosition);
      }
    }
    function onAutoClose(e) {
      if (avoidAutoClose !== true) {
        closePortalMenus(proxy, e);
        emit("click", e);
      } else {
        avoidAutoClose = false;
      }
    }
    function onFocusout(evt) {
      if (handlesFocus.value === true && props.noFocus !== true && childHasFocus(innerRef.value, evt.target) !== true) {
        focus();
      }
    }
    function onEscapeKey(evt) {
      emit("escapeKey");
      hide(evt);
    }
    function updatePosition() {
      const el = innerRef.value;
      if (el === null || anchorEl.value === null) {
        return;
      }
      setPosition({
        el,
        offset: props.offset,
        anchorEl: anchorEl.value,
        anchorOrigin: anchorOrigin.value,
        selfOrigin: selfOrigin.value,
        absoluteOffset,
        fit: props.fit,
        cover: props.cover,
        maxHeight: props.maxHeight,
        maxWidth: props.maxWidth
      });
    }
    function renderPortalContent() {
      return h(
        Transition,
        transitionProps.value,
        () => showing.value === true ? h("div", {
          role: "menu",
          ...attrs,
          ref: innerRef,
          tabindex: -1,
          class: [
            "q-menu q-position-engine scroll" + menuClass.value,
            attrs.class
          ],
          style: [
            attrs.style,
            transitionStyle.value
          ],
          ...onEvents.value
        }, hSlot(slots.default)) : null
      );
    }
    onBeforeUnmount(anchorCleanup);
    Object.assign(proxy, { focus, updatePosition });
    return renderPortal;
  }
});
const aggBucketSize = 1e3;
const scrollToEdges = [
  "start",
  "center",
  "end",
  "start-force",
  "center-force",
  "end-force"
];
const filterProto = Array.prototype.filter;
const setOverflowAnchor = window.getComputedStyle(document.body).overflowAnchor === void 0 ? noop : function(contentEl, index2) {
  if (contentEl === null) {
    return;
  }
  cancelAnimationFrame(contentEl._qOverflowAnimationFrame);
  contentEl._qOverflowAnimationFrame = requestAnimationFrame(() => {
    if (contentEl === null) {
      return;
    }
    const children = contentEl.children || [];
    filterProto.call(children, (el2) => el2.dataset && el2.dataset.qVsAnchor !== void 0).forEach((el2) => {
      delete el2.dataset.qVsAnchor;
    });
    const el = children[index2];
    if (el && el.dataset) {
      el.dataset.qVsAnchor = "";
    }
  });
};
function sumFn(acc, h2) {
  return acc + h2;
}
function getScrollDetails(parent, child, beforeRef, afterRef, horizontal, rtl, stickyStart, stickyEnd) {
  const parentCalc = parent === window ? document.scrollingElement || document.documentElement : parent, propElSize = horizontal === true ? "offsetWidth" : "offsetHeight", details = {
    scrollStart: 0,
    scrollViewSize: -stickyStart - stickyEnd,
    scrollMaxSize: 0,
    offsetStart: -stickyStart,
    offsetEnd: -stickyEnd
  };
  if (horizontal === true) {
    if (parent === window) {
      details.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0;
      details.scrollViewSize += document.documentElement.clientWidth;
    } else {
      details.scrollStart = parentCalc.scrollLeft;
      details.scrollViewSize += parentCalc.clientWidth;
    }
    details.scrollMaxSize = parentCalc.scrollWidth;
    if (rtl === true) {
      details.scrollStart = (rtlHasScrollBug === true ? details.scrollMaxSize - details.scrollViewSize : 0) - details.scrollStart;
    }
  } else {
    if (parent === window) {
      details.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0;
      details.scrollViewSize += document.documentElement.clientHeight;
    } else {
      details.scrollStart = parentCalc.scrollTop;
      details.scrollViewSize += parentCalc.clientHeight;
    }
    details.scrollMaxSize = parentCalc.scrollHeight;
  }
  if (beforeRef !== null) {
    for (let el = beforeRef.previousElementSibling; el !== null; el = el.previousElementSibling) {
      if (el.classList.contains("q-virtual-scroll--skip") === false) {
        details.offsetStart += el[propElSize];
      }
    }
  }
  if (afterRef !== null) {
    for (let el = afterRef.nextElementSibling; el !== null; el = el.nextElementSibling) {
      if (el.classList.contains("q-virtual-scroll--skip") === false) {
        details.offsetEnd += el[propElSize];
      }
    }
  }
  if (child !== parent) {
    const parentRect = parentCalc.getBoundingClientRect(), childRect = child.getBoundingClientRect();
    if (horizontal === true) {
      details.offsetStart += childRect.left - parentRect.left;
      details.offsetEnd -= childRect.width;
    } else {
      details.offsetStart += childRect.top - parentRect.top;
      details.offsetEnd -= childRect.height;
    }
    if (parent !== window) {
      details.offsetStart += details.scrollStart;
    }
    details.offsetEnd += details.scrollMaxSize - details.offsetStart;
  }
  return details;
}
function setScroll(parent, scroll, horizontal, rtl) {
  if (scroll === "end") {
    scroll = (parent === window ? document.body : parent)[horizontal === true ? "scrollWidth" : "scrollHeight"];
  }
  if (parent === window) {
    if (horizontal === true) {
      if (rtl === true) {
        scroll = (rtlHasScrollBug === true ? document.body.scrollWidth - document.documentElement.clientWidth : 0) - scroll;
      }
      window.scrollTo(scroll, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
    } else {
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, scroll);
    }
  } else if (horizontal === true) {
    if (rtl === true) {
      scroll = (rtlHasScrollBug === true ? parent.scrollWidth - parent.offsetWidth : 0) - scroll;
    }
    parent.scrollLeft = scroll;
  } else {
    parent.scrollTop = scroll;
  }
}
function sumSize(sizeAgg, size2, from, to) {
  if (from >= to) {
    return 0;
  }
  const lastTo = size2.length, fromAgg = Math.floor(from / aggBucketSize), toAgg = Math.floor((to - 1) / aggBucketSize) + 1;
  let total = sizeAgg.slice(fromAgg, toAgg).reduce(sumFn, 0);
  if (from % aggBucketSize !== 0) {
    total -= size2.slice(fromAgg * aggBucketSize, from).reduce(sumFn, 0);
  }
  if (to % aggBucketSize !== 0 && to !== lastTo) {
    total -= size2.slice(to, toAgg * aggBucketSize).reduce(sumFn, 0);
  }
  return total;
}
const commonVirtScrollProps = {
  virtualScrollSliceSize: {
    type: [Number, String],
    default: null
  },
  virtualScrollSliceRatioBefore: {
    type: [Number, String],
    default: 1
  },
  virtualScrollSliceRatioAfter: {
    type: [Number, String],
    default: 1
  },
  virtualScrollItemSize: {
    type: [Number, String],
    default: 24
  },
  virtualScrollStickySizeStart: {
    type: [Number, String],
    default: 0
  },
  virtualScrollStickySizeEnd: {
    type: [Number, String],
    default: 0
  },
  tableColspan: [Number, String]
};
const useVirtualScrollProps = {
  virtualScrollHorizontal: Boolean,
  onVirtualScroll: Function,
  ...commonVirtScrollProps
};
function useVirtualScroll({
  virtualScrollLength,
  getVirtualScrollTarget,
  getVirtualScrollEl,
  virtualScrollItemSizeComputed
}) {
  const vm = getCurrentInstance();
  const { props, emit, proxy } = vm;
  const { $q } = proxy;
  let prevScrollStart, prevToIndex, localScrollViewSize, virtualScrollSizesAgg = [], virtualScrollSizes;
  const virtualScrollPaddingBefore = ref(0);
  const virtualScrollPaddingAfter = ref(0);
  const virtualScrollSliceSizeComputed = ref({});
  const beforeRef = ref(null);
  const afterRef = ref(null);
  const contentRef = ref(null);
  const virtualScrollSliceRange = ref({ from: 0, to: 0 });
  const colspanAttr = computed(() => props.tableColspan !== void 0 ? props.tableColspan : 100);
  if (virtualScrollItemSizeComputed === void 0) {
    virtualScrollItemSizeComputed = computed(() => props.virtualScrollItemSize);
  }
  const needsReset = computed(() => virtualScrollItemSizeComputed.value + ";" + props.virtualScrollHorizontal);
  const needsSliceRecalc = computed(
    () => needsReset.value + ";" + props.virtualScrollSliceRatioBefore + ";" + props.virtualScrollSliceRatioAfter
  );
  watch(needsSliceRecalc, () => {
    setVirtualScrollSize();
  });
  watch(needsReset, reset);
  function reset() {
    localResetVirtualScroll(prevToIndex, true);
  }
  function refresh(toIndex) {
    localResetVirtualScroll(toIndex === void 0 ? prevToIndex : toIndex);
  }
  function scrollTo(toIndex, edge) {
    const scrollEl2 = getVirtualScrollTarget();
    if (scrollEl2 === void 0 || scrollEl2 === null || scrollEl2.nodeType === 8) {
      return;
    }
    const scrollDetails = getScrollDetails(
      scrollEl2,
      getVirtualScrollEl(),
      beforeRef.value,
      afterRef.value,
      props.virtualScrollHorizontal,
      $q.lang.rtl,
      props.virtualScrollStickySizeStart,
      props.virtualScrollStickySizeEnd
    );
    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);
    setVirtualScrollSliceRange(
      scrollEl2,
      scrollDetails,
      Math.min(virtualScrollLength.value - 1, Math.max(0, parseInt(toIndex, 10) || 0)),
      0,
      scrollToEdges.indexOf(edge) > -1 ? edge : prevToIndex > -1 && toIndex > prevToIndex ? "end" : "start"
    );
  }
  function localOnVirtualScrollEvt() {
    const scrollEl2 = getVirtualScrollTarget();
    if (scrollEl2 === void 0 || scrollEl2 === null || scrollEl2.nodeType === 8) {
      return;
    }
    const scrollDetails = getScrollDetails(
      scrollEl2,
      getVirtualScrollEl(),
      beforeRef.value,
      afterRef.value,
      props.virtualScrollHorizontal,
      $q.lang.rtl,
      props.virtualScrollStickySizeStart,
      props.virtualScrollStickySizeEnd
    ), listLastIndex = virtualScrollLength.value - 1, listEndOffset = scrollDetails.scrollMaxSize - scrollDetails.offsetStart - scrollDetails.offsetEnd - virtualScrollPaddingAfter.value;
    if (prevScrollStart === scrollDetails.scrollStart) {
      return;
    }
    if (scrollDetails.scrollMaxSize <= 0) {
      setVirtualScrollSliceRange(scrollEl2, scrollDetails, 0, 0);
      return;
    }
    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);
    updateVirtualScrollSizes(virtualScrollSliceRange.value.from);
    const scrollMaxStart = Math.floor(scrollDetails.scrollMaxSize - Math.max(scrollDetails.scrollViewSize, scrollDetails.offsetEnd) - Math.min(virtualScrollSizes[listLastIndex], scrollDetails.scrollViewSize / 2));
    if (scrollMaxStart > 0 && Math.ceil(scrollDetails.scrollStart) >= scrollMaxStart) {
      setVirtualScrollSliceRange(
        scrollEl2,
        scrollDetails,
        listLastIndex,
        scrollDetails.scrollMaxSize - scrollDetails.offsetEnd - virtualScrollSizesAgg.reduce(sumFn, 0)
      );
      return;
    }
    let toIndex = 0, listOffset = scrollDetails.scrollStart - scrollDetails.offsetStart, offset = listOffset;
    if (listOffset <= listEndOffset && listOffset + scrollDetails.scrollViewSize >= virtualScrollPaddingBefore.value) {
      listOffset -= virtualScrollPaddingBefore.value;
      toIndex = virtualScrollSliceRange.value.from;
      offset = listOffset;
    } else {
      for (let j2 = 0; listOffset >= virtualScrollSizesAgg[j2] && toIndex < listLastIndex; j2++) {
        listOffset -= virtualScrollSizesAgg[j2];
        toIndex += aggBucketSize;
      }
    }
    while (listOffset > 0 && toIndex < listLastIndex) {
      listOffset -= virtualScrollSizes[toIndex];
      if (listOffset > -scrollDetails.scrollViewSize) {
        toIndex++;
        offset = listOffset;
      } else {
        offset = virtualScrollSizes[toIndex] + listOffset;
      }
    }
    setVirtualScrollSliceRange(
      scrollEl2,
      scrollDetails,
      toIndex,
      offset
    );
  }
  function setVirtualScrollSliceRange(scrollEl2, scrollDetails, toIndex, offset, align) {
    const alignForce = typeof align === "string" && align.indexOf("-force") > -1;
    const alignEnd = alignForce === true ? align.replace("-force", "") : align;
    const alignRange = alignEnd !== void 0 ? alignEnd : "start";
    let from = Math.max(0, toIndex - virtualScrollSliceSizeComputed.value[alignRange]), to = from + virtualScrollSliceSizeComputed.value.total;
    if (to > virtualScrollLength.value) {
      to = virtualScrollLength.value;
      from = Math.max(0, to - virtualScrollSliceSizeComputed.value.total);
    }
    prevScrollStart = scrollDetails.scrollStart;
    const rangeChanged = from !== virtualScrollSliceRange.value.from || to !== virtualScrollSliceRange.value.to;
    if (rangeChanged === false && alignEnd === void 0) {
      emitScroll(toIndex);
      return;
    }
    const { activeElement } = document;
    const contentEl = contentRef.value;
    if (rangeChanged === true && contentEl !== null && contentEl !== activeElement && contentEl.contains(activeElement) === true) {
      contentEl.addEventListener("focusout", onBlurRefocusFn);
      setTimeout(() => {
        contentEl !== null && contentEl.removeEventListener("focusout", onBlurRefocusFn);
      });
    }
    setOverflowAnchor(contentEl, toIndex - from);
    const sizeBefore = alignEnd !== void 0 ? virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0) : 0;
    if (rangeChanged === true) {
      const tempTo = to >= virtualScrollSliceRange.value.from && from <= virtualScrollSliceRange.value.to ? virtualScrollSliceRange.value.to : to;
      virtualScrollSliceRange.value = { from, to: tempTo };
      virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, from);
      virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);
      requestAnimationFrame(() => {
        if (virtualScrollSliceRange.value.to !== to && prevScrollStart === scrollDetails.scrollStart) {
          virtualScrollSliceRange.value = { from: virtualScrollSliceRange.value.from, to };
          virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);
        }
      });
    }
    requestAnimationFrame(() => {
      if (prevScrollStart !== scrollDetails.scrollStart) {
        return;
      }
      if (rangeChanged === true) {
        updateVirtualScrollSizes(from);
      }
      const sizeAfter = virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0), posStart = sizeAfter + scrollDetails.offsetStart + virtualScrollPaddingBefore.value, posEnd = posStart + virtualScrollSizes[toIndex];
      let scrollPosition = posStart + offset;
      if (alignEnd !== void 0) {
        const sizeDiff = sizeAfter - sizeBefore;
        const scrollStart = scrollDetails.scrollStart + sizeDiff;
        scrollPosition = alignForce !== true && scrollStart < posStart && posEnd < scrollStart + scrollDetails.scrollViewSize ? scrollStart : alignEnd === "end" ? posEnd - scrollDetails.scrollViewSize : posStart - (alignEnd === "start" ? 0 : Math.round((scrollDetails.scrollViewSize - virtualScrollSizes[toIndex]) / 2));
      }
      prevScrollStart = scrollPosition;
      setScroll(
        scrollEl2,
        scrollPosition,
        props.virtualScrollHorizontal,
        $q.lang.rtl
      );
      emitScroll(toIndex);
    });
  }
  function updateVirtualScrollSizes(from) {
    const contentEl = contentRef.value;
    if (contentEl) {
      const children = filterProto.call(
        contentEl.children,
        (el) => el.classList && el.classList.contains("q-virtual-scroll--skip") === false
      ), childrenLength = children.length, sizeFn = props.virtualScrollHorizontal === true ? (el) => el.getBoundingClientRect().width : (el) => el.offsetHeight;
      let index2 = from, size2, diff;
      for (let i = 0; i < childrenLength; ) {
        size2 = sizeFn(children[i]);
        i++;
        while (i < childrenLength && children[i].classList.contains("q-virtual-scroll--with-prev") === true) {
          size2 += sizeFn(children[i]);
          i++;
        }
        diff = size2 - virtualScrollSizes[index2];
        if (diff !== 0) {
          virtualScrollSizes[index2] += diff;
          virtualScrollSizesAgg[Math.floor(index2 / aggBucketSize)] += diff;
        }
        index2++;
      }
    }
  }
  function onBlurRefocusFn() {
    contentRef.value !== null && contentRef.value !== void 0 && contentRef.value.focus();
  }
  function localResetVirtualScroll(toIndex, fullReset) {
    const defaultSize = 1 * virtualScrollItemSizeComputed.value;
    if (fullReset === true || Array.isArray(virtualScrollSizes) === false) {
      virtualScrollSizes = [];
    }
    const oldVirtualScrollSizesLength = virtualScrollSizes.length;
    virtualScrollSizes.length = virtualScrollLength.value;
    for (let i = virtualScrollLength.value - 1; i >= oldVirtualScrollSizesLength; i--) {
      virtualScrollSizes[i] = defaultSize;
    }
    const jMax = Math.floor((virtualScrollLength.value - 1) / aggBucketSize);
    virtualScrollSizesAgg = [];
    for (let j2 = 0; j2 <= jMax; j2++) {
      let size2 = 0;
      const iMax = Math.min((j2 + 1) * aggBucketSize, virtualScrollLength.value);
      for (let i = j2 * aggBucketSize; i < iMax; i++) {
        size2 += virtualScrollSizes[i];
      }
      virtualScrollSizesAgg.push(size2);
    }
    prevToIndex = -1;
    prevScrollStart = void 0;
    virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, virtualScrollSliceRange.value.from);
    virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, virtualScrollSliceRange.value.to, virtualScrollLength.value);
    if (toIndex >= 0) {
      updateVirtualScrollSizes(virtualScrollSliceRange.value.from);
      nextTick(() => {
        scrollTo(toIndex);
      });
    } else {
      onVirtualScrollEvt();
    }
  }
  function setVirtualScrollSize(scrollViewSize) {
    if (scrollViewSize === void 0 && typeof window !== "undefined") {
      const scrollEl2 = getVirtualScrollTarget();
      if (scrollEl2 !== void 0 && scrollEl2 !== null && scrollEl2.nodeType !== 8) {
        scrollViewSize = getScrollDetails(
          scrollEl2,
          getVirtualScrollEl(),
          beforeRef.value,
          afterRef.value,
          props.virtualScrollHorizontal,
          $q.lang.rtl,
          props.virtualScrollStickySizeStart,
          props.virtualScrollStickySizeEnd
        ).scrollViewSize;
      }
    }
    localScrollViewSize = scrollViewSize;
    const virtualScrollSliceRatioBefore = parseFloat(props.virtualScrollSliceRatioBefore) || 0;
    const virtualScrollSliceRatioAfter = parseFloat(props.virtualScrollSliceRatioAfter) || 0;
    const multiplier = 1 + virtualScrollSliceRatioBefore + virtualScrollSliceRatioAfter;
    const view = scrollViewSize === void 0 || scrollViewSize <= 0 ? 1 : Math.ceil(scrollViewSize / virtualScrollItemSizeComputed.value);
    const baseSize = Math.max(
      1,
      view,
      Math.ceil((props.virtualScrollSliceSize > 0 ? props.virtualScrollSliceSize : 10) / multiplier)
    );
    virtualScrollSliceSizeComputed.value = {
      total: Math.ceil(baseSize * multiplier),
      start: Math.ceil(baseSize * virtualScrollSliceRatioBefore),
      center: Math.ceil(baseSize * (0.5 + virtualScrollSliceRatioBefore)),
      end: Math.ceil(baseSize * (1 + virtualScrollSliceRatioBefore)),
      view
    };
  }
  function padVirtualScroll(tag, content) {
    const paddingSize = props.virtualScrollHorizontal === true ? "width" : "height";
    const style = {
      ["--q-virtual-scroll-item-" + paddingSize]: virtualScrollItemSizeComputed.value + "px"
    };
    return [
      tag === "tbody" ? h(tag, {
        class: "q-virtual-scroll__padding",
        key: "before",
        ref: beforeRef
      }, [
        h("tr", [
          h("td", {
            style: { [paddingSize]: `${virtualScrollPaddingBefore.value}px`, ...style },
            colspan: colspanAttr.value
          })
        ])
      ]) : h(tag, {
        class: "q-virtual-scroll__padding",
        key: "before",
        ref: beforeRef,
        style: { [paddingSize]: `${virtualScrollPaddingBefore.value}px`, ...style }
      }),
      h(tag, {
        class: "q-virtual-scroll__content",
        key: "content",
        ref: contentRef,
        tabindex: -1
      }, content.flat()),
      tag === "tbody" ? h(tag, {
        class: "q-virtual-scroll__padding",
        key: "after",
        ref: afterRef
      }, [
        h("tr", [
          h("td", {
            style: { [paddingSize]: `${virtualScrollPaddingAfter.value}px`, ...style },
            colspan: colspanAttr.value
          })
        ])
      ]) : h(tag, {
        class: "q-virtual-scroll__padding",
        key: "after",
        ref: afterRef,
        style: { [paddingSize]: `${virtualScrollPaddingAfter.value}px`, ...style }
      })
    ];
  }
  function emitScroll(index2) {
    if (prevToIndex !== index2) {
      props.onVirtualScroll !== void 0 && emit("virtualScroll", {
        index: index2,
        from: virtualScrollSliceRange.value.from,
        to: virtualScrollSliceRange.value.to - 1,
        direction: index2 < prevToIndex ? "decrease" : "increase",
        ref: proxy
      });
      prevToIndex = index2;
    }
  }
  setVirtualScrollSize();
  const onVirtualScrollEvt = debounce(
    localOnVirtualScrollEvt,
    $q.platform.is.ios === true ? 120 : 35
  );
  onBeforeMount(() => {
    setVirtualScrollSize();
  });
  let shouldActivate = false;
  onDeactivated(() => {
    shouldActivate = true;
  });
  onActivated(() => {
    if (shouldActivate !== true) {
      return;
    }
    const scrollEl2 = getVirtualScrollTarget();
    if (prevScrollStart !== void 0 && scrollEl2 !== void 0 && scrollEl2 !== null && scrollEl2.nodeType !== 8) {
      setScroll(
        scrollEl2,
        prevScrollStart,
        props.virtualScrollHorizontal,
        $q.lang.rtl
      );
    } else {
      scrollTo(prevToIndex);
    }
  });
  onBeforeUnmount(() => {
    onVirtualScrollEvt.cancel();
  });
  Object.assign(proxy, { scrollTo, reset, refresh });
  return {
    virtualScrollSliceRange,
    virtualScrollSliceSizeComputed,
    setVirtualScrollSize,
    onVirtualScrollEvt,
    localResetVirtualScroll,
    padVirtualScroll,
    scrollTo,
    reset,
    refresh
  };
}
function between(v2, min, max) {
  return max <= min ? min : Math.min(max, Math.max(min, v2));
}
function normalizeToInterval(v2, min, max) {
  if (max <= min) {
    return min;
  }
  const size2 = max - min + 1;
  let index2 = min + (v2 - min) % size2;
  if (index2 < min) {
    index2 = size2 + index2;
  }
  return index2 === 0 ? 0 : index2;
}
const validateNewValueMode = (v2) => ["add", "add-unique", "toggle"].includes(v2);
const reEscapeList = ".*+?^${}()|[]\\";
const fieldPropsList = Object.keys(useFieldProps);
const QSelect = createComponent({
  name: "QSelect",
  inheritAttrs: false,
  props: {
    ...useVirtualScrollProps,
    ...useFormProps,
    ...useFieldProps,
    modelValue: {
      required: true
    },
    multiple: Boolean,
    displayValue: [String, Number],
    displayValueHtml: Boolean,
    dropdownIcon: String,
    options: {
      type: Array,
      default: () => []
    },
    optionValue: [Function, String],
    optionLabel: [Function, String],
    optionDisable: [Function, String],
    hideSelected: Boolean,
    hideDropdownIcon: Boolean,
    fillInput: Boolean,
    maxValues: [Number, String],
    optionsDense: Boolean,
    optionsDark: {
      type: Boolean,
      default: null
    },
    optionsSelectedClass: String,
    optionsHtml: Boolean,
    optionsCover: Boolean,
    menuShrink: Boolean,
    menuAnchor: String,
    menuSelf: String,
    menuOffset: Array,
    popupContentClass: String,
    popupContentStyle: [String, Array, Object],
    useInput: Boolean,
    useChips: Boolean,
    newValueMode: {
      type: String,
      validator: validateNewValueMode
    },
    mapOptions: Boolean,
    emitValue: Boolean,
    inputDebounce: {
      type: [Number, String],
      default: 500
    },
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object],
    tabindex: {
      type: [String, Number],
      default: 0
    },
    autocomplete: String,
    transitionShow: String,
    transitionHide: String,
    transitionDuration: [String, Number],
    behavior: {
      type: String,
      validator: (v2) => ["default", "menu", "dialog"].includes(v2),
      default: "default"
    },
    virtualScrollItemSize: {
      type: [Number, String],
      default: void 0
    },
    onNewValue: Function,
    onFilter: Function
  },
  emits: [
    ...useFieldEmits,
    "add",
    "remove",
    "inputValue",
    "newValue",
    "keyup",
    "keypress",
    "keydown",
    "filterAbort"
  ],
  setup(props, { slots, emit }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const menu = ref(false);
    const dialog = ref(false);
    const optionIndex = ref(-1);
    const inputValue = ref("");
    const dialogFieldFocused = ref(false);
    const innerLoadingIndicator = ref(false);
    let inputTimer, innerValueCache, hasDialog, userInputValue, filterId, defaultInputValue, transitionShowComputed, searchBuffer, searchBufferExp;
    const inputRef = ref(null);
    const targetRef = ref(null);
    const menuRef = ref(null);
    const dialogRef = ref(null);
    const menuContentRef = ref(null);
    const nameProp = useFormInputNameAttr(props);
    const onComposition = useKeyComposition(onInput);
    const virtualScrollLength = computed(() => Array.isArray(props.options) ? props.options.length : 0);
    const virtualScrollItemSizeComputed = computed(() => props.virtualScrollItemSize === void 0 ? props.optionsDense === true ? 24 : 48 : props.virtualScrollItemSize);
    const {
      virtualScrollSliceRange,
      virtualScrollSliceSizeComputed,
      localResetVirtualScroll,
      padVirtualScroll,
      onVirtualScrollEvt,
      scrollTo,
      setVirtualScrollSize
    } = useVirtualScroll({
      virtualScrollLength,
      getVirtualScrollTarget,
      getVirtualScrollEl,
      virtualScrollItemSizeComputed
    });
    const state = useFieldState();
    const innerValue = computed(() => {
      const mapNull = props.mapOptions === true && props.multiple !== true, val = props.modelValue !== void 0 && (props.modelValue !== null || mapNull === true) ? props.multiple === true && Array.isArray(props.modelValue) ? props.modelValue : [props.modelValue] : [];
      if (props.mapOptions === true && Array.isArray(props.options) === true) {
        const cache = props.mapOptions === true && innerValueCache !== void 0 ? innerValueCache : [];
        const values = val.map((v2) => getOption(v2, cache));
        return props.modelValue === null && mapNull === true ? values.filter((v2) => v2 !== null) : values;
      }
      return val;
    });
    const innerFieldProps = computed(() => {
      const acc = {};
      fieldPropsList.forEach((key) => {
        const val = props[key];
        if (val !== void 0) {
          acc[key] = val;
        }
      });
      return acc;
    });
    const isOptionsDark = computed(() => props.optionsDark === null ? state.isDark.value : props.optionsDark);
    const hasValue = computed(() => fieldValueIsFilled(innerValue.value));
    const computedInputClass = computed(() => {
      let cls = "q-field__input q-placeholder col";
      if (props.hideSelected === true || innerValue.value.length === 0) {
        return [cls, props.inputClass];
      }
      cls += " q-field__input--padding";
      return props.inputClass === void 0 ? cls : [cls, props.inputClass];
    });
    const menuContentClass = computed(
      () => (props.virtualScrollHorizontal === true ? "q-virtual-scroll--horizontal" : "") + (props.popupContentClass ? " " + props.popupContentClass : "")
    );
    const noOptions = computed(() => virtualScrollLength.value === 0);
    const selectedString = computed(
      () => innerValue.value.map((opt) => getOptionLabel.value(opt)).join(", ")
    );
    const ariaCurrentValue = computed(() => props.displayValue !== void 0 ? props.displayValue : selectedString.value);
    const needsHtmlFn = computed(() => props.optionsHtml === true ? () => true : (opt) => opt !== void 0 && opt !== null && opt.html === true);
    const valueAsHtml = computed(() => props.displayValueHtml === true || props.displayValue === void 0 && (props.optionsHtml === true || innerValue.value.some(needsHtmlFn.value)));
    const tabindex = computed(() => state.focused.value === true ? props.tabindex : -1);
    const comboboxAttrs = computed(() => {
      const attrs = {
        tabindex: props.tabindex,
        role: "combobox",
        "aria-label": props.label,
        "aria-readonly": props.readonly === true ? "true" : "false",
        "aria-autocomplete": props.useInput === true ? "list" : "none",
        "aria-expanded": menu.value === true ? "true" : "false",
        "aria-controls": `${state.targetUid.value}_lb`
      };
      if (optionIndex.value >= 0) {
        attrs["aria-activedescendant"] = `${state.targetUid.value}_${optionIndex.value}`;
      }
      return attrs;
    });
    const listboxAttrs = computed(() => ({
      id: `${state.targetUid.value}_lb`,
      role: "listbox",
      "aria-multiselectable": props.multiple === true ? "true" : "false"
    }));
    const selectedScope = computed(() => {
      return innerValue.value.map((opt, i) => ({
        index: i,
        opt,
        html: needsHtmlFn.value(opt),
        selected: true,
        removeAtIndex: removeAtIndexAndFocus,
        toggleOption,
        tabindex: tabindex.value
      }));
    });
    const optionScope = computed(() => {
      if (virtualScrollLength.value === 0) {
        return [];
      }
      const { from, to } = virtualScrollSliceRange.value;
      return props.options.slice(from, to).map((opt, i) => {
        const disable = isOptionDisabled.value(opt) === true;
        const index2 = from + i;
        const itemProps = {
          clickable: true,
          active: false,
          activeClass: computedOptionsSelectedClass.value,
          manualFocus: true,
          focused: false,
          disable,
          tabindex: -1,
          dense: props.optionsDense,
          dark: isOptionsDark.value,
          role: "option",
          id: `${state.targetUid.value}_${index2}`,
          onClick: () => {
            toggleOption(opt);
          }
        };
        if (disable !== true) {
          isOptionSelected(opt) === true && (itemProps.active = true);
          optionIndex.value === index2 && (itemProps.focused = true);
          itemProps["aria-selected"] = itemProps.active === true ? "true" : "false";
          if ($q.platform.is.desktop === true) {
            itemProps.onMousemove = () => {
              menu.value === true && setOptionIndex(index2);
            };
          }
        }
        return {
          index: index2,
          opt,
          html: needsHtmlFn.value(opt),
          label: getOptionLabel.value(opt),
          selected: itemProps.active,
          focused: itemProps.focused,
          toggleOption,
          setOptionIndex,
          itemProps
        };
      });
    });
    const dropdownArrowIcon = computed(() => props.dropdownIcon !== void 0 ? props.dropdownIcon : $q.iconSet.arrow.dropdown);
    const squaredMenu = computed(
      () => props.optionsCover === false && props.outlined !== true && props.standout !== true && props.borderless !== true && props.rounded !== true
    );
    const computedOptionsSelectedClass = computed(() => props.optionsSelectedClass !== void 0 ? props.optionsSelectedClass : props.color !== void 0 ? `text-${props.color}` : "");
    const getOptionValue = computed(() => getPropValueFn(props.optionValue, "value"));
    const getOptionLabel = computed(() => getPropValueFn(props.optionLabel, "label"));
    const isOptionDisabled = computed(() => getPropValueFn(props.optionDisable, "disable"));
    const innerOptionsValue = computed(() => innerValue.value.map((opt) => getOptionValue.value(opt)));
    const inputControlEvents = computed(() => {
      const evt = {
        onInput,
        onChange: onComposition,
        onKeydown: onTargetKeydown,
        onKeyup: onTargetAutocomplete,
        onKeypress: onTargetKeypress,
        onFocus: selectInputText,
        onClick(e) {
          hasDialog === true && stop(e);
        }
      };
      evt.onCompositionstart = evt.onCompositionupdate = evt.onCompositionend = onComposition;
      return evt;
    });
    watch(innerValue, (val) => {
      innerValueCache = val;
      if (props.useInput === true && props.fillInput === true && props.multiple !== true && state.innerLoading.value !== true && (dialog.value !== true && menu.value !== true || hasValue.value !== true)) {
        userInputValue !== true && resetInputValue();
        if (dialog.value === true || menu.value === true) {
          filter2("");
        }
      }
    }, { immediate: true });
    watch(() => props.fillInput, resetInputValue);
    watch(menu, updateMenu);
    watch(virtualScrollLength, rerenderMenu);
    function getEmittingOptionValue(opt) {
      return props.emitValue === true ? getOptionValue.value(opt) : opt;
    }
    function removeAtIndex(index2) {
      if (index2 > -1 && index2 < innerValue.value.length) {
        if (props.multiple === true) {
          const model = props.modelValue.slice();
          emit("remove", { index: index2, value: model.splice(index2, 1)[0] });
          emit("update:modelValue", model);
        } else {
          emit("update:modelValue", null);
        }
      }
    }
    function removeAtIndexAndFocus(index2) {
      removeAtIndex(index2);
      state.focus();
    }
    function add2(opt, unique) {
      const val = getEmittingOptionValue(opt);
      if (props.multiple !== true) {
        props.fillInput === true && updateInputValue(
          getOptionLabel.value(opt),
          true,
          true
        );
        emit("update:modelValue", val);
        return;
      }
      if (innerValue.value.length === 0) {
        emit("add", { index: 0, value: val });
        emit("update:modelValue", props.multiple === true ? [val] : val);
        return;
      }
      if (unique === true && isOptionSelected(opt) === true) {
        return;
      }
      if (props.maxValues !== void 0 && props.modelValue.length >= props.maxValues) {
        return;
      }
      const model = props.modelValue.slice();
      emit("add", { index: model.length, value: val });
      model.push(val);
      emit("update:modelValue", model);
    }
    function toggleOption(opt, keepOpen) {
      if (state.editable.value !== true || opt === void 0 || isOptionDisabled.value(opt) === true) {
        return;
      }
      const optValue = getOptionValue.value(opt);
      if (props.multiple !== true) {
        if (keepOpen !== true) {
          updateInputValue(
            props.fillInput === true ? getOptionLabel.value(opt) : "",
            true,
            true
          );
          hidePopup();
        }
        targetRef.value !== null && targetRef.value.focus();
        if (innerValue.value.length === 0 || isDeepEqual(getOptionValue.value(innerValue.value[0]), optValue) !== true) {
          emit("update:modelValue", props.emitValue === true ? optValue : opt);
        }
        return;
      }
      (hasDialog !== true || dialogFieldFocused.value === true) && state.focus();
      selectInputText();
      if (innerValue.value.length === 0) {
        const val = props.emitValue === true ? optValue : opt;
        emit("add", { index: 0, value: val });
        emit("update:modelValue", props.multiple === true ? [val] : val);
        return;
      }
      const model = props.modelValue.slice(), index2 = innerOptionsValue.value.findIndex((v2) => isDeepEqual(v2, optValue));
      if (index2 > -1) {
        emit("remove", { index: index2, value: model.splice(index2, 1)[0] });
      } else {
        if (props.maxValues !== void 0 && model.length >= props.maxValues) {
          return;
        }
        const val = props.emitValue === true ? optValue : opt;
        emit("add", { index: model.length, value: val });
        model.push(val);
      }
      emit("update:modelValue", model);
    }
    function setOptionIndex(index2) {
      if ($q.platform.is.desktop !== true) {
        return;
      }
      const val = index2 > -1 && index2 < virtualScrollLength.value ? index2 : -1;
      if (optionIndex.value !== val) {
        optionIndex.value = val;
      }
    }
    function moveOptionSelection(offset = 1, skipInputValue) {
      if (menu.value === true) {
        let index2 = optionIndex.value;
        do {
          index2 = normalizeToInterval(
            index2 + offset,
            -1,
            virtualScrollLength.value - 1
          );
        } while (index2 !== -1 && index2 !== optionIndex.value && isOptionDisabled.value(props.options[index2]) === true);
        if (optionIndex.value !== index2) {
          setOptionIndex(index2);
          scrollTo(index2);
          if (skipInputValue !== true && props.useInput === true && props.fillInput === true) {
            setInputValue(
              index2 >= 0 ? getOptionLabel.value(props.options[index2]) : defaultInputValue
            );
          }
        }
      }
    }
    function getOption(value2, valueCache) {
      const fn = (opt) => isDeepEqual(getOptionValue.value(opt), value2);
      return props.options.find(fn) || valueCache.find(fn) || value2;
    }
    function getPropValueFn(propValue, defaultVal) {
      const val = propValue !== void 0 ? propValue : defaultVal;
      return typeof val === "function" ? val : (opt) => opt !== null && typeof opt === "object" && val in opt ? opt[val] : opt;
    }
    function isOptionSelected(opt) {
      const val = getOptionValue.value(opt);
      return innerOptionsValue.value.find((v2) => isDeepEqual(v2, val)) !== void 0;
    }
    function selectInputText(e) {
      if (props.useInput === true && targetRef.value !== null && (e === void 0 || targetRef.value === e.target && e.target.value === selectedString.value)) {
        targetRef.value.select();
      }
    }
    function onTargetKeyup(e) {
      if (isKeyCode(e, 27) === true && menu.value === true) {
        stop(e);
        hidePopup();
        resetInputValue();
      }
      emit("keyup", e);
    }
    function onTargetAutocomplete(e) {
      const { value: value2 } = e.target;
      if (e.keyCode !== void 0) {
        onTargetKeyup(e);
        return;
      }
      e.target.value = "";
      clearTimeout(inputTimer);
      resetInputValue();
      if (typeof value2 === "string" && value2.length > 0) {
        const needle = value2.toLocaleLowerCase();
        const findFn = (extractFn) => {
          const option2 = props.options.find((opt) => extractFn.value(opt).toLocaleLowerCase() === needle);
          if (option2 === void 0) {
            return false;
          }
          if (innerValue.value.indexOf(option2) === -1) {
            toggleOption(option2);
          } else {
            hidePopup();
          }
          return true;
        };
        const fillFn = (afterFilter) => {
          if (findFn(getOptionValue) === true) {
            return;
          }
          if (findFn(getOptionLabel) === true || afterFilter === true) {
            return;
          }
          filter2(value2, true, () => fillFn(true));
        };
        fillFn();
      } else {
        state.clearValue(e);
      }
    }
    function onTargetKeypress(e) {
      emit("keypress", e);
    }
    function onTargetKeydown(e) {
      emit("keydown", e);
      if (shouldIgnoreKey(e) === true) {
        return;
      }
      const newValueModeValid = inputValue.value.length > 0 && (props.newValueMode !== void 0 || props.onNewValue !== void 0);
      const tabShouldSelect = e.shiftKey !== true && props.multiple !== true && (optionIndex.value > -1 || newValueModeValid === true);
      if (e.keyCode === 27) {
        prevent(e);
        return;
      }
      if (e.keyCode === 9 && tabShouldSelect === false) {
        closeMenu();
        return;
      }
      if (e.target === void 0 || e.target.id !== state.targetUid.value) {
        return;
      }
      if (e.keyCode === 40 && state.innerLoading.value !== true && menu.value === false) {
        stopAndPrevent(e);
        showPopup();
        return;
      }
      if (e.keyCode === 8 && props.hideSelected !== true && inputValue.value.length === 0) {
        if (props.multiple === true && Array.isArray(props.modelValue) === true) {
          removeAtIndex(props.modelValue.length - 1);
        } else if (props.multiple !== true && props.modelValue !== null) {
          emit("update:modelValue", null);
        }
        return;
      }
      if ((e.keyCode === 35 || e.keyCode === 36) && (typeof inputValue.value !== "string" || inputValue.value.length === 0)) {
        stopAndPrevent(e);
        optionIndex.value = -1;
        moveOptionSelection(e.keyCode === 36 ? 1 : -1, props.multiple);
      }
      if ((e.keyCode === 33 || e.keyCode === 34) && virtualScrollSliceSizeComputed.value !== void 0) {
        stopAndPrevent(e);
        optionIndex.value = Math.max(
          -1,
          Math.min(
            virtualScrollLength.value,
            optionIndex.value + (e.keyCode === 33 ? -1 : 1) * virtualScrollSliceSizeComputed.value.view
          )
        );
        moveOptionSelection(e.keyCode === 33 ? 1 : -1, props.multiple);
      }
      if (e.keyCode === 38 || e.keyCode === 40) {
        stopAndPrevent(e);
        moveOptionSelection(e.keyCode === 38 ? -1 : 1, props.multiple);
      }
      const optionsLength = virtualScrollLength.value;
      if (searchBuffer === void 0 || searchBufferExp < Date.now()) {
        searchBuffer = "";
      }
      if (optionsLength > 0 && props.useInput !== true && e.key !== void 0 && e.key.length === 1 && e.altKey === false && e.ctrlKey === false && e.metaKey === false && (e.keyCode !== 32 || searchBuffer.length > 0)) {
        menu.value !== true && showPopup(e);
        const char = e.key.toLocaleLowerCase(), keyRepeat = searchBuffer.length === 1 && searchBuffer[0] === char;
        searchBufferExp = Date.now() + 1500;
        if (keyRepeat === false) {
          stopAndPrevent(e);
          searchBuffer += char;
        }
        const searchRe = new RegExp("^" + searchBuffer.split("").map((l) => reEscapeList.indexOf(l) > -1 ? "\\" + l : l).join(".*"), "i");
        let index2 = optionIndex.value;
        if (keyRepeat === true || index2 < 0 || searchRe.test(getOptionLabel.value(props.options[index2])) !== true) {
          do {
            index2 = normalizeToInterval(index2 + 1, -1, optionsLength - 1);
          } while (index2 !== optionIndex.value && (isOptionDisabled.value(props.options[index2]) === true || searchRe.test(getOptionLabel.value(props.options[index2])) !== true));
        }
        if (optionIndex.value !== index2) {
          nextTick(() => {
            setOptionIndex(index2);
            scrollTo(index2);
            if (index2 >= 0 && props.useInput === true && props.fillInput === true) {
              setInputValue(getOptionLabel.value(props.options[index2]));
            }
          });
        }
        return;
      }
      if (e.keyCode !== 13 && (e.keyCode !== 32 || props.useInput === true || searchBuffer !== "") && (e.keyCode !== 9 || tabShouldSelect === false)) {
        return;
      }
      e.keyCode !== 9 && stopAndPrevent(e);
      if (optionIndex.value > -1 && optionIndex.value < optionsLength) {
        toggleOption(props.options[optionIndex.value]);
        return;
      }
      if (newValueModeValid === true) {
        const done = (val, mode) => {
          if (mode) {
            if (validateNewValueMode(mode) !== true) {
              return;
            }
          } else {
            mode = props.newValueMode;
          }
          if (val === void 0 || val === null) {
            return;
          }
          updateInputValue("", props.multiple !== true, true);
          const fn = mode === "toggle" ? toggleOption : add2;
          fn(val, mode === "add-unique");
          if (props.multiple !== true) {
            targetRef.value !== null && targetRef.value.focus();
            hidePopup();
          }
        };
        if (props.onNewValue !== void 0) {
          emit("newValue", inputValue.value, done);
        } else {
          done(inputValue.value);
        }
        if (props.multiple !== true) {
          return;
        }
      }
      if (menu.value === true) {
        closeMenu();
      } else if (state.innerLoading.value !== true) {
        showPopup();
      }
    }
    function getVirtualScrollEl() {
      return hasDialog === true ? menuContentRef.value : menuRef.value !== null && menuRef.value.contentEl !== null ? menuRef.value.contentEl : void 0;
    }
    function getVirtualScrollTarget() {
      return getVirtualScrollEl();
    }
    function getSelection() {
      if (props.hideSelected === true) {
        return [];
      }
      if (slots["selected-item"] !== void 0) {
        return selectedScope.value.map((scope) => slots["selected-item"](scope)).slice();
      }
      if (slots.selected !== void 0) {
        return [].concat(slots.selected());
      }
      if (props.useChips === true) {
        return selectedScope.value.map((scope, i) => h(QChip, {
          key: "option-" + i,
          removable: state.editable.value === true && isOptionDisabled.value(scope.opt) !== true,
          dense: true,
          textColor: props.color,
          tabindex: tabindex.value,
          onRemove() {
            scope.removeAtIndex(i);
          }
        }, () => h("span", {
          class: "ellipsis",
          [scope.html === true ? "innerHTML" : "textContent"]: getOptionLabel.value(scope.opt)
        })));
      }
      return [
        h("span", {
          [valueAsHtml.value === true ? "innerHTML" : "textContent"]: ariaCurrentValue.value
        })
      ];
    }
    function getAllOptions() {
      if (noOptions.value === true) {
        return slots["no-option"] !== void 0 ? slots["no-option"]({ inputValue: inputValue.value }) : void 0;
      }
      const fn = slots.option !== void 0 ? slots.option : (scope) => {
        return h(QItem, {
          key: scope.index,
          ...scope.itemProps
        }, () => {
          return h(
            QItemSection,
            () => h(
              QItemLabel,
              () => h("span", {
                [scope.html === true ? "innerHTML" : "textContent"]: scope.label
              })
            )
          );
        });
      };
      let options = padVirtualScroll("div", optionScope.value.map(fn));
      if (slots["before-options"] !== void 0) {
        options = slots["before-options"]().concat(options);
      }
      return hMergeSlot(slots["after-options"], options);
    }
    function getInput(fromDialog, isTarget) {
      const attrs = isTarget === true ? { ...comboboxAttrs.value, ...state.splitAttrs.attributes.value } : void 0;
      const data = {
        ref: isTarget === true ? targetRef : void 0,
        key: "i_t",
        class: computedInputClass.value,
        style: props.inputStyle,
        value: inputValue.value !== void 0 ? inputValue.value : "",
        type: "search",
        ...attrs,
        id: isTarget === true ? state.targetUid.value : void 0,
        maxlength: props.maxlength,
        autocomplete: props.autocomplete,
        "data-autofocus": fromDialog === true || props.autofocus === true || void 0,
        disabled: props.disable === true,
        readonly: props.readonly === true,
        ...inputControlEvents.value
      };
      if (fromDialog !== true && hasDialog === true) {
        if (Array.isArray(data.class) === true) {
          data.class = [...data.class, "no-pointer-events"];
        } else {
          data.class += " no-pointer-events";
        }
      }
      return h("input", data);
    }
    function onInput(e) {
      clearTimeout(inputTimer);
      if (e && e.target && e.target.qComposing === true) {
        return;
      }
      setInputValue(e.target.value || "");
      userInputValue = true;
      defaultInputValue = inputValue.value;
      if (state.focused.value !== true && (hasDialog !== true || dialogFieldFocused.value === true)) {
        state.focus();
      }
      if (props.onFilter !== void 0) {
        inputTimer = setTimeout(() => {
          filter2(inputValue.value);
        }, props.inputDebounce);
      }
    }
    function setInputValue(val) {
      if (inputValue.value !== val) {
        inputValue.value = val;
        emit("inputValue", val);
      }
    }
    function updateInputValue(val, noFiltering, internal) {
      userInputValue = internal !== true;
      if (props.useInput === true) {
        setInputValue(val);
        if (noFiltering === true || internal !== true) {
          defaultInputValue = val;
        }
        noFiltering !== true && filter2(val);
      }
    }
    function filter2(val, keepClosed, afterUpdateFn) {
      if (props.onFilter === void 0 || keepClosed !== true && state.focused.value !== true) {
        return;
      }
      if (state.innerLoading.value === true) {
        emit("filterAbort");
      } else {
        state.innerLoading.value = true;
        innerLoadingIndicator.value = true;
      }
      if (val !== "" && props.multiple !== true && innerValue.value.length > 0 && userInputValue !== true && val === getOptionLabel.value(innerValue.value[0])) {
        val = "";
      }
      const localFilterId = setTimeout(() => {
        menu.value === true && (menu.value = false);
      }, 10);
      clearTimeout(filterId);
      filterId = localFilterId;
      emit(
        "filter",
        val,
        (fn, afterFn) => {
          if ((keepClosed === true || state.focused.value === true) && filterId === localFilterId) {
            clearTimeout(filterId);
            typeof fn === "function" && fn();
            innerLoadingIndicator.value = false;
            nextTick(() => {
              state.innerLoading.value = false;
              if (state.editable.value === true) {
                if (keepClosed === true) {
                  menu.value === true && hidePopup();
                } else if (menu.value === true) {
                  updateMenu(true);
                } else {
                  menu.value = true;
                }
              }
              typeof afterFn === "function" && nextTick(() => {
                afterFn(proxy);
              });
              typeof afterUpdateFn === "function" && nextTick(() => {
                afterUpdateFn(proxy);
              });
            });
          }
        },
        () => {
          if (state.focused.value === true && filterId === localFilterId) {
            clearTimeout(filterId);
            state.innerLoading.value = false;
            innerLoadingIndicator.value = false;
          }
          menu.value === true && (menu.value = false);
        }
      );
    }
    function getMenu() {
      return h(QMenu, {
        ref: menuRef,
        class: menuContentClass.value,
        style: props.popupContentStyle,
        modelValue: menu.value,
        fit: props.menuShrink !== true,
        cover: props.optionsCover === true && noOptions.value !== true && props.useInput !== true,
        anchor: props.menuAnchor,
        self: props.menuSelf,
        offset: props.menuOffset,
        dark: isOptionsDark.value,
        noParentEvent: true,
        noRefocus: true,
        noFocus: true,
        square: squaredMenu.value,
        transitionShow: props.transitionShow,
        transitionHide: props.transitionHide,
        transitionDuration: props.transitionDuration,
        separateClosePopup: true,
        ...listboxAttrs.value,
        onScrollPassive: onVirtualScrollEvt,
        onBeforeShow: onControlPopupShow,
        onBeforeHide: onMenuBeforeHide,
        onShow: onMenuShow
      }, getAllOptions);
    }
    function onMenuBeforeHide(e) {
      onControlPopupHide(e);
      closeMenu();
    }
    function onMenuShow() {
      setVirtualScrollSize();
    }
    function onDialogFieldFocus(e) {
      stop(e);
      targetRef.value !== null && targetRef.value.focus();
      dialogFieldFocused.value = true;
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, 0);
    }
    function onDialogFieldBlur(e) {
      stop(e);
      nextTick(() => {
        dialogFieldFocused.value = false;
      });
    }
    function getDialog() {
      const content = [
        h(QField, {
          class: `col-auto ${state.fieldClass.value}`,
          ...innerFieldProps.value,
          for: state.targetUid.value,
          dark: isOptionsDark.value,
          square: true,
          loading: innerLoadingIndicator.value,
          itemAligned: false,
          filled: true,
          stackLabel: inputValue.value.length > 0,
          ...state.splitAttrs.listeners.value,
          onFocus: onDialogFieldFocus,
          onBlur: onDialogFieldBlur
        }, {
          ...slots,
          rawControl: () => state.getControl(true),
          before: void 0,
          after: void 0
        })
      ];
      menu.value === true && content.push(
        h("div", {
          ref: menuContentRef,
          class: menuContentClass.value + " scroll",
          style: props.popupContentStyle,
          ...listboxAttrs.value,
          onClick: prevent,
          onScrollPassive: onVirtualScrollEvt
        }, getAllOptions())
      );
      return h(QDialog, {
        ref: dialogRef,
        modelValue: dialog.value,
        position: props.useInput === true ? "top" : void 0,
        transitionShow: transitionShowComputed,
        transitionHide: props.transitionHide,
        transitionDuration: props.transitionDuration,
        onBeforeShow: onControlPopupShow,
        onBeforeHide: onDialogBeforeHide,
        onHide: onDialogHide,
        onShow: onDialogShow
      }, () => h("div", {
        class: "q-select__dialog" + (isOptionsDark.value === true ? " q-select__dialog--dark q-dark" : "") + (dialogFieldFocused.value === true ? " q-select__dialog--focused" : "")
      }, content));
    }
    function onDialogBeforeHide(e) {
      onControlPopupHide(e);
      if (dialogRef.value !== null) {
        dialogRef.value.__updateRefocusTarget(
          state.rootRef.value.querySelector(".q-field__native > [tabindex]:last-child")
        );
      }
      state.focused.value = false;
    }
    function onDialogHide(e) {
      hidePopup();
      state.focused.value === false && emit("blur", e);
      resetInputValue();
    }
    function onDialogShow() {
      const el = document.activeElement;
      if ((el === null || el.id !== state.targetUid.value) && targetRef.value !== null && targetRef.value !== el) {
        targetRef.value.focus();
      }
      setVirtualScrollSize();
    }
    function closeMenu() {
      if (dialog.value === true) {
        return;
      }
      optionIndex.value = -1;
      if (menu.value === true) {
        menu.value = false;
      }
      if (state.focused.value === false) {
        clearTimeout(filterId);
        filterId = void 0;
        if (state.innerLoading.value === true) {
          emit("filterAbort");
          state.innerLoading.value = false;
          innerLoadingIndicator.value = false;
        }
      }
    }
    function showPopup(e) {
      if (state.editable.value !== true) {
        return;
      }
      if (hasDialog === true) {
        state.onControlFocusin(e);
        dialog.value = true;
        nextTick(() => {
          state.focus();
        });
      } else {
        state.focus();
      }
      if (props.onFilter !== void 0) {
        filter2(inputValue.value);
      } else if (noOptions.value !== true || slots["no-option"] !== void 0) {
        menu.value = true;
      }
    }
    function hidePopup() {
      dialog.value = false;
      closeMenu();
    }
    function resetInputValue() {
      props.useInput === true && updateInputValue(
        props.multiple !== true && props.fillInput === true && innerValue.value.length > 0 ? getOptionLabel.value(innerValue.value[0]) || "" : "",
        true,
        true
      );
    }
    function updateMenu(show) {
      let optionIndex2 = -1;
      if (show === true) {
        if (innerValue.value.length > 0) {
          const val = getOptionValue.value(innerValue.value[0]);
          optionIndex2 = props.options.findIndex((v2) => isDeepEqual(getOptionValue.value(v2), val));
        }
        localResetVirtualScroll(optionIndex2);
      }
      setOptionIndex(optionIndex2);
    }
    function rerenderMenu(newLength, oldLength) {
      if (menu.value === true && state.innerLoading.value === false) {
        localResetVirtualScroll(-1, true);
        nextTick(() => {
          if (menu.value === true && state.innerLoading.value === false) {
            if (newLength > oldLength) {
              localResetVirtualScroll();
            } else {
              updateMenu(true);
            }
          }
        });
      }
    }
    function updateMenuPosition() {
      if (dialog.value === false && menuRef.value !== null) {
        menuRef.value.updatePosition();
      }
    }
    function onControlPopupShow(e) {
      e !== void 0 && stop(e);
      emit("popupShow", e);
      state.hasPopupOpen = true;
      state.onControlFocusin(e);
    }
    function onControlPopupHide(e) {
      e !== void 0 && stop(e);
      emit("popupHide", e);
      state.hasPopupOpen = false;
      state.onControlFocusout(e);
    }
    function updatePreState() {
      hasDialog = $q.platform.is.mobile !== true && props.behavior !== "dialog" ? false : props.behavior !== "menu" && (props.useInput === true ? slots["no-option"] !== void 0 || props.onFilter !== void 0 || noOptions.value === false : true);
      transitionShowComputed = $q.platform.is.ios === true && hasDialog === true && props.useInput === true ? "fade" : props.transitionShow;
    }
    onBeforeUpdate(updatePreState);
    onUpdated(updateMenuPosition);
    updatePreState();
    onBeforeUnmount(() => {
      clearTimeout(inputTimer);
    });
    Object.assign(proxy, {
      showPopup,
      hidePopup,
      removeAtIndex,
      add: add2,
      toggleOption,
      getOptionIndex: () => optionIndex.value,
      setOptionIndex,
      moveOptionSelection,
      filter: filter2,
      updateMenuPosition,
      updateInputValue,
      isOptionSelected,
      getEmittingOptionValue,
      isOptionDisabled: (...args) => isOptionDisabled.value.apply(null, args) === true,
      getOptionValue: (...args) => getOptionValue.value.apply(null, args),
      getOptionLabel: (...args) => getOptionLabel.value.apply(null, args)
    });
    Object.assign(state, {
      innerValue,
      fieldClass: computed(
        () => `q-select q-field--auto-height q-select--with${props.useInput !== true ? "out" : ""}-input q-select--with${props.useChips !== true ? "out" : ""}-chips q-select--${props.multiple === true ? "multiple" : "single"}`
      ),
      inputRef,
      targetRef,
      hasValue,
      showPopup,
      floatingLabel: computed(
        () => props.hideSelected !== true && hasValue.value === true || typeof inputValue.value === "number" || inputValue.value.length > 0 || fieldValueIsFilled(props.displayValue)
      ),
      getControlChild: () => {
        if (state.editable.value !== false && (dialog.value === true || noOptions.value !== true || slots["no-option"] !== void 0)) {
          return hasDialog === true ? getDialog() : getMenu();
        } else if (state.hasPopupOpen === true) {
          state.hasPopupOpen = false;
        }
      },
      controlEvents: {
        onFocusin(e) {
          state.onControlFocusin(e);
        },
        onFocusout(e) {
          state.onControlFocusout(e, () => {
            resetInputValue();
            closeMenu();
          });
        },
        onClick(e) {
          prevent(e);
          if (hasDialog !== true && menu.value === true) {
            closeMenu();
            targetRef.value !== null && targetRef.value.focus();
            return;
          }
          showPopup(e);
        }
      },
      getControl: (fromDialog) => {
        const child = getSelection();
        const isTarget = fromDialog === true || dialog.value !== true || hasDialog !== true;
        if (props.useInput === true) {
          child.push(getInput(fromDialog, isTarget));
        } else if (state.editable.value === true) {
          const attrs2 = isTarget === true ? comboboxAttrs.value : void 0;
          child.push(
            h("input", {
              ref: isTarget === true ? targetRef : void 0,
              key: "d_t",
              class: "q-select__focus-target",
              id: isTarget === true ? state.targetUid.value : void 0,
              value: ariaCurrentValue.value,
              readonly: true,
              "data-autofocus": fromDialog === true || props.autofocus === true || void 0,
              ...attrs2,
              onKeydown: onTargetKeydown,
              onKeyup: onTargetKeyup,
              onKeypress: onTargetKeypress
            })
          );
          if (isTarget === true && typeof props.autocomplete === "string" && props.autocomplete.length > 0) {
            child.push(
              h("input", {
                class: "q-select__autocomplete-input",
                autocomplete: props.autocomplete,
                tabindex: -1,
                onKeyup: onTargetAutocomplete
              })
            );
          }
        }
        if (nameProp.value !== void 0 && props.disable !== true && innerOptionsValue.value.length > 0) {
          const opts = innerOptionsValue.value.map((value2) => h("option", { value: value2, selected: true }));
          child.push(
            h("select", {
              class: "hidden",
              name: nameProp.value,
              multiple: props.multiple
            }, opts)
          );
        }
        const attrs = props.useInput === true || isTarget !== true ? void 0 : state.splitAttrs.attributes.value;
        return h("div", {
          class: "q-field__native row items-center",
          ...attrs
        }, child);
      },
      getInnerAppend: () => props.loading !== true && innerLoadingIndicator.value !== true && props.hideDropdownIcon !== true ? [
        h(QIcon, {
          class: "q-select__dropdown-icon" + (menu.value === true ? " rotate-180" : ""),
          name: dropdownArrowIcon.value
        })
      ] : null
    });
    return useField(state);
  }
});
const space = h("div", { class: "q-space" });
const QSpace = createComponent({
  name: "QSpace",
  setup() {
    return () => space;
  }
});
class DefaultSeriesMetadataConfig {
  constructor() {
    __publicField(this, "ageRating", true);
    __publicField(this, "authors", true);
    __publicField(this, "books", true);
    __publicField(this, "genres", true);
    __publicField(this, "language", true);
    __publicField(this, "links", true);
    __publicField(this, "publisher", true);
    __publicField(this, "readingDirection", true);
    __publicField(this, "releaseDate", true);
    __publicField(this, "status", true);
    __publicField(this, "summary", true);
    __publicField(this, "tags", true);
    __publicField(this, "thumbnail", true);
    __publicField(this, "title", true);
    __publicField(this, "totalBookCount", true);
    __publicField(this, "useOriginalPublisher", false);
  }
}
class DefaultBookMetadataConfig {
  constructor() {
    __publicField(this, "authors", true);
    __publicField(this, "isbn", true);
    __publicField(this, "links", true);
    __publicField(this, "number", true);
    __publicField(this, "releaseDate", true);
    __publicField(this, "summary", true);
    __publicField(this, "tags", true);
    __publicField(this, "thumbnail", true);
    __publicField(this, "title", true);
  }
}
class DefaultProviderConfig {
  constructor() {
    __publicField(this, "enabled", false);
    __publicField(this, "priority", 10);
    __publicField(this, "authorRoles", ["WRITER"]);
    __publicField(this, "artistRoles", ["PENCILLER", "INKER", "COLORIST", "LETTERER", "COVER"]);
    __publicField(this, "mediaType", "MANGA");
    __publicField(this, "seriesMetadata", new DefaultSeriesMetadataConfig());
    __publicField(this, "bookMetadata", new DefaultBookMetadataConfig());
  }
}
class DefaultProvidersConfig {
  constructor() {
    __publicField(this, "aniList", new DefaultProviderConfig());
    __publicField(this, "bookWalker", new DefaultProviderConfig());
    __publicField(this, "kodansha", new DefaultProviderConfig());
    __publicField(this, "mal", new DefaultProviderConfig());
    __publicField(this, "mangaUpdates", new DefaultProviderConfig());
    __publicField(this, "nautiljon", new DefaultProviderConfig());
    __publicField(this, "viz", new DefaultProviderConfig());
    __publicField(this, "yenPress", new DefaultProviderConfig());
    __publicField(this, "mangaDex", new DefaultProviderConfig());
    __publicField(this, "bangumi", new DefaultProviderConfig());
    __publicField(this, "comicVine", new DefaultProviderConfig());
  }
}
const useConfigUpdateStore = defineStore("settingsUpdate", () => {
  const settings = useSettingsStore();
  const libraries = ref([{ id: "", name: "" }]);
  const currentConfig = ref(null);
  const providersWithBooks = ["nautiljon", "yenPress", "kodansha", "viz", "bookWalker", "mangaDex", "bangumi", "comicVine"];
  const providersWithMediaType = ["mangaUpdates", "mal", "nautiljon", "aniList", "yenPress", "bookWalker", "bangumi"];
  const notifications = reactive({
    komgaLibraries: [],
    kavitaLibraries: [],
    webhooks: [
      {
        value: "",
        existing: false
      }
    ],
    seriesCover: false
  });
  const metadataProviders = reactive({
    malClientId: "",
    malClientIdDisabled: false,
    comicVineClientId: "",
    comicVineClientIdDisabled: false,
    nameMatchingMode: "CLOSEST_MATCH",
    defaultProviders: [{
      name: "MangaUpdates",
      books: false,
      mediaTypeEnabled: false,
      ...new DefaultProviderConfig()
    }],
    defaultDisabledProviders: [{
      name: "MangaUpdates",
      books: false,
      mediaTypeEnabled: false,
      ...new DefaultProviderConfig()
    }],
    libraryProviders: [{
      id: "123",
      name: "",
      deleted: false,
      providers: [{
        name: "MangaUpdates",
        books: false,
        mediaTypeEnabled: false,
        ...new DefaultProviderConfig()
      }],
      disabledProviders: [{
        name: "MangaUpdates",
        books: false,
        mediaTypeEnabled: false,
        ...new DefaultProviderConfig()
      }]
    }]
  });
  const komgaMetadata = reactive({
    default: {
      libraryType: "MANGA",
      aggregateMetadata: false,
      mergeTags: false,
      mergeGenres: false,
      modes: ["API"],
      bookCovers: false,
      seriesCovers: false,
      overrideExistingCovers: true,
      seriesTitle: false,
      seriesTitleLanguage: "en",
      alternativeTitles: false,
      alternativeTitleLanguages: ["en", "ja", "ja-ro"],
      orderBooks: false,
      readingDirectionValue: null,
      languageValue: null
    },
    library: []
  });
  const komga = reactive({
    baseUri: "http://localhost:8080",
    user: "admin@example.org",
    password: "",
    passwordDisabled: true,
    eventListener: {
      enabled: false,
      libraries: []
    }
  });
  const kavita = reactive({
    baseUri: "http://localhost:5000",
    apiKey: "",
    eventListener: {
      enabled: false,
      libraries: []
    }
  });
  const kavitaMetadata = reactive({
    default: {
      libraryType: "MANGA",
      aggregateMetadata: false,
      mergeTags: false,
      mergeGenres: false,
      modes: ["API"],
      bookCovers: false,
      seriesCovers: false,
      seriesTitle: false,
      seriesTitleLanguage: "en",
      alternativeTitles: false,
      alternativeTitleLanguages: ["en", "ja", "ja-ro"],
      orderBooks: false,
      languageValue: null
    },
    library: []
  });
  function reset(config) {
    var _a2, _b, _c;
    libraries.value = getLibraries();
    currentConfig.value = structuredClone(config);
    notifications.webhooks = Object.entries((_b = (_a2 = config.discord) == null ? void 0 : _a2.webhooks) != null ? _b : {}).map(([, value2]) => {
      return { value: value2, existing: true };
    });
    notifications.seriesCover = (_c = config.discord) == null ? void 0 : _c.seriesCover;
    notifications.komgaLibraries = config.komga.notifications.libraries.map((id2) => {
      var _a3;
      return {
        name: (_a3 = libraries.value.find((library) => library.id == id2)) == null ? void 0 : _a3.name,
        id: id2
      };
    });
    notifications.kavitaLibraries = config.kavita.notifications.libraries.map((id2) => {
      var _a3;
      return {
        name: (_a3 = libraries.value.find((library) => library.id == id2)) == null ? void 0 : _a3.name,
        id: id2
      };
    });
    metadataProviders.malClientId = config.metadataProviders.malClientId;
    metadataProviders.malClientIdDisabled = config.metadataProviders.malClientId != "";
    metadataProviders.comicVineClientId = config.metadataProviders.comicVineClientId;
    metadataProviders.comicVineClientIdDisabled = config.metadataProviders.comicVineClientId != void 0;
    metadataProviders.nameMatchingMode = config.metadataProviders.nameMatchingMode;
    metadataProviders.defaultProviders = Object.entries(config.metadataProviders.defaultProviders).sort((a, b) => a[1].priority - b[1].priority).map(([key, value2]) => {
      let books = providersWithBooks.includes(key);
      let mediaType = providersWithMediaType.includes(key);
      return { ...value2, name: key, books, mediaTypeEnabled: mediaType };
    }).filter((provider) => provider.enabled);
    metadataProviders.defaultDisabledProviders = Object.entries(config.metadataProviders.defaultProviders).map(([key, value2]) => {
      let books = providersWithBooks.includes(key);
      let mediaType = providersWithMediaType.includes(key);
      return { ...value2, name: key, books, mediaTypeEnabled: mediaType };
    }).filter((provider) => !provider.enabled).sort((a, b) => a.name.localeCompare(b.name));
    metadataProviders.libraryProviders = Object.entries(config.metadataProviders.libraryProviders).map(([key, value2]) => {
      var _a3, _b2;
      return {
        id: key,
        name: (_b2 = (_a3 = libraries.value.find((l) => l.id == key)) == null ? void 0 : _a3.name) != null ? _b2 : "",
        deleted: false,
        providers: Object.entries(value2).sort((a, b) => a[1].priority - b[1].priority).map(([key2, value22]) => {
          let books = providersWithBooks.includes(key2);
          let mediaType = providersWithMediaType.includes(key2);
          return {
            ...value22,
            name: key2,
            books,
            mediaTypeEnabled: mediaType
          };
        }).filter((provider) => provider.enabled),
        disabledProviders: Object.entries(value2).map(([key2, value22]) => {
          let books = providersWithBooks.includes(key2);
          let mediaType = providersWithMediaType.includes(key2);
          return { ...value22, name: key2, books, mediaTypeEnabled: mediaType };
        }).filter((provider) => !provider.enabled).sort((a, b) => a.name.localeCompare(b.name))
      };
    });
    komga.baseUri = config.komga.baseUri;
    komga.user = config.komga.komgaUser;
    komga.password = "";
    komga.passwordDisabled = true;
    komga.eventListener.enabled = config.komga.eventListener.enabled;
    komga.eventListener.libraries = config.komga.eventListener.libraries.map((id2) => {
      var _a3;
      return {
        name: (_a3 = libraries.value.find((library) => library.id == id2)) == null ? void 0 : _a3.name,
        id: id2
      };
    });
    komgaMetadata.default.aggregateMetadata = config.komga.metadataUpdate.default.aggregate;
    komgaMetadata.default.mergeTags = config.komga.metadataUpdate.default.mergeTags;
    komgaMetadata.default.mergeGenres = config.komga.metadataUpdate.default.mergeGenres;
    komgaMetadata.default.modes = config.komga.metadataUpdate.default.updateModes;
    komgaMetadata.default.bookCovers = config.komga.metadataUpdate.default.bookCovers;
    komgaMetadata.default.seriesCovers = config.komga.metadataUpdate.default.seriesCovers;
    komgaMetadata.default.overrideExistingCovers = config.komga.metadataUpdate.default.overrideExistingCovers;
    komgaMetadata.default.seriesTitle = config.komga.metadataUpdate.default.postProcessing.seriesTitle;
    komgaMetadata.default.seriesTitleLanguage = config.komga.metadataUpdate.default.postProcessing.seriesTitleLanguage;
    komgaMetadata.default.orderBooks = config.komga.metadataUpdate.default.postProcessing.orderBooks;
    komgaMetadata.default.readingDirectionValue = config.komga.metadataUpdate.default.postProcessing.readingDirectionValue;
    komgaMetadata.default.languageValue = config.komga.metadataUpdate.default.postProcessing.languageValue;
    komgaMetadata.default.alternativeTitles = config.komga.metadataUpdate.default.postProcessing.alternativeSeriesTitles;
    komgaMetadata.default.alternativeTitleLanguages = config.komga.metadataUpdate.default.postProcessing.alternativeSeriesTitleLanguages;
    komgaMetadata.library = Object.entries(config.komga.metadataUpdate.library).map(([libraryId, libraryConfig]) => {
      var _a3, _b2;
      return {
        id: libraryId,
        name: (_b2 = (_a3 = libraries.value.find((l) => l.id == libraryId)) == null ? void 0 : _a3.name) != null ? _b2 : "",
        deleted: false,
        libraryType: libraryConfig.libraryType,
        aggregateMetadata: libraryConfig.aggregate,
        mergeTags: libraryConfig.mergeTags,
        mergeGenres: libraryConfig.mergeGenres,
        modes: libraryConfig.updateModes,
        bookCovers: libraryConfig.bookCovers,
        seriesCovers: libraryConfig.seriesCovers,
        overrideExistingCovers: libraryConfig.overrideExistingCovers,
        seriesTitle: libraryConfig.postProcessing.seriesTitle,
        seriesTitleLanguage: libraryConfig.postProcessing.seriesTitleLanguage,
        orderBooks: libraryConfig.postProcessing.orderBooks,
        readingDirectionValue: libraryConfig.postProcessing.readingDirectionValue,
        languageValue: libraryConfig.postProcessing.languageValue,
        alternativeTitles: libraryConfig.postProcessing.alternativeSeriesTitles,
        alternativeTitleLanguages: libraryConfig.postProcessing.alternativeSeriesTitleLanguages
      };
    });
    kavita.baseUri = config.kavita.baseUri;
    kavita.eventListener.enabled = config.kavita.eventListener.enabled;
    kavita.eventListener.libraries = config.kavita.eventListener.libraries.map((id2) => {
      var _a3;
      return {
        name: (_a3 = libraries.value.find((library) => library.id == id2)) == null ? void 0 : _a3.name,
        id: id2
      };
    });
    kavita.apiKey = "";
    kavitaMetadata.default.aggregateMetadata = config.kavita.metadataUpdate.default.aggregate;
    kavitaMetadata.default.mergeTags = config.kavita.metadataUpdate.default.mergeTags;
    kavitaMetadata.default.mergeGenres = config.kavita.metadataUpdate.default.mergeGenres;
    kavitaMetadata.default.modes = config.kavita.metadataUpdate.default.updateModes;
    kavitaMetadata.default.bookCovers = config.kavita.metadataUpdate.default.bookCovers;
    kavitaMetadata.default.seriesCovers = config.kavita.metadataUpdate.default.seriesCovers;
    kavitaMetadata.default.overrideExistingCovers = config.kavita.metadataUpdate.default.overrideExistingCovers;
    kavitaMetadata.default.seriesTitle = config.kavita.metadataUpdate.default.postProcessing.seriesTitle;
    kavitaMetadata.default.seriesTitleLanguage = config.kavita.metadataUpdate.default.postProcessing.seriesTitleLanguage;
    kavitaMetadata.default.languageValue = config.kavita.metadataUpdate.default.postProcessing.languageValue;
    kavitaMetadata.default.alternativeTitles = config.kavita.metadataUpdate.default.postProcessing.alternativeSeriesTitles;
    kavitaMetadata.default.alternativeTitleLanguages = config.kavita.metadataUpdate.default.postProcessing.alternativeSeriesTitleLanguages;
    kavitaMetadata.library = Object.entries(config.kavita.metadataUpdate.library).map(([libraryId, libraryConfig]) => {
      var _a3, _b2;
      return {
        id: libraryId,
        name: (_b2 = (_a3 = libraries.value.find((l) => l.id == libraryId)) == null ? void 0 : _a3.name) != null ? _b2 : "",
        deleted: false,
        libraryType: libraryConfig.libraryType,
        aggregateMetadata: libraryConfig.aggregate,
        mergeTags: libraryConfig.mergeTags,
        mergeGenres: libraryConfig.mergeGenres,
        modes: libraryConfig.updateModes,
        bookCovers: libraryConfig.bookCovers,
        seriesCovers: libraryConfig.seriesCovers,
        overrideExistingCovers: libraryConfig.overrideExistingCovers,
        seriesTitle: libraryConfig.postProcessing.seriesTitle,
        seriesTitleLanguage: libraryConfig.postProcessing.seriesTitleLanguage,
        orderBooks: libraryConfig.postProcessing.orderBooks,
        languageValue: libraryConfig.postProcessing.languageValue,
        alternativeTitles: libraryConfig.postProcessing.alternativeSeriesTitles,
        alternativeTitleLanguages: libraryConfig.postProcessing.alternativeSeriesTitleLanguages
      };
    });
  }
  function getUpdates() {
    let config = currentConfig.value;
    if (!config)
      throw Error("uninitialized config");
    let changes = {};
    changes.kavita = getKavitaUpdates(config.kavita);
    changes.komga = getKomgaUpdates(config.komga);
    changes.metadataProviders = getMetadataProvidersUpdates();
    changes.discord = getDiscordUpdates(config.discord);
    return changes;
  }
  function getKomgaUpdates(current) {
    var _a2, _b, _c, _d;
    let changes = {};
    if (komga.baseUri != current.baseUri)
      changes.baseUri = komga.baseUri;
    if (komga.user != current.komgaUser)
      changes.komgaUser = komga.user;
    if (!komga.passwordDisabled && komga.password != "")
      changes.komgaPassword = komga.password;
    let eventListenerPatch = {
      enabled: komga.eventListener.enabled,
      libraries: (_b = (_a2 = komga.eventListener.libraries) == null ? void 0 : _a2.map((library) => library.id)) != null ? _b : []
    };
    changes.eventListener = getEventListenerUpdates(current.eventListener, eventListenerPatch);
    changes.notifications = getNotificationsUpdates(
      current.notifications,
      { libraries: (_d = (_c = notifications.komgaLibraries) == null ? void 0 : _c.map((lib) => lib.id)) != null ? _d : [] }
    );
    changes.metadataUpdate = getMetadataUpdates(current.metadataUpdate, komgaMetadata);
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getKavitaUpdates(current) {
    var _a2, _b, _c, _d;
    let changes = {};
    if (kavita.baseUri != current.baseUri)
      changes.baseUri = kavita.baseUri;
    if (kavita.apiKey)
      changes.apiKey = kavita.apiKey;
    let eventListenerPatch = {
      enabled: kavita.eventListener.enabled,
      libraries: (_b = (_a2 = kavita.eventListener.libraries) == null ? void 0 : _a2.map((library) => library.id)) != null ? _b : []
    };
    changes.eventListener = getEventListenerUpdates(current.eventListener, eventListenerPatch);
    changes.notifications = getNotificationsUpdates(
      current.notifications,
      { libraries: (_d = (_c = notifications.kavitaLibraries) == null ? void 0 : _c.map((lib) => lib.id)) != null ? _d : [] }
    );
    changes.metadataUpdate = getMetadataUpdates(current.metadataUpdate, kavitaMetadata);
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getMetadataUpdates(current, patch) {
    let changes = {};
    changes.default = getMetadataProcessingUpdates(current.default, patch.default);
    changes.library = getLibraryMetadataUpdates(current.library, patch.library);
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getMetadataProcessingUpdates(current, patch) {
    var _a2;
    let changes = {};
    if (patch.libraryType != (current == null ? void 0 : current.libraryType))
      changes.libraryType = patch.libraryType;
    if (patch.aggregateMetadata != (current == null ? void 0 : current.aggregate))
      changes.aggregate = patch.aggregateMetadata;
    if (patch.mergeTags != (current == null ? void 0 : current.mergeTags))
      changes.mergeTags = patch.mergeTags;
    if (patch.mergeGenres != (current == null ? void 0 : current.mergeGenres))
      changes.mergeGenres = patch.mergeGenres;
    if (patch.bookCovers != (current == null ? void 0 : current.bookCovers))
      changes.bookCovers = patch.bookCovers;
    if (patch.seriesCovers != (current == null ? void 0 : current.seriesCovers))
      changes.seriesCovers = patch.seriesCovers;
    if (patch.overrideExistingCovers != (current == null ? void 0 : current.overrideExistingCovers))
      changes.overrideExistingCovers = patch.overrideExistingCovers;
    if (!patch.modes.every((v2, i) => v2 === (current == null ? void 0 : current.updateModes[i])))
      changes.updateModes = patch.modes;
    let postProcessingChanges = {};
    if (patch.seriesTitle != (current == null ? void 0 : current.postProcessing.seriesTitle))
      postProcessingChanges.seriesTitle = patch.seriesTitle;
    if (patch.seriesTitleLanguage != (current == null ? void 0 : current.postProcessing.seriesTitleLanguage))
      postProcessingChanges.seriesTitleLanguage = patch.seriesTitleLanguage;
    if (patch.alternativeTitles != (current == null ? void 0 : current.postProcessing.alternativeSeriesTitles))
      postProcessingChanges.alternativeSeriesTitles = patch.alternativeTitles;
    if (!equalArrays(patch.alternativeTitleLanguages, (_a2 = current == null ? void 0 : current.postProcessing.alternativeSeriesTitleLanguages) != null ? _a2 : []))
      postProcessingChanges.alternativeSeriesTitleLanguages = patch.alternativeTitleLanguages;
    if (patch.orderBooks != (current == null ? void 0 : current.postProcessing.orderBooks))
      postProcessingChanges.orderBooks = patch.orderBooks;
    if (patch.readingDirectionValue != (current == null ? void 0 : current.postProcessing.readingDirectionValue))
      postProcessingChanges.readingDirectionValue = patch.readingDirectionValue;
    if (patch.languageValue != (current == null ? void 0 : current.postProcessing.languageValue))
      postProcessingChanges.languageValue = patch.languageValue;
    if (Object.entries(postProcessingChanges).every((val) => val[1] === void 0))
      postProcessingChanges = void 0;
    changes.postProcessing = postProcessingChanges;
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getLibraryMetadataUpdates(current, patch) {
    let currentLibrariesConfig = new Map(Object.entries(current != null ? current : {}));
    let updatedLibraryProviders = patch.map((libraryConfig) => {
      let config;
      if (libraryConfig.deleted)
        config = null;
      else
        config = getMetadataProcessingUpdates(currentLibrariesConfig.get(libraryConfig.id), libraryConfig);
      return [libraryConfig.id, config];
    }).filter((val) => val[1] !== void 0);
    let changes = Object.fromEntries(updatedLibraryProviders);
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getEventListenerUpdates(current, patch) {
    let changes = {};
    if (patch.enabled != current.enabled)
      changes.enabled = patch.enabled;
    if (patch.libraries.length == 0 && current.libraries.length != 0) {
      changes.libraries = [];
    } else if (patch.libraries.length != 0 && !patch.libraries.every((v2, i) => v2 === current.libraries[i])) {
      changes.libraries = patch.libraries;
    }
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getNotificationsUpdates(current, patch) {
    if (patch.libraries.length == 0 && current.libraries.length != 0) {
      return { libraries: [] };
    } else if (patch.libraries.length != 0 && !patch.libraries.every((v2, i) => v2 === current.libraries[i])) {
      return patch;
    } else
      return void 0;
  }
  function getDiscordUpdates(currentConfig2) {
    var _a2;
    let changes = {};
    if (notifications.seriesCover != (currentConfig2 == null ? void 0 : currentConfig2.seriesCover))
      changes.seriesCover = notifications.seriesCover;
    if (JSON.stringify(notifications.webhooks) != JSON.stringify(currentConfig2 == null ? void 0 : currentConfig2.webhooks)) {
      let oldEntries = Object.entries((_a2 = currentConfig2 == null ? void 0 : currentConfig2.webhooks) != null ? _a2 : {}).sort((a, b) => parseInt(a[0]) - parseInt(b[0])).map(([, value2]) => value2);
      let webhookChanges = notifications.webhooks.map((obj, index2) => {
        return [index2, obj.value];
      }).filter(([index2, value2]) => !(index2 in oldEntries) || oldEntries[index2] != value2);
      if (Object.entries(webhookChanges).filter((val) => val[1] != void 0).length != 0)
        changes.webhooks = Object.fromEntries(webhookChanges);
    }
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getMetadataProvidersUpdates() {
    var _a2;
    if (!currentConfig.value)
      throw Error("uninitialized config");
    let currentProvidersConfig = (_a2 = currentConfig.value) == null ? void 0 : _a2.metadataProviders;
    let changes = {};
    if (!metadataProviders.malClientIdDisabled)
      changes.malClientId = metadataProviders.malClientId;
    if (!metadataProviders.comicVineClientIdDisabled)
      changes.comicVineClientId = metadataProviders.comicVineClientId;
    if (metadataProviders.nameMatchingMode != (currentProvidersConfig == null ? void 0 : currentProvidersConfig.nameMatchingMode))
      changes.nameMatchingMode = metadataProviders.nameMatchingMode;
    metadataProviders.defaultProviders.forEach((provider, index2) => provider.priority = index2 + 1);
    let updatedProviders = Object.fromEntries(
      metadataProviders.defaultProviders.concat(metadataProviders.defaultDisabledProviders).map((obj) => [obj.name, obj])
    );
    changes.defaultProviders = getProvidersUpdates(currentProvidersConfig == null ? void 0 : currentProvidersConfig.defaultProviders, updatedProviders);
    changes.libraryProviders = getLibraryProvidersUpdates();
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getLibraryProvidersUpdates() {
    var _a2, _b, _c;
    let currentLibrariesConfig = new Map(Object.entries((_c = (_b = (_a2 = currentConfig.value) == null ? void 0 : _a2.metadataProviders) == null ? void 0 : _b.libraryProviders) != null ? _c : {}));
    let updatedLibraryProviders = metadataProviders.libraryProviders.map((libraryConfig) => {
      libraryConfig.providers.forEach((provider, index2) => provider.priority = index2 + 1);
      let config;
      if (libraryConfig.deleted)
        config = null;
      else
        config = getProvidersUpdates(
          currentLibrariesConfig.get(libraryConfig.id),
          Object.fromEntries(libraryConfig.providers.concat(libraryConfig.disabledProviders).map((provider) => [provider.name, provider]))
        );
      return [libraryConfig.id, config];
    }).filter((val) => val[1] !== void 0);
    let changes = Object.fromEntries(updatedLibraryProviders);
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getProvidersUpdates(current, updated) {
    let changes = {};
    Object.entries(updated).forEach(([key, value2]) => {
      switch (key) {
        case "mangaUpdates":
          changes.mangaUpdates = getProviderUpdates(current == null ? void 0 : current.mangaUpdates, value2);
          break;
        case "mal":
          changes.mal = getProviderUpdates(current == null ? void 0 : current.mal, value2);
          break;
        case "nautiljon":
          changes.nautiljon = getProviderUpdates(current == null ? void 0 : current.nautiljon, value2);
          break;
        case "aniList":
          changes.aniList = getProviderUpdates(current == null ? void 0 : current.aniList, value2);
          break;
        case "yenPress":
          changes.yenPress = getProviderUpdates(current == null ? void 0 : current.yenPress, value2);
          break;
        case "kodansha":
          changes.kodansha = getProviderUpdates(current == null ? void 0 : current.kodansha, value2);
          break;
        case "viz":
          changes.viz = getProviderUpdates(current == null ? void 0 : current.viz, value2);
          break;
        case "bookWalker":
          changes.bookWalker = getProviderUpdates(current == null ? void 0 : current.bookWalker, value2);
          break;
        case "mangaDex":
          changes.mangaDex = getProviderUpdates(current == null ? void 0 : current.mangaDex, value2);
          break;
        case "bangumi":
          changes.bangumi = getProviderUpdates(current == null ? void 0 : current.bangumi, value2);
          break;
        case "comicVine":
          changes.comicVine = getProviderUpdates(current == null ? void 0 : current.comicVine, value2);
          break;
        default:
          return void 0;
      }
    });
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getProviderUpdates(current, updated) {
    var _a2, _b;
    let changes = {};
    if (updated.enabled != (current == null ? void 0 : current.enabled))
      changes.enabled = updated.enabled;
    if (updated.priority != (current == null ? void 0 : current.priority))
      changes.priority = updated.priority;
    if (updated.nameMatchingMode != (current == null ? void 0 : current.nameMatchingMode))
      changes.nameMatchingMode = updated.nameMatchingMode;
    if (!equalArrays(updated.authorRoles, (_a2 = current == null ? void 0 : current.authorRoles) != null ? _a2 : []))
      changes.authorRoles = updated.authorRoles;
    if (!equalArrays(updated.artistRoles, (_b = current == null ? void 0 : current.artistRoles) != null ? _b : []))
      changes.artistRoles = updated.artistRoles;
    if (updated.mediaType != (current == null ? void 0 : current.mediaType))
      changes.mediaType = updated.mediaType;
    changes.seriesMetadata = getSeriesMetadataUpdates(current == null ? void 0 : current.seriesMetadata, updated.seriesMetadata);
    changes.bookMetadata = getBookMetadataUpdates(current == null ? void 0 : current.bookMetadata, updated.bookMetadata);
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getSeriesMetadataUpdates(current, updated) {
    let changes = {};
    if (updated.status != (current == null ? void 0 : current.status))
      changes.status = updated.status;
    if (updated.title != (current == null ? void 0 : current.title))
      changes.title = updated.title;
    if (updated.summary != (current == null ? void 0 : current.summary))
      changes.summary = updated.summary;
    if (updated.publisher != (current == null ? void 0 : current.publisher))
      changes.publisher = updated.publisher;
    if (updated.readingDirection != (current == null ? void 0 : current.readingDirection))
      changes.readingDirection = updated.readingDirection;
    if (updated.ageRating != (current == null ? void 0 : current.ageRating))
      changes.ageRating = updated.ageRating;
    if (updated.language != (current == null ? void 0 : current.language))
      changes.language = updated.language;
    if (updated.genres != (current == null ? void 0 : current.genres))
      changes.genres = updated.genres;
    if (updated.tags != (current == null ? void 0 : current.tags))
      changes.tags = updated.tags;
    if (updated.totalBookCount != (current == null ? void 0 : current.totalBookCount))
      changes.totalBookCount = updated.totalBookCount;
    if (updated.authors != (current == null ? void 0 : current.authors))
      changes.authors = updated.authors;
    if (updated.releaseDate != (current == null ? void 0 : current.releaseDate))
      changes.releaseDate = updated.releaseDate;
    if (updated.thumbnail != (current == null ? void 0 : current.thumbnail))
      changes.thumbnail = updated.thumbnail;
    if (updated.books != (current == null ? void 0 : current.books))
      changes.books = updated.books;
    if (updated.links != (current == null ? void 0 : current.links))
      changes.links = updated.links;
    if (updated.useOriginalPublisher != (current == null ? void 0 : current.useOriginalPublisher))
      changes.useOriginalPublisher = updated.useOriginalPublisher;
    if (updated.originalPublisherTagName != (current == null ? void 0 : current.originalPublisherTagName))
      changes.originalPublisherTagName = updated.originalPublisherTagName;
    if (updated.englishPublisherTagName != (current == null ? void 0 : current.englishPublisherTagName))
      changes.englishPublisherTagName = updated.englishPublisherTagName;
    if (updated.frenchPublisherTagName != (current == null ? void 0 : current.frenchPublisherTagName))
      changes.frenchPublisherTagName = updated.frenchPublisherTagName;
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getBookMetadataUpdates(current, updated) {
    let changes = {};
    if (updated.title != (current == null ? void 0 : current.title))
      changes.title = updated.title;
    if (updated.summary != (current == null ? void 0 : current.summary))
      changes.summary = updated.summary;
    if (updated.number != (current == null ? void 0 : current.number))
      changes.number = updated.number;
    if (updated.releaseDate != (current == null ? void 0 : current.releaseDate))
      changes.releaseDate = updated.releaseDate;
    if (updated.authors != (current == null ? void 0 : current.authors))
      changes.authors = updated.authors;
    if (updated.tags != (current == null ? void 0 : current.tags))
      changes.tags = updated.tags;
    if (updated.isbn != (current == null ? void 0 : current.isbn))
      changes.isbn = updated.isbn;
    if (updated.links != (current == null ? void 0 : current.links))
      changes.links = updated.links;
    if (updated.thumbnail != (current == null ? void 0 : current.thumbnail))
      changes.thumbnail = updated.thumbnail;
    if (Object.entries(changes).every((val) => val[1] === void 0))
      return void 0;
    else
      return changes;
  }
  function getLibraries() {
    if (settings.mediaServer == MediaServer.Komga) {
      return Array.from(document.getElementsByClassName("v-navigation-drawer__content")[0].getElementsByTagName("a")).filter(
        (el) => el.classList.contains("v-list-item--dense") && /\/libraries.*/.test(el.getAttribute("href"))
      ).map((el) => {
        let pathTokens = el.getAttribute("href").split("/");
        return {
          id: pathTokens[pathTokens.findIndex((el2) => el2 == "libraries") + 1],
          name: el.text
        };
      });
    } else {
      return Array.from(document.getElementsByTagName("app-side-nav")[0].getElementsByTagName("a")).filter(
        (el) => el.classList.contains("side-nav-item") && /\/library.*/.test(el.getAttribute("href"))
      ).map((el) => {
        var _a2, _b;
        let pathTokens = el.getAttribute("href").split("/");
        return {
          id: pathTokens[pathTokens.findIndex((el2) => el2 == "library") + 1],
          name: (_b = (_a2 = Array.from(el.getElementsByTagName("span")).find((span) => span.classList.contains("side-nav-text"))) == null ? void 0 : _a2.textContent) != null ? _b : ""
        };
      });
    }
  }
  function equalArrays(a1, a2) {
    return a1.length == a2.length && a1.every((elem, index2) => elem == a2[index2]);
  }
  return {
    currentConfig,
    notifications,
    metadataProviders,
    komgaMetadata,
    kavitaMetadata,
    libraries,
    providersWithBooks,
    providersWithMediaType,
    kavita,
    komga,
    reset,
    getUpdates
  };
});
const _withScopeId$5 = (n) => (pushScopeId("data-v-35e1c28d"), n = n(), popScopeId(), n);
const _hoisted_1$b = { class: "column" };
const _hoisted_2$9 = { class: "text-h6 gt-xs q-pb-lg" };
const _hoisted_3$8 = {
  key: 0,
  class: "col-auto",
  style: { "padding": "8px 0 8px 0" }
};
const _hoisted_4$7 = {
  key: 1,
  class: "col-auto",
  style: { "padding": "8px 0 8px 0" }
};
const _hoisted_5$6 = { class: "col-auto" };
const _hoisted_6$6 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_7$4 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("span", { class: "text-body2" }, "Webhooks", -1));
const _hoisted_8$4 = {
  key: 0,
  class: "row q-pt-sm"
};
const _hoisted_9$4 = { class: "col" };
const _hoisted_10$4 = { class: "col-auto" };
const _hoisted_11$3 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_12$2 = { class: "row" };
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "NotificationsSettingsTab",
  setup(__props) {
    const settings = useSettingsStore();
    const configStore = useConfigUpdateStore();
    let config = configStore.notifications;
    function addEntry() {
      config.webhooks.push({ value: "", existing: false });
    }
    function removeEntry(index2) {
      let webhook = config.webhooks[index2];
      if (webhook.existing)
        webhook.value = null;
      else
        config.webhooks.splice(index2, 1);
    }
    function libraryLabel(library) {
      return `${library.name} (${library.id})`;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$b, [
        createBaseVNode("div", _hoisted_2$9, [
          createVNode(QIcon, {
            name: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-bell" : "fa fa-bell"
          }, null, 8, ["name"]),
          createTextVNode(" Discord Notifications ")
        ]),
        unref(settings).mediaServer === unref(MediaServer).Komga ? (openBlock(), createElementBlock("div", _hoisted_3$8, [
          createVNode(QSelect, {
            filled: "",
            modelValue: unref(config).komgaLibraries,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(config).komgaLibraries = $event),
            multiple: "",
            clearable: "",
            options: unref(configStore).libraries,
            "option-label": libraryLabel,
            label: "Notify for Libraries",
            hint: "will notify for all libraries if empty"
          }, null, 8, ["modelValue", "options"])
        ])) : createCommentVNode("", true),
        unref(settings).mediaServer === unref(MediaServer).Kavita ? (openBlock(), createElementBlock("div", _hoisted_4$7, [
          createVNode(QSelect, {
            filled: "",
            modelValue: unref(config).kavitaLibraries,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(config).kavitaLibraries = $event),
            multiple: "",
            clearable: "",
            options: unref(configStore).libraries,
            "option-label": libraryLabel,
            label: "Notify for Libraries",
            hint: "will notify for all libraries if empty"
          }, null, 8, ["modelValue", "options"])
        ])) : createCommentVNode("", true),
        createVNode(QSeparator),
        createBaseVNode("div", _hoisted_5$6, [
          createVNode(QCheckbox, {
            modelValue: unref(config).seriesCover,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(config).seriesCover = $event),
            label: "Upload Series Cover"
          }, null, 8, ["modelValue"])
        ]),
        createBaseVNode("div", _hoisted_6$6, [
          _hoisted_7$4,
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(config).webhooks, (webhook, i) => {
            return openBlock(), createElementBlock(Fragment, null, [
              webhook.value != null ? (openBlock(), createElementBlock("div", _hoisted_8$4, [
                createBaseVNode("div", _hoisted_9$4, [
                  createVNode(QInput, {
                    modelValue: unref(config).webhooks[i].value,
                    "onUpdate:modelValue": ($event) => unref(config).webhooks[i].value = $event,
                    autogrow: "",
                    filled: "",
                    disable: unref(config).webhooks[i].existing
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"])
                ]),
                createBaseVNode("div", _hoisted_10$4, [
                  createVNode(QBtn, {
                    onClick: ($event) => removeEntry(i),
                    flat: "",
                    round: "",
                    icon: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-delete" : "fa fa-trash",
                    size: unref(settings).mediaServer === unref(MediaServer).Komga ? "md" : "sm"
                  }, null, 8, ["onClick", "icon", "size"])
                ])
              ])) : createCommentVNode("", true)
            ], 64);
          }), 256))
        ]),
        createBaseVNode("div", _hoisted_11$3, [
          createBaseVNode("div", _hoisted_12$2, [
            createVNode(QSpace),
            createVNode(QBtn, {
              round: "",
              color: "secondary",
              onClick: addEntry,
              icon: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-plus" : "fa fa-plus",
              style: { "padding": "0" }
            }, null, 8, ["icon"])
          ])
        ])
      ]);
    };
  }
});
const NotificationsSettingsTab_vue_vue_type_style_index_0_scoped_35e1c28d_lang = "";
const _export_sfc = (sfc, props) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target2[key] = val;
  }
  return target2;
};
const NotificationsSettingsTab = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-35e1c28d"]]);
const QList = createComponent({
  name: "QList",
  props: {
    ...useDarkProps,
    bordered: Boolean,
    dense: Boolean,
    separator: Boolean,
    padding: Boolean,
    tag: {
      type: String,
      default: "div"
    }
  },
  setup(props, { slots }) {
    const vm = getCurrentInstance();
    const isDark = useDark(props, vm.proxy.$q);
    const classes = computed(
      () => "q-list" + (props.bordered === true ? " q-list--bordered" : "") + (props.dense === true ? " q-list--dense" : "") + (props.separator === true ? " q-list--separator" : "") + (isDark.value === true ? " q-list--dark" : "") + (props.padding === true ? " q-list--padding" : "")
    );
    return () => h(props.tag, { class: classes.value }, hSlot(slots.default));
  }
});
const QSlideTransition = createComponent({
  name: "QSlideTransition",
  props: {
    appear: Boolean,
    duration: {
      type: Number,
      default: 300
    }
  },
  emits: ["show", "hide"],
  setup(props, { slots, emit }) {
    let animating = false, doneFn, element;
    let timer2, timerFallback, animListener, lastEvent;
    function cleanup() {
      doneFn && doneFn();
      doneFn = null;
      animating = false;
      clearTimeout(timer2);
      clearTimeout(timerFallback);
      element !== void 0 && element.removeEventListener("transitionend", animListener);
      animListener = null;
    }
    function begin(el, height, done) {
      el.style.overflowY = "hidden";
      if (height !== void 0) {
        el.style.height = `${height}px`;
      }
      el.style.transition = `height ${props.duration}ms cubic-bezier(.25, .8, .50, 1)`;
      animating = true;
      doneFn = done;
    }
    function end(el, event) {
      el.style.overflowY = null;
      el.style.height = null;
      el.style.transition = null;
      cleanup();
      event !== lastEvent && emit(event);
    }
    function onEnter(el, done) {
      let pos = 0;
      element = el;
      if (animating === true) {
        cleanup();
        pos = el.offsetHeight === el.scrollHeight ? 0 : void 0;
      } else {
        lastEvent = "hide";
      }
      begin(el, pos, done);
      timer2 = setTimeout(() => {
        el.style.height = `${el.scrollHeight}px`;
        animListener = (evt) => {
          if (Object(evt) !== evt || evt.target === el) {
            end(el, "show");
          }
        };
        el.addEventListener("transitionend", animListener);
        timerFallback = setTimeout(animListener, props.duration * 1.1);
      }, 100);
    }
    function onLeave(el, done) {
      let pos;
      element = el;
      if (animating === true) {
        cleanup();
      } else {
        lastEvent = "show";
        pos = el.scrollHeight;
      }
      begin(el, pos, done);
      timer2 = setTimeout(() => {
        el.style.height = 0;
        animListener = (evt) => {
          if (Object(evt) !== evt || evt.target === el) {
            end(el, "hide");
          }
        };
        el.addEventListener("transitionend", animListener);
        timerFallback = setTimeout(animListener, props.duration * 1.1);
      }, 100);
    }
    onBeforeUnmount(() => {
      animating === true && cleanup();
    });
    return () => h(Transition, {
      css: false,
      appear: props.appear,
      onEnter,
      onLeave
    }, slots.default);
  }
});
const itemGroups = shallowReactive({});
const LINK_PROPS = Object.keys(useRouterLinkProps);
const QExpansionItem = createComponent({
  name: "QExpansionItem",
  props: {
    ...useRouterLinkProps,
    ...useModelToggleProps,
    ...useDarkProps,
    icon: String,
    label: String,
    labelLines: [Number, String],
    caption: String,
    captionLines: [Number, String],
    dense: Boolean,
    toggleAriaLabel: String,
    expandIcon: String,
    expandedIcon: String,
    expandIconClass: [Array, String, Object],
    duration: Number,
    headerInsetLevel: Number,
    contentInsetLevel: Number,
    expandSeparator: Boolean,
    defaultOpened: Boolean,
    hideExpandIcon: Boolean,
    expandIconToggle: Boolean,
    switchToggleSide: Boolean,
    denseToggle: Boolean,
    group: String,
    popup: Boolean,
    headerStyle: [Array, String, Object],
    headerClass: [Array, String, Object]
  },
  emits: [
    ...useModelToggleEmits,
    "click",
    "afterShow",
    "afterHide"
  ],
  setup(props, { slots, emit }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = useDark(props, $q);
    const showing = ref(
      props.modelValue !== null ? props.modelValue : props.defaultOpened
    );
    const blurTargetRef = ref(null);
    const targetUid = uid$2();
    const { show, hide, toggle } = useModelToggle({ showing });
    let uniqueId, exitGroup;
    const classes = computed(
      () => `q-expansion-item q-item-type q-expansion-item--${showing.value === true ? "expanded" : "collapsed"} q-expansion-item--${props.popup === true ? "popup" : "standard"}`
    );
    const contentStyle = computed(() => {
      if (props.contentInsetLevel === void 0) {
        return null;
      }
      const dir = $q.lang.rtl === true ? "Right" : "Left";
      return {
        ["padding" + dir]: props.contentInsetLevel * 56 + "px"
      };
    });
    const hasLink = computed(
      () => props.disable !== true && (props.href !== void 0 || props.to !== void 0 && props.to !== null && props.to !== "")
    );
    const linkProps = computed(() => {
      const acc = {};
      LINK_PROPS.forEach((key) => {
        acc[key] = props[key];
      });
      return acc;
    });
    const isClickable = computed(
      () => hasLink.value === true || props.expandIconToggle !== true
    );
    const expansionIcon = computed(() => props.expandedIcon !== void 0 && showing.value === true ? props.expandedIcon : props.expandIcon || $q.iconSet.expansionItem[props.denseToggle === true ? "denseIcon" : "icon"]);
    const activeToggleIcon = computed(
      () => props.disable !== true && (hasLink.value === true || props.expandIconToggle === true)
    );
    const headerSlotScope = computed(() => ({
      expanded: showing.value === true,
      detailsId: props.targetUid,
      toggle,
      show,
      hide
    }));
    const toggleAriaAttrs = computed(() => {
      const toggleAriaLabel = props.toggleAriaLabel !== void 0 ? props.toggleAriaLabel : $q.lang.label[showing.value === true ? "collapse" : "expand"](props.label);
      return {
        role: "button",
        "aria-expanded": showing.value === true ? "true" : "false",
        "aria-controls": targetUid,
        "aria-label": toggleAriaLabel
      };
    });
    watch(() => props.group, (name) => {
      exitGroup !== void 0 && exitGroup();
      name !== void 0 && enterGroup();
    });
    function onHeaderClick(e) {
      hasLink.value !== true && toggle(e);
      emit("click", e);
    }
    function toggleIconKeyboard(e) {
      e.keyCode === 13 && toggleIcon(e, true);
    }
    function toggleIcon(e, keyboard) {
      keyboard !== true && blurTargetRef.value !== null && blurTargetRef.value.focus();
      toggle(e);
      stopAndPrevent(e);
    }
    function onShow() {
      emit("afterShow");
    }
    function onHide() {
      emit("afterHide");
    }
    function enterGroup() {
      if (uniqueId === void 0) {
        uniqueId = uid$2();
      }
      if (showing.value === true) {
        itemGroups[props.group] = uniqueId;
      }
      const show2 = watch(showing, (val) => {
        if (val === true) {
          itemGroups[props.group] = uniqueId;
        } else if (itemGroups[props.group] === uniqueId) {
          delete itemGroups[props.group];
        }
      });
      const group = watch(
        () => itemGroups[props.group],
        (val, oldVal) => {
          if (oldVal === uniqueId && val !== void 0 && val !== uniqueId) {
            hide();
          }
        }
      );
      exitGroup = () => {
        show2();
        group();
        if (itemGroups[props.group] === uniqueId) {
          delete itemGroups[props.group];
        }
        exitGroup = void 0;
      };
    }
    function getToggleIcon() {
      const data = {
        class: [
          `q-focusable relative-position cursor-pointer${props.denseToggle === true && props.switchToggleSide === true ? " items-end" : ""}`,
          props.expandIconClass
        ],
        side: props.switchToggleSide !== true,
        avatar: props.switchToggleSide
      };
      const child = [
        h(QIcon, {
          class: "q-expansion-item__toggle-icon" + (props.expandedIcon === void 0 && showing.value === true ? " q-expansion-item__toggle-icon--rotated" : ""),
          name: expansionIcon.value
        })
      ];
      if (activeToggleIcon.value === true) {
        Object.assign(data, {
          tabindex: 0,
          ...toggleAriaAttrs.value,
          onClick: toggleIcon,
          onKeyup: toggleIconKeyboard
        });
        child.unshift(
          h("div", {
            ref: blurTargetRef,
            class: "q-expansion-item__toggle-focus q-icon q-focus-helper q-focus-helper--rounded",
            tabindex: -1
          })
        );
      }
      return h(QItemSection, data, () => child);
    }
    function getHeaderChild() {
      let child;
      if (slots.header !== void 0) {
        child = [].concat(slots.header(headerSlotScope.value));
      } else {
        child = [
          h(QItemSection, () => [
            h(QItemLabel, { lines: props.labelLines }, () => props.label || ""),
            props.caption ? h(QItemLabel, { lines: props.captionLines, caption: true }, () => props.caption) : null
          ])
        ];
        props.icon && child[props.switchToggleSide === true ? "push" : "unshift"](
          h(QItemSection, {
            side: props.switchToggleSide === true,
            avatar: props.switchToggleSide !== true
          }, () => h(QIcon, { name: props.icon }))
        );
      }
      if (props.disable !== true && props.hideExpandIcon !== true) {
        child[props.switchToggleSide === true ? "unshift" : "push"](
          getToggleIcon()
        );
      }
      return child;
    }
    function getHeader() {
      const data = {
        ref: "item",
        style: props.headerStyle,
        class: props.headerClass,
        dark: isDark.value,
        disable: props.disable,
        dense: props.dense,
        insetLevel: props.headerInsetLevel
      };
      if (isClickable.value === true) {
        data.clickable = true;
        data.onClick = onHeaderClick;
        Object.assign(
          data,
          hasLink.value === true ? linkProps.value : toggleAriaAttrs.value
        );
      }
      return h(QItem, data, getHeaderChild);
    }
    function getTransitionChild() {
      return withDirectives(
        h("div", {
          key: "e-content",
          class: "q-expansion-item__content relative-position",
          style: contentStyle.value,
          id: targetUid
        }, hSlot(slots.default)),
        [[
          vShow,
          showing.value
        ]]
      );
    }
    function getContent() {
      const node = [
        getHeader(),
        h(QSlideTransition, {
          duration: props.duration,
          onShow,
          onHide
        }, getTransitionChild)
      ];
      if (props.expandSeparator === true) {
        node.push(
          h(QSeparator, {
            class: "q-expansion-item__border q-expansion-item__border--top absolute-top",
            dark: isDark.value
          }),
          h(QSeparator, {
            class: "q-expansion-item__border q-expansion-item__border--bottom absolute-bottom",
            dark: isDark.value
          })
        );
      }
      return node;
    }
    props.group !== void 0 && enterGroup();
    onBeforeUnmount(() => {
      exitGroup !== void 0 && exitGroup();
    });
    return () => h("div", { class: classes.value }, [
      h("div", { class: "q-expansion-item__container relative-position" }, getContent())
    ]);
  }
});
function getDepth(value2) {
  if (value2 === false) {
    return 0;
  }
  if (value2 === true || value2 === void 0) {
    return 1;
  }
  const depth = parseInt(value2, 10);
  return isNaN(depth) ? 0 : depth;
}
const ClosePopup = createDirective(
  {
    name: "close-popup",
    beforeMount(el, { value: value2 }) {
      const ctx = {
        depth: getDepth(value2),
        handler(evt) {
          ctx.depth !== 0 && setTimeout(() => {
            const proxy = getPortalProxy(el);
            if (proxy !== void 0) {
              closePortals(proxy, evt, ctx.depth);
            }
          });
        },
        handlerKey(evt) {
          isKeyCode(evt, 13) === true && ctx.handler(evt);
        }
      };
      el.__qclosepopup = ctx;
      el.addEventListener("click", ctx.handler);
      el.addEventListener("keyup", ctx.handlerKey);
    },
    updated(el, { value: value2, oldValue }) {
      if (value2 !== oldValue) {
        el.__qclosepopup.depth = getDepth(value2);
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qclosepopup;
      el.removeEventListener("click", ctx.handler);
      el.removeEventListener("keyup", ctx.handlerKey);
      delete el.__qclosepopup;
    }
  }
);
/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target2) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target2 = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target2[key] = source[key];
    }
  }
  return target2;
}
var version = "1.15.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key])
        return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($2) {
    return $2(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target2) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target2
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target2 = state.target, fromRect = target2.fromRect, toRect = getRect(target2), prevFromRect = target2.prevFromRect, prevToRect = target2.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target2, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target2.toRect = toRect;
        if (target2.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target2.prevFromRect = fromRect;
          target2.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target2, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target2.animationResetTimer);
          target2.animationResetTimer = setTimeout(function() {
            target2.animationTime = 0;
            target2.prevFromRect = null;
            target2.fromRect = null;
            target2.prevToRect = null;
            target2.thisAnimationDuration = null;
          }, time);
          target2.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target2, currentRect, toRect, duration) {
      if (duration) {
        css(target2, "transition", "");
        css(target2, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target2.animatingX = !!translateX;
        target2.animatingY = !!translateY;
        css(target2, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target2);
        css(target2, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target2, "transform", "translate3d(0,0,0)");
        typeof target2.animated === "number" && clearTimeout(target2.animated);
        target2.animated = setTimeout(function() {
          css(target2, "transition", "");
          css(target2, "transform", "");
          target2.animated = false;
          target2.animatingX = false;
          target2.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target2) {
  return target2.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value2) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value2);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options) {
  function toFn(value2, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value2 == null && (pull || sameGroup)) {
        return true;
      } else if (value2 == null || value2 === false) {
        return false;
      } else if (pull && value2 === "clone") {
        return value2;
      } else if (typeof value2 === "function") {
        return toFn(value2(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value2 === true || typeof value2 === "string" && value2 === otherGroup || value2.join && value2.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn in this) {
    if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
      this[fn] = this[fn].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = {
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target2) {
    if (!this.el.contains(target2) && target2 !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target2) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target2, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target2 = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target2, filter2 = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target2 && target2.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target2 = closest(target2, options.draggable, el, false);
    if (target2 && target2.animated) {
      return;
    }
    if (lastDownEl === target2) {
      return;
    }
    oldIndex = index(target2);
    oldDraggableIndex = index(target2, options.draggable);
    if (typeof filter2 === "function") {
      if (filter2.call(this, evt, target2, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target2,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter2) {
      filter2 = filter2.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target2,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter2) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target2);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target2) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target2 && !dragEl && target2.parentNode === el) {
      var dragRect = getRect(target2);
      rootEl = el;
      dragEl = target2;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target2;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target2 = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target2;
      while (target2 && target2.shadowRoot) {
        target2 = target2.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target2 === parent)
          break;
        parent = target2;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target2);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target2,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target2 = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target2 = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target: target2,
        completed,
        onMove: function onMove(target3, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target3, getRect(target3), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target2;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target2 === dragEl && !dragEl.animated || target2 === el && !target2.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target2 !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target2 = closest(target2, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target2.animated && target2.animatingX && target2.animatingY || _this._ignoreWhileAnimating === target2) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target2) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target2 = elLastChild;
        }
        if (target2) {
          targetRect = getRect(target2);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target2, targetRect, evt, !!target2) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target2 = firstChild;
        targetRect = getRect(target2);
        if (_onMove(rootEl, el, dragEl, dragRect, target2, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target2.parentNode === el) {
        targetRect = getRect(target2);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target2.animated && target2.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target2, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target2) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target2, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target2);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target2) {
          return completed(false);
        }
        lastTarget = target2;
        lastDirection = direction;
        var nextSibling = target2.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target2, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target2.parentNode.insertBefore(dragEl, after ? nextSibling : target2);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target2)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray2() {
    var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id2, i) {
      var el = rootEl2.children[i];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id2] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id2) {
      if (items[id2]) {
        rootEl2.removeChild(items[id2]);
        rootEl2.appendChild(items[id2]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  option: function option(name, value2) {
    var options = this.options;
    if (value2 === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value2);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value2;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target2, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target2);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target2) {
  if (index(dragEl) < index(target2)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id2) {
  return clearTimeout(id2);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target2 = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target2)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
const _hoisted_1$a = { key: 0 };
const _hoisted_2$8 = { key: 1 };
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "Sortable",
  props: {
    options: {
      type: Object,
      default: null,
      required: false
    },
    list: {
      type: [Array, Object],
      default: [],
      required: true
    },
    itemKey: {
      type: [String, Function],
      default: "",
      required: true
    },
    tag: {
      type: String,
      default: "div",
      required: false
    }
  },
  emits: ["choose", "unchoose", "start", "end", "add", "update", "sort", "remove", "filter", "move", "clone", "change"],
  setup(__props, { emit }) {
    const props = __props;
    const attrs = useAttrs();
    const containerRef = ref(null);
    const sortable = ref(null);
    const getKey = computed(() => {
      if (typeof props.itemKey === "string")
        return (item) => item[props.itemKey];
      return props.itemKey;
    });
    watch(containerRef, (newDraggable) => {
      if (newDraggable) {
        sortable.value = new Sortable(newDraggable, {
          ...props.options,
          onChoose: (event) => emit("choose", event),
          onUnchoose: (event) => emit("unchoose", event),
          onStart: (event) => emit("start", event),
          onEnd: (event) => emit("end", event),
          onAdd: (event) => emit("add", event),
          onUpdate: (event) => emit("update", event),
          onSort: (event) => emit("sort", event),
          onRemove: (event) => emit("remove", event),
          onFilter: (event) => emit("filter", event),
          onMove: (event, originalEvent) => "onMoveCapture" in attrs ? attrs.onMoveCapture(event, originalEvent) : emit("move", event, originalEvent),
          onClone: (event) => emit("clone", event),
          onChange: (event) => emit("change", event)
        });
      }
    });
    watch(
      () => props.options,
      (options) => {
        if (options && (sortable == null ? void 0 : sortable.value)) {
          for (const property in options) {
            sortable.value.option(
              property,
              options[property]
            );
          }
        }
      }
    );
    onUnmounted(() => {
      if (sortable.value) {
        sortable.value.destroy();
        containerRef.value = null;
        sortable.value = null;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {
        ref_key: "containerRef",
        ref: containerRef,
        class: normalizeClass(_ctx.$props.class)
      }, {
        default: withCtx(() => [
          _ctx.$slots["header"] ? (openBlock(), createElementBlock("header", _hoisted_1$a, [
            renderSlot(_ctx.$slots, "header")
          ])) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.list, (item, index2) => {
            return renderSlot(_ctx.$slots, "item", {
              key: unref(getKey)(item),
              element: item,
              index: index2
            });
          }), 128)),
          _ctx.$slots["footer"] ? (openBlock(), createElementBlock("footer", _hoisted_2$8, [
            renderSlot(_ctx.$slots, "footer")
          ])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["class"]);
    };
  }
});
const _withScopeId$4 = (n) => (pushScopeId("data-v-e7c9ff7c"), n = n(), popScopeId(), n);
const _hoisted_1$9 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", { class: "col-auto" }, " Library ", -1));
const _hoisted_2$7 = { class: "col-auto q-ml-sm" };
const _hoisted_3$7 = { class: "column" };
const _hoisted_4$6 = {
  class: "col-auto",
  style: { "padding": "0" }
};
const _hoisted_5$5 = { class: "column" };
const _hoisted_6$5 = {
  class: "col-auto",
  style: { "padding": "0" }
};
const _hoisted_7$3 = { class: "row" };
const _hoisted_8$3 = {
  class: "col-auto full-width",
  style: { "padding": "0" }
};
const _hoisted_9$3 = {
  key: 0,
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_10$3 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_11$2 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_12$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_13$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_14$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_15$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_16$1 = { class: "col-auto" };
const _hoisted_17$1 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", { class: "col-auto" }, " Add New ", -1));
const _hoisted_18$1 = { class: "col-auto q-ml-sm" };
const _hoisted_19$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_20$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_21$1 = { class: "row" };
const _hoisted_22$1 = {
  class: "col",
  style: { "padding": "0" }
};
const _hoisted_23$1 = {
  key: 0,
  class: "col-auto",
  style: { "padding": "0" }
};
const _hoisted_24$1 = { class: "row" };
const _hoisted_25$1 = {
  class: "col",
  style: { "padding": "0" }
};
const _hoisted_26$1 = {
  key: 0,
  class: "col-auto",
  style: { "padding": "0" }
};
const _hoisted_27$1 = { class: "column" };
const _hoisted_28$1 = {
  class: "col-auto",
  style: { "padding": "0" }
};
const _hoisted_29$1 = { class: "row" };
const _hoisted_30$1 = {
  class: "col-auto full-width",
  style: { "padding": "0" }
};
const _hoisted_31$1 = {
  key: 0,
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_32$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_33$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_34$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_35$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_36$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_37$1 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_38$1 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", { class: "col-auto" }, " Add New ", -1));
const _hoisted_39$1 = { class: "col-auto q-ml-sm" };
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "MetadataProvidersSettingsTab",
  setup(__props) {
    const settings = useSettingsStore();
    const configStore = useConfigUpdateStore();
    const config = configStore.metadataProviders;
    const tab = ref("default");
    const tabsKey2 = computed(() => config.libraryProviders.map((p2) => p2.deleted).join());
    const expansionItems = ref(/* @__PURE__ */ new Set());
    const matchingModeOptions = ["CLOSEST_MATCH", "EXACT"];
    const rolesOptions = ["WRITER", "PENCILLER", "INKER", "COLORIST", "LETTERER", "COVER", "EDITOR", "TRANSLATOR"];
    const mediaTypeOptions = ["MANGA", "NOVEL"];
    const sortableOptions = computed(() => {
      return {
        draggable: ".draggable",
        animation: 150,
        ghostClass: "ghost",
        dragClass: "drag",
        scroll: true,
        scrollSensitivity: 50,
        scrollSpeed: 10,
        bubbleScroll: true,
        handle: ".provider-handle",
        forceFallback: true
      };
    });
    const tabPanel = ref(null);
    const moveItemInArray = (array, from, to) => {
      const item = array.splice(from, 1)[0];
      array.splice(to, 0, item);
    };
    function hideExpandedProviders() {
      let filteredItems = Array.from(expansionItems.value).filter((item) => item != null);
      filteredItems.forEach((item) => item.hide());
      expansionItems.value = new Set(filteredItems);
    }
    function addExpansionItemRef(item) {
      expansionItems.value.add(item);
    }
    function enableProvider(index2) {
      let provider = config.defaultDisabledProviders[index2];
      provider.enabled = true;
      config.defaultProviders.push(provider);
      config.defaultDisabledProviders.splice(index2, 1);
    }
    function enableLibraryProvider(libraryIndex, index2) {
      let provider = config.libraryProviders[libraryIndex].disabledProviders[index2];
      provider.enabled = true;
      config.libraryProviders[libraryIndex].providers.push(provider);
      config.libraryProviders[libraryIndex].disabledProviders.splice(index2, 1);
    }
    function disableProvider(index2) {
      let provider = config.defaultProviders[index2];
      provider.enabled = false;
      config.defaultDisabledProviders.push(provider);
      config.defaultDisabledProviders.sort((a, b) => a.name.localeCompare(b.name));
      config.defaultProviders.splice(index2, 1);
    }
    function disableLibraryProvider(libraryIndex, index2) {
      let provider = config.libraryProviders[libraryIndex].providers[index2];
      provider.enabled = false;
      config.libraryProviders[libraryIndex].disabledProviders.push(provider);
      config.libraryProviders[libraryIndex].providers.splice(index2, 1);
    }
    async function addLibrary(id2) {
      var _a2, _b, _c, _d;
      let existing = config.libraryProviders.find((library) => library.id == id2);
      if (existing) {
        existing.deleted = false;
        await nextTick();
        (_a2 = tabPanel.value) == null ? void 0 : _a2.goTo(id2);
        return;
      }
      let defaultProviders = Object.entries(new DefaultProvidersConfig()).map(([key, value2]) => {
        let books = configStore.providersWithBooks.includes(key);
        let mediaTypeEnabled = configStore.providersWithMediaType.includes(key);
        return {
          name: key,
          books,
          mediaTypeEnabled,
          ...value2
        };
      }).sort((a, b) => a.name.localeCompare(b.name));
      config.libraryProviders.push({
        id: id2,
        name: (_c = (_b = configStore.libraries.find((l) => l.id == id2)) == null ? void 0 : _b.name) != null ? _c : "",
        deleted: false,
        providers: [],
        disabledProviders: defaultProviders
      });
      await nextTick();
      (_d = tabPanel.value) == null ? void 0 : _d.goTo(id2);
    }
    function removeLibrary(index2) {
      var _a2;
      config.libraryProviders[index2].deleted = true;
      (_a2 = tabPanel.value) == null ? void 0 : _a2.goTo("default");
    }
    function getLibraries() {
      let libraryProviders = configStore.metadataProviders.libraryProviders;
      return configStore.libraries.filter((library) => !libraryProviders.find((libraryConfig) => !libraryConfig.deleted && libraryConfig.id == library.id));
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(QCard, {
        flat: "",
        style: { "max-height": "750px" }
      }, {
        default: withCtx(() => [
          (openBlock(), createBlock(QTabs, {
            modelValue: tab.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => tab.value = $event),
            dense: "",
            class: "text-grey",
            "active-color": "primary",
            "indicator-color": "primary",
            align: "justify",
            "narrow-indicator": "",
            key: unref(tabsKey2)
          }, {
            default: withCtx(() => [
              createVNode(QTab, {
                name: "default",
                label: "Default",
                "no-caps": ""
              }),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(config).libraryProviders, (library, index2) => {
                return openBlock(), createElementBlock(Fragment, {
                  key: library.id
                }, [
                  !library.deleted ? (openBlock(), createBlock(QTab, {
                    key: 0,
                    name: library.id,
                    "no-caps": ""
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", null, [
                        createTextVNode(toDisplayString(`${library.name} (${library.id})`) + " ", 1),
                        createVNode(QBtn, {
                          flat: "",
                          size: "xs",
                          "icon-right": unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-close" : "fa fa-xmark",
                          onClick: ($event) => removeLibrary(index2)
                        }, null, 8, ["icon-right", "onClick"])
                      ])
                    ]),
                    _: 2
                  }, 1032, ["name"])) : createCommentVNode("", true)
                ], 64);
              }), 128)),
              getLibraries().length ? (openBlock(), createBlock(QBtn, {
                key: 0,
                flat: ""
              }, {
                default: withCtx(() => [
                  _hoisted_1$9,
                  createBaseVNode("div", _hoisted_2$7, [
                    createVNode(QIcon, {
                      name: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-plus" : "fa fa-plus"
                    }, null, 8, ["name"])
                  ]),
                  createVNode(QMenu, { fit: "" }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(getLibraries(), (library, index2) => {
                        return openBlock(), createBlock(QList, { dense: "" }, {
                          default: withCtx(() => [
                            withDirectives((openBlock(), createBlock(QItem, {
                              clickable: "",
                              onClick: ($event) => addLibrary(library.id)
                            }, {
                              default: withCtx(() => [
                                createVNode(QItemSection, null, {
                                  default: withCtx(() => [
                                    createVNode(QItemLabel, null, {
                                      default: withCtx(() => [
                                        createTextVNode(toDisplayString(library.name), 1)
                                      ]),
                                      _: 2
                                    }, 1024)
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1032, ["onClick"])), [
                              [ClosePopup]
                            ])
                          ]),
                          _: 2
                        }, 1024);
                      }), 256))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["modelValue"])),
          createVNode(QSeparator),
          createVNode(unref(QTabPanels), {
            modelValue: tab.value,
            "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => tab.value = $event),
            ref_key: "tabPanel",
            ref: tabPanel,
            animated: ""
          }, {
            default: withCtx(() => [
              createVNode(QTabPanel, {
                name: "default",
                style: { "padding": "8px 0 0 0" }
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_3$7, [
                    createBaseVNode("div", _hoisted_4$6, [
                      (openBlock(), createBlock(unref(_sfc_main$h), {
                        list: unref(config).defaultProviders,
                        "item-key": "name",
                        options: unref(sortableOptions),
                        key: unref(config).defaultProviders.length,
                        onEnd: _cache[1] || (_cache[1] = (event) => moveItemInArray(unref(config).defaultProviders, event.oldIndex, event.newIndex)),
                        onStart: _cache[2] || (_cache[2] = () => hideExpandedProviders())
                      }, {
                        item: withCtx(({ element, index: index2 }) => [
                          (openBlock(), createBlock(QCard, {
                            bordered: "",
                            class: "draggable provider-card q-mb-sm",
                            key: element.name
                          }, {
                            default: withCtx(() => [
                              createVNode(QCardSection, { class: "q-pa-sm" }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_5$5, [
                                    createBaseVNode("div", _hoisted_6$5, [
                                      createBaseVNode("div", _hoisted_7$3, [
                                        createVNode(QIcon, {
                                          class: "provider-handle",
                                          size: unref(settings).mediaServer === unref(MediaServer).Komga ? "sm" : "xs",
                                          name: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-drag" : "fa fa-grip-vertical"
                                        }, null, 8, ["size", "name"]),
                                        createTextVNode(" " + toDisplayString(`${index2 + 1} - ${element.name}`) + " ", 1),
                                        createVNode(QSpace),
                                        createVNode(QBtn, {
                                          onClick: ($event) => disableProvider(index2),
                                          flat: "",
                                          round: "",
                                          icon: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-close" : "fa fa-xmark",
                                          size: unref(settings).mediaServer === unref(MediaServer).Komga ? "sm" : "xs"
                                        }, null, 8, ["onClick", "icon", "size"])
                                      ])
                                    ]),
                                    createBaseVNode("div", _hoisted_8$3, [
                                      createVNode(QExpansionItem, {
                                        ref: (el) => addExpansionItemRef(el),
                                        dense: "",
                                        "dense-toggle": "",
                                        "expand-separator": "",
                                        label: "Options"
                                      }, {
                                        default: withCtx(() => [
                                          createVNode(QCard, null, {
                                            default: withCtx(() => [
                                              createVNode(QCardSection, { class: "q-pa-sm" }, {
                                                default: withCtx(() => [
                                                  createVNode(QExpansionItem, {
                                                    dense: "",
                                                    "dense-toggle": "",
                                                    "expand-separator": "",
                                                    label: "Series Metadata"
                                                  }, {
                                                    default: withCtx(() => [
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.ageRating,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.ageRating = $event,
                                                        label: "Age Rating"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.authors,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.authors = $event,
                                                        label: "Authors"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.thumbnail,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.thumbnail = $event,
                                                        label: "Cover"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.genres,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.genres = $event,
                                                        label: "Genres"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.language,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.language = $event,
                                                        label: "Language"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.links,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.links = $event,
                                                        label: "Links"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.publisher,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.publisher = $event,
                                                        label: "Publisher"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.useOriginalPublisher,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.useOriginalPublisher = $event,
                                                        label: "Use Original Publisher"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.releaseDate,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.releaseDate = $event,
                                                        label: "Release Date"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.status,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.status = $event,
                                                        label: "Status"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.summary,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.summary = $event,
                                                        label: "Summary"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.tags,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.tags = $event,
                                                        label: "Tags"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.title,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.title = $event,
                                                        label: "Title"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.totalBookCount,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.totalBookCount = $event,
                                                        label: "Book Count"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                    ]),
                                                    _: 2
                                                  }, 1024),
                                                  unref(config).defaultProviders[index2].books ? (openBlock(), createBlock(QExpansionItem, {
                                                    key: 0,
                                                    dense: "",
                                                    "dense-toggle": "",
                                                    "expand-separator": "",
                                                    label: "Book Metadata"
                                                  }, {
                                                    default: withCtx(() => [
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].seriesMetadata.books,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.books = $event,
                                                        label: "Enabled"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].bookMetadata.authors,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].bookMetadata.authors = $event,
                                                        disable: !unref(config).defaultProviders[index2].seriesMetadata.books,
                                                        label: "Authors"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].bookMetadata.thumbnail,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].bookMetadata.thumbnail = $event,
                                                        disable: !unref(config).defaultProviders[index2].seriesMetadata.books,
                                                        label: "Cover"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].bookMetadata.isbn,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].bookMetadata.isbn = $event,
                                                        disable: !unref(config).defaultProviders[index2].seriesMetadata.books,
                                                        label: "ISBN"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].bookMetadata.links,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].bookMetadata.links = $event,
                                                        disable: !unref(config).defaultProviders[index2].seriesMetadata.books,
                                                        label: "Links"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].bookMetadata.number,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].bookMetadata.number = $event,
                                                        disable: !unref(config).defaultProviders[index2].seriesMetadata.books,
                                                        label: "Number"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].bookMetadata.releaseDate,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].bookMetadata.releaseDate = $event,
                                                        disable: !unref(config).defaultProviders[index2].seriesMetadata.books,
                                                        label: "Release Date"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].bookMetadata.summary,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].bookMetadata.summary = $event,
                                                        disable: !unref(config).defaultProviders[index2].seriesMetadata.books,
                                                        label: "Summary"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).defaultProviders[index2].bookMetadata.tags,
                                                        "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].bookMetadata.tags = $event,
                                                        disable: !unref(config).defaultProviders[index2].seriesMetadata.books,
                                                        label: "Tags"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"])
                                                    ]),
                                                    _: 2
                                                  }, 1024)) : createCommentVNode("", true),
                                                  createVNode(QExpansionItem, {
                                                    dense: "",
                                                    "dense-toggle": "",
                                                    "expand-separator": "",
                                                    label: "Misc"
                                                  }, {
                                                    default: withCtx(() => [
                                                      unref(config).defaultProviders[index2].mediaTypeEnabled ? (openBlock(), createElementBlock("div", _hoisted_9$3, [
                                                        createVNode(QSelect, {
                                                          modelValue: unref(config).defaultProviders[index2].mediaType,
                                                          "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].mediaType = $event,
                                                          options: mediaTypeOptions,
                                                          label: "Media Type",
                                                          dense: "",
                                                          filled: ""
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ])) : createCommentVNode("", true),
                                                      createBaseVNode("div", _hoisted_10$3, [
                                                        createVNode(QSelect, {
                                                          modelValue: unref(config).defaultProviders[index2].nameMatchingMode,
                                                          "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].nameMatchingMode = $event,
                                                          options: matchingModeOptions,
                                                          label: "Name Matching Mode",
                                                          dense: "",
                                                          filled: "",
                                                          clearable: ""
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ]),
                                                      createBaseVNode("div", _hoisted_11$2, [
                                                        createVNode(QSelect, {
                                                          modelValue: unref(config).defaultProviders[index2].authorRoles,
                                                          "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].authorRoles = $event,
                                                          options: rolesOptions,
                                                          dense: "",
                                                          filled: "",
                                                          multiple: "",
                                                          label: "Author Roles"
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ]),
                                                      createBaseVNode("div", _hoisted_12$1, [
                                                        createVNode(QSelect, {
                                                          modelValue: unref(config).defaultProviders[index2].artistRoles,
                                                          "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].artistRoles = $event,
                                                          options: rolesOptions,
                                                          dense: "",
                                                          filled: "",
                                                          multiple: "",
                                                          label: "Artist Roles"
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ]),
                                                      createBaseVNode("div", _hoisted_13$1, [
                                                        createVNode(QInput, {
                                                          modelValue: unref(config).defaultProviders[index2].seriesMetadata.englishPublisherTagName,
                                                          "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.englishPublisherTagName = $event,
                                                          label: "English Publisher Tag Name",
                                                          dense: "",
                                                          filled: ""
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ]),
                                                      createBaseVNode("div", _hoisted_14$1, [
                                                        createVNode(QInput, {
                                                          modelValue: unref(config).defaultProviders[index2].seriesMetadata.originalPublisherTagName,
                                                          "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.originalPublisherTagName = $event,
                                                          label: "Original Publisher Tag Name",
                                                          dense: "",
                                                          filled: ""
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ]),
                                                      createBaseVNode("div", _hoisted_15$1, [
                                                        createVNode(QInput, {
                                                          modelValue: unref(config).defaultProviders[index2].seriesMetadata.frenchPublisherTagName,
                                                          "onUpdate:modelValue": ($event) => unref(config).defaultProviders[index2].seriesMetadata.frenchPublisherTagName = $event,
                                                          label: "French Publisher Tag Name",
                                                          dense: "",
                                                          filled: ""
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ])
                                                    ]),
                                                    _: 2
                                                  }, 1024)
                                                ]),
                                                _: 2
                                              }, 1024)
                                            ]),
                                            _: 2
                                          }, 1024)
                                        ]),
                                        _: 2
                                      }, 1536)
                                    ])
                                  ])
                                ]),
                                _: 2
                              }, 1024)
                            ]),
                            _: 2
                          }, 1024))
                        ]),
                        _: 1
                      }, 8, ["list", "options"]))
                    ]),
                    createBaseVNode("div", _hoisted_16$1, [
                      createVNode(QBtn, { color: "secondary" }, {
                        default: withCtx(() => [
                          _hoisted_17$1,
                          createBaseVNode("div", _hoisted_18$1, [
                            createVNode(QIcon, {
                              name: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-plus" : "fa fa-plus"
                            }, null, 8, ["name"])
                          ]),
                          createVNode(QMenu, { "auto-close": "" }, {
                            default: withCtx(() => [
                              createVNode(QList, null, {
                                default: withCtx(() => [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(config).defaultDisabledProviders, (provider, index2) => {
                                    return openBlock(), createBlock(QItem, {
                                      clickable: "",
                                      onClick: ($event) => enableProvider(index2)
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(QItemSection, null, {
                                          default: withCtx(() => [
                                            createVNode(QItemLabel, null, {
                                              default: withCtx(() => [
                                                createTextVNode(toDisplayString(provider.name), 1)
                                              ]),
                                              _: 2
                                            }, 1024)
                                          ]),
                                          _: 2
                                        }, 1024)
                                      ]),
                                      _: 2
                                    }, 1032, ["onClick"]);
                                  }), 256))
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    createBaseVNode("div", _hoisted_19$1, [
                      createVNode(QSelect, {
                        modelValue: unref(config).nameMatchingMode,
                        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(config).nameMatchingMode = $event),
                        options: matchingModeOptions,
                        label: "Name Matching Mode",
                        dense: "",
                        filled: ""
                      }, null, 8, ["modelValue"])
                    ]),
                    createBaseVNode("div", _hoisted_20$1, [
                      createBaseVNode("div", _hoisted_21$1, [
                        createBaseVNode("div", _hoisted_22$1, [
                          createVNode(QInput, {
                            modelValue: unref(config).malClientId,
                            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(config).malClientId = $event),
                            label: "MyAnimeList ClientId",
                            dense: "",
                            filled: "",
                            disable: unref(config).malClientIdDisabled
                          }, null, 8, ["modelValue", "disable"])
                        ]),
                        unref(config).malClientIdDisabled ? (openBlock(), createElementBlock("div", _hoisted_23$1, [
                          createVNode(QBtn, {
                            onClick: _cache[5] || (_cache[5] = ($event) => {
                              unref(config).malClientId = "";
                              unref(config).malClientIdDisabled = false;
                            }),
                            flat: "",
                            round: "",
                            icon: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-pencil" : "fa fa-pencil",
                            size: unref(settings).mediaServer === unref(MediaServer).Komga ? "md" : "sm"
                          }, null, 8, ["icon", "size"])
                        ])) : createCommentVNode("", true)
                      ]),
                      createBaseVNode("div", _hoisted_24$1, [
                        createBaseVNode("div", _hoisted_25$1, [
                          createVNode(QInput, {
                            modelValue: unref(config).comicVineClientId,
                            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(config).comicVineClientId = $event),
                            label: "ComicVine ClientId",
                            dense: "",
                            filled: "",
                            disable: unref(config).comicVineClientIdDisabled
                          }, null, 8, ["modelValue", "disable"])
                        ]),
                        unref(config).comicVineClientIdDisabled ? (openBlock(), createElementBlock("div", _hoisted_26$1, [
                          createVNode(QBtn, {
                            onClick: _cache[7] || (_cache[7] = ($event) => {
                              unref(config).comicVineClientId = "";
                              unref(config).comicVineClientIdDisabled = false;
                            }),
                            flat: "",
                            round: "",
                            icon: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-pencil" : "fa fa-pencil",
                            size: unref(settings).mediaServer === unref(MediaServer).Komga ? "md" : "sm"
                          }, null, 8, ["icon", "size"])
                        ])) : createCommentVNode("", true)
                      ])
                    ])
                  ])
                ]),
                _: 1
              }),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(config).libraryProviders, (library, libraryIndex) => {
                return openBlock(), createElementBlock(Fragment, {
                  key: library.id
                }, [
                  !library.deleted ? (openBlock(), createBlock(QTabPanel, {
                    key: 0,
                    name: library.id,
                    style: { "padding": "8px 0 0 0" }
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(unref(_sfc_main$h), {
                        list: unref(config).libraryProviders[libraryIndex].providers,
                        "item-key": "name",
                        options: unref(sortableOptions),
                        key: unref(config).libraryProviders[libraryIndex].providers.length,
                        onEnd: (event) => moveItemInArray(unref(config).libraryProviders[libraryIndex].providers, event.oldIndex, event.newIndex),
                        onStart: _cache[8] || (_cache[8] = () => hideExpandedProviders())
                      }, {
                        item: withCtx(({ element, index: index2 }) => [
                          (openBlock(), createBlock(QCard, {
                            bordered: "",
                            class: "draggable provider-card q-mb-sm",
                            key: element.name
                          }, {
                            default: withCtx(() => [
                              createVNode(QCardSection, { class: "q-pa-sm" }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_27$1, [
                                    createBaseVNode("div", _hoisted_28$1, [
                                      createBaseVNode("div", _hoisted_29$1, [
                                        createVNode(QIcon, {
                                          class: "provider-handle",
                                          size: unref(settings).mediaServer === unref(MediaServer).Komga ? "sm" : "xs",
                                          name: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-drag" : "fa fa-grip-vertical"
                                        }, null, 8, ["size", "name"]),
                                        createTextVNode(" " + toDisplayString(`${index2 + 1} - ${element.name}`) + " ", 1),
                                        createVNode(QSpace),
                                        createVNode(QBtn, {
                                          onClick: ($event) => disableLibraryProvider(libraryIndex, index2),
                                          flat: "",
                                          round: "",
                                          icon: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-close" : "fa fa-xmark",
                                          size: unref(settings).mediaServer === unref(MediaServer).Komga ? "sm" : "xs"
                                        }, null, 8, ["onClick", "icon", "size"])
                                      ])
                                    ]),
                                    createBaseVNode("div", _hoisted_30$1, [
                                      createVNode(QExpansionItem, {
                                        ref_for: true,
                                        ref: (el) => addExpansionItemRef(el),
                                        dense: "",
                                        "dense-toggle": "",
                                        "expand-separator": "",
                                        label: "Options"
                                      }, {
                                        default: withCtx(() => [
                                          createVNode(QCard, null, {
                                            default: withCtx(() => [
                                              createVNode(QCardSection, { class: "q-pa-sm" }, {
                                                default: withCtx(() => [
                                                  createVNode(QExpansionItem, {
                                                    dense: "",
                                                    "dense-toggle": "",
                                                    "expand-separator": "",
                                                    label: "Series Metadata"
                                                  }, {
                                                    default: withCtx(() => [
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.ageRating,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.ageRating = $event,
                                                        label: "Age Rating"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.authors,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.authors = $event,
                                                        label: "Authors"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.thumbnail,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.thumbnail = $event,
                                                        label: "Cover"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.genres,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.genres = $event,
                                                        label: "Genres"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.language,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.language = $event,
                                                        label: "Language"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.links,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.links = $event,
                                                        label: "Links"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.publisher,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.publisher = $event,
                                                        label: "Publisher"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.useOriginalPublisher,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.useOriginalPublisher = $event,
                                                        label: "Use Original Publisher"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.releaseDate,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.releaseDate = $event,
                                                        label: "Release Date"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.status,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.status = $event,
                                                        label: "Status"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.summary,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.summary = $event,
                                                        label: "Summary"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.tags,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.tags = $event,
                                                        label: "Tags"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.title,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.title = $event,
                                                        label: "Title"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.totalBookCount,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.totalBookCount = $event,
                                                        label: "Book Count"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                    ]),
                                                    _: 2
                                                  }, 1024),
                                                  unref(config).libraryProviders[libraryIndex].providers[index2].books ? (openBlock(), createBlock(QExpansionItem, {
                                                    key: 0,
                                                    dense: "",
                                                    "dense-toggle": "",
                                                    "expand-separator": "",
                                                    label: "Book Metadata"
                                                  }, {
                                                    default: withCtx(() => [
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.books,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.books = $event,
                                                        label: "Enabled"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.authors,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.authors = $event,
                                                        disable: !unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.books,
                                                        label: "Authors"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.thumbnail,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.thumbnail = $event,
                                                        disable: !unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.books,
                                                        label: "Cover"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.isbn,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.isbn = $event,
                                                        disable: !unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.books,
                                                        label: "ISBN"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.links,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.links = $event,
                                                        disable: !unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.books,
                                                        label: "Links"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.number,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.number = $event,
                                                        disable: !unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.books,
                                                        label: "Number"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.releaseDate,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.releaseDate = $event,
                                                        disable: !unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.books,
                                                        label: "Release Date"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.summary,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.summary = $event,
                                                        disable: !unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.books,
                                                        label: "Summary"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"]),
                                                      createVNode(QCheckbox, {
                                                        modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.tags,
                                                        "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].bookMetadata.tags = $event,
                                                        disable: !unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.books,
                                                        label: "Tags"
                                                      }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"])
                                                    ]),
                                                    _: 2
                                                  }, 1024)) : createCommentVNode("", true),
                                                  createVNode(QExpansionItem, {
                                                    dense: "",
                                                    "dense-toggle": "",
                                                    "expand-separator": "",
                                                    label: "Misc"
                                                  }, {
                                                    default: withCtx(() => [
                                                      unref(config).libraryProviders[libraryIndex].providers[index2].mediaTypeEnabled ? (openBlock(), createElementBlock("div", _hoisted_31$1, [
                                                        createVNode(QSelect, {
                                                          modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].mediaType,
                                                          "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].mediaType = $event,
                                                          options: mediaTypeOptions,
                                                          label: "Media Type",
                                                          dense: "",
                                                          filled: ""
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ])) : createCommentVNode("", true),
                                                      createBaseVNode("div", _hoisted_32$1, [
                                                        createVNode(QSelect, {
                                                          modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].nameMatchingMode,
                                                          "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].nameMatchingMode = $event,
                                                          options: matchingModeOptions,
                                                          label: "Name Matching Mode",
                                                          dense: "",
                                                          filled: "",
                                                          clearable: ""
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ]),
                                                      createBaseVNode("div", _hoisted_33$1, [
                                                        createVNode(QSelect, {
                                                          modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].authorRoles,
                                                          "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].authorRoles = $event,
                                                          options: rolesOptions,
                                                          dense: "",
                                                          filled: "",
                                                          multiple: "",
                                                          label: "Author Roles"
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ]),
                                                      createBaseVNode("div", _hoisted_34$1, [
                                                        createVNode(QSelect, {
                                                          modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].artistRoles,
                                                          "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].artistRoles = $event,
                                                          options: rolesOptions,
                                                          dense: "",
                                                          filled: "",
                                                          multiple: "",
                                                          label: "Artist Roles"
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ]),
                                                      createBaseVNode("div", _hoisted_35$1, [
                                                        createVNode(QInput, {
                                                          modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.englishPublisherTagName,
                                                          "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.englishPublisherTagName = $event,
                                                          label: "English Publisher Tag Name",
                                                          dense: "",
                                                          filled: ""
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ]),
                                                      createBaseVNode("div", _hoisted_36$1, [
                                                        createVNode(QInput, {
                                                          modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.originalPublisherTagName,
                                                          "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.originalPublisherTagName = $event,
                                                          label: "Original Publisher Tag Name",
                                                          dense: "",
                                                          filled: ""
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ]),
                                                      createBaseVNode("div", _hoisted_37$1, [
                                                        createVNode(QInput, {
                                                          modelValue: unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.frenchPublisherTagName,
                                                          "onUpdate:modelValue": ($event) => unref(config).libraryProviders[libraryIndex].providers[index2].seriesMetadata.frenchPublisherTagName = $event,
                                                          label: "French Publisher Tag Name",
                                                          dense: "",
                                                          filled: ""
                                                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                                      ])
                                                    ]),
                                                    _: 2
                                                  }, 1024)
                                                ]),
                                                _: 2
                                              }, 1024)
                                            ]),
                                            _: 2
                                          }, 1024)
                                        ]),
                                        _: 2
                                      }, 1536)
                                    ])
                                  ])
                                ]),
                                _: 2
                              }, 1024)
                            ]),
                            _: 2
                          }, 1024))
                        ]),
                        _: 2
                      }, 1032, ["list", "options", "onEnd"])),
                      createVNode(QBtn, {
                        class: "q-mb-sm",
                        color: "secondary"
                      }, {
                        default: withCtx(() => [
                          _hoisted_38$1,
                          createBaseVNode("div", _hoisted_39$1, [
                            createVNode(QIcon, {
                              name: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-plus" : "fa fa-plus"
                            }, null, 8, ["name"])
                          ]),
                          createVNode(QMenu, { "auto-close": "" }, {
                            default: withCtx(() => [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(config).libraryProviders[libraryIndex].disabledProviders, (provider, index2) => {
                                return openBlock(), createBlock(QList, null, {
                                  default: withCtx(() => [
                                    createVNode(QItem, {
                                      clickable: "",
                                      onClick: ($event) => enableLibraryProvider(libraryIndex, index2)
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(QItemSection, null, {
                                          default: withCtx(() => [
                                            createVNode(QItemLabel, null, {
                                              default: withCtx(() => [
                                                createTextVNode(toDisplayString(provider.name), 1)
                                              ]),
                                              _: 2
                                            }, 1024)
                                          ]),
                                          _: 2
                                        }, 1024)
                                      ]),
                                      _: 2
                                    }, 1032, ["onClick"])
                                  ]),
                                  _: 2
                                }, 1024);
                              }), 256))
                            ]),
                            _: 2
                          }, 1024)
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1032, ["name"])) : createCommentVNode("", true)
                ], 64);
              }), 128))
            ]),
            _: 1
          }, 8, ["modelValue"])
        ]),
        _: 1
      });
    };
  }
});
const MetadataProvidersSettingsTab_vue_vue_type_style_index_0_scoped_e7c9ff7c_lang = "";
const MetadataProvidersSettingsTab = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-e7c9ff7c"]]);
/**
 * @name is-language-code
 * @fileoverview Is given string a language code (as per IANA)
 * @version 5.0.3
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/is-language-code/}
 */
var z = ["aa", "aaa", "aab", "aac", "aad", "aae", "aaf", "aag", "aah", "aai", "aak", "aal", "aam", "aan", "aao", "aap", "aaq", "aas", "aat", "aau", "aav", "aaw", "aax", "aaz", "ab", "aba", "abb", "abc", "abd", "abe", "abf", "abg", "abh", "abi", "abj", "abl", "abm", "abn", "abo", "abp", "abq", "abr", "abs", "abt", "abu", "abv", "abw", "abx", "aby", "abz", "aca", "acb", "acd", "ace", "acf", "ach", "aci", "ack", "acl", "acm", "acn", "acp", "acq", "acr", "acs", "act", "acu", "acv", "acw", "acx", "acy", "acz", "ada", "adb", "add", "ade", "adf", "adg", "adh", "adi", "adj", "adl", "adn", "ado", "adp", "adq", "adr", "ads", "adt", "adu", "adw", "adx", "ady", "adz", "ae", "aea", "aeb", "aec", "aed", "aee", "aek", "ael", "aem", "aen", "aeq", "aer", "aes", "aeu", "aew", "aey", "aez", "af", "afa", "afb", "afd", "afe", "afg", "afh", "afi", "afk", "afn", "afo", "afp", "afs", "aft", "afu", "afz", "aga", "agb", "agc", "agd", "age", "agf", "agg", "agh", "agi", "agj", "agk", "agl", "agm", "agn", "ago", "agp", "agq", "agr", "ags", "agt", "agu", "agv", "agw", "agx", "agy", "agz", "aha", "ahb", "ahg", "ahh", "ahi", "ahk", "ahl", "ahm", "ahn", "aho", "ahp", "ahr", "ahs", "aht", "aia", "aib", "aic", "aid", "aie", "aif", "aig", "aih", "aii", "aij", "aik", "ail", "aim", "ain", "aio", "aip", "aiq", "air", "ais", "ait", "aiw", "aix", "aiy", "aja", "ajg", "aji", "ajn", "ajp", "ajt", "aju", "ajw", "ajz", "ak", "akb", "akc", "akd", "ake", "akf", "akg", "akh", "aki", "akj", "akk", "akl", "akm", "ako", "akp", "akq", "akr", "aks", "akt", "aku", "akv", "akw", "akx", "aky", "akz", "ala", "alc", "ald", "ale", "alf", "alg", "alh", "ali", "alj", "alk", "all", "alm", "aln", "alo", "alp", "alq", "alr", "als", "alt", "alu", "alv", "alw", "alx", "aly", "alz", "am", "ama", "amb", "amc", "ame", "amf", "amg", "ami", "amj", "amk", "aml", "amm", "amn", "amo", "amp", "amq", "amr", "ams", "amt", "amu", "amv", "amw", "amx", "amy", "amz", "an", "ana", "anb", "anc", "and", "ane", "anf", "ang", "anh", "ani", "anj", "ank", "anl", "anm", "ann", "ano", "anp", "anq", "anr", "ans", "ant", "anu", "anv", "anw", "anx", "any", "anz", "aoa", "aob", "aoc", "aod", "aoe", "aof", "aog", "aoh", "aoi", "aoj", "aok", "aol", "aom", "aon", "aor", "aos", "aot", "aou", "aox", "aoz", "apa", "apb", "apc", "apd", "ape", "apf", "apg", "aph", "api", "apj", "apk", "apl", "apm", "apn", "apo", "app", "apq", "apr", "aps", "apt", "apu", "apv", "apw", "apx", "apy", "apz", "aqa", "aqc", "aqd", "aqg", "aql", "aqm", "aqn", "aqp", "aqr", "aqt", "aqz", "ar", "arb", "arc", "ard", "are", "arh", "ari", "arj", "ark", "arl", "arn", "aro", "arp", "arq", "arr", "ars", "art", "aru", "arv", "arw", "arx", "ary", "arz", "as", "asa", "asb", "asc", "asd", "ase", "asf", "asg", "ash", "asi", "asj", "ask", "asl", "asn", "aso", "asp", "asq", "asr", "ass", "ast", "asu", "asv", "asw", "asx", "asy", "asz", "ata", "atb", "atc", "atd", "ate", "atg", "ath", "ati", "atj", "atk", "atl", "atm", "atn", "ato", "atp", "atq", "atr", "ats", "att", "atu", "atv", "atw", "atx", "aty", "atz", "aua", "aub", "auc", "aud", "aue", "auf", "aug", "auh", "aui", "auj", "auk", "aul", "aum", "aun", "auo", "aup", "auq", "aur", "aus", "aut", "auu", "auw", "aux", "auy", "auz", "av", "avb", "avd", "avi", "avk", "avl", "avm", "avn", "avo", "avs", "avt", "avu", "avv", "awa", "awb", "awc", "awd", "awe", "awg", "awh", "awi", "awk", "awm", "awn", "awo", "awr", "aws", "awt", "awu", "awv", "aww", "awx", "awy", "axb", "axe", "axg", "axk", "axl", "axm", "axx", "ay", "aya", "ayb", "ayc", "ayd", "aye", "ayg", "ayh", "ayi", "ayk", "ayl", "ayn", "ayo", "ayp", "ayq", "ayr", "ays", "ayt", "ayu", "ayx", "ayy", "ayz", "az", "aza", "azb", "azc", "azd", "azg", "azj", "azm", "azn", "azo", "azt", "azz", "ba", "baa", "bab", "bac", "bad", "bae", "baf", "bag", "bah", "bai", "baj", "bal", "ban", "bao", "bap", "bar", "bas", "bat", "bau", "bav", "baw", "bax", "bay", "baz", "bba", "bbb", "bbc", "bbd", "bbe", "bbf", "bbg", "bbh", "bbi", "bbj", "bbk", "bbl", "bbm", "bbn", "bbo", "bbp", "bbq", "bbr", "bbs", "bbt", "bbu", "bbv", "bbw", "bbx", "bby", "bbz", "bca", "bcb", "bcc", "bcd", "bce", "bcf", "bcg", "bch", "bci", "bcj", "bck", "bcl", "bcm", "bcn", "bco", "bcp", "bcq", "bcr", "bcs", "bct", "bcu", "bcv", "bcw", "bcy", "bcz", "bda", "bdb", "bdc", "bdd", "bde", "bdf", "bdg", "bdh", "bdi", "bdj", "bdk", "bdl", "bdm", "bdn", "bdo", "bdp", "bdq", "bdr", "bds", "bdt", "bdu", "bdv", "bdw", "bdx", "bdy", "bdz", "be", "bea", "beb", "bec", "bed", "bee", "bef", "beg", "beh", "bei", "bej", "bek", "bem", "beo", "bep", "beq", "ber", "bes", "bet", "beu", "bev", "bew", "bex", "bey", "bez", "bfa", "bfb", "bfc", "bfd", "bfe", "bff", "bfg", "bfh", "bfi", "bfj", "bfk", "bfl", "bfm", "bfn", "bfo", "bfp", "bfq", "bfr", "bfs", "bft", "bfu", "bfw", "bfx", "bfy", "bfz", "bg", "bga", "bgb", "bgc", "bgd", "bge", "bgf", "bgg", "bgi", "bgj", "bgk", "bgl", "bgm", "bgn", "bgo", "bgp", "bgq", "bgr", "bgs", "bgt", "bgu", "bgv", "bgw", "bgx", "bgy", "bgz", "bh", "bha", "bhb", "bhc", "bhd", "bhe", "bhf", "bhg", "bhh", "bhi", "bhj", "bhk", "bhl", "bhm", "bhn", "bho", "bhp", "bhq", "bhr", "bhs", "bht", "bhu", "bhv", "bhw", "bhx", "bhy", "bhz", "bi", "bia", "bib", "bic", "bid", "bie", "bif", "big", "bij", "bik", "bil", "bim", "bin", "bio", "bip", "biq", "bir", "bit", "biu", "biv", "biw", "bix", "biy", "biz", "bja", "bjb", "bjc", "bjd", "bje", "bjf", "bjg", "bjh", "bji", "bjj", "bjk", "bjl", "bjm", "bjn", "bjo", "bjp", "bjq", "bjr", "bjs", "bjt", "bju", "bjv", "bjw", "bjx", "bjy", "bjz", "bka", "bkb", "bkc", "bkd", "bkf", "bkg", "bkh", "bki", "bkj", "bkk", "bkl", "bkm", "bkn", "bko", "bkp", "bkq", "bkr", "bks", "bkt", "bku", "bkv", "bkw", "bkx", "bky", "bkz", "bla", "blb", "blc", "bld", "ble", "blf", "blg", "blh", "bli", "blj", "blk", "bll", "blm", "bln", "blo", "blp", "blq", "blr", "bls", "blt", "blv", "blw", "blx", "bly", "blz", "bm", "bma", "bmb", "bmc", "bmd", "bme", "bmf", "bmg", "bmh", "bmi", "bmj", "bmk", "bml", "bmm", "bmn", "bmo", "bmp", "bmq", "bmr", "bms", "bmt", "bmu", "bmv", "bmw", "bmx", "bmy", "bmz", "bn", "bna", "bnb", "bnc", "bnd", "bne", "bnf", "bng", "bni", "bnj", "bnk", "bnl", "bnm", "bnn", "bno", "bnp", "bnq", "bnr", "bns", "bnt", "bnu", "bnv", "bnw", "bnx", "bny", "bnz", "bo", "boa", "bob", "boe", "bof", "bog", "boh", "boi", "boj", "bok", "bol", "bom", "bon", "boo", "bop", "boq", "bor", "bot", "bou", "bov", "bow", "box", "boy", "boz", "bpa", "bpb", "bpd", "bpg", "bph", "bpi", "bpj", "bpk", "bpl", "bpm", "bpn", "bpo", "bpp", "bpq", "bpr", "bps", "bpt", "bpu", "bpv", "bpw", "bpx", "bpy", "bpz", "bqa", "bqb", "bqc", "bqd", "bqf", "bqg", "bqh", "bqi", "bqj", "bqk", "bql", "bqm", "bqn", "bqo", "bqp", "bqq", "bqr", "bqs", "bqt", "bqu", "bqv", "bqw", "bqx", "bqy", "bqz", "br", "bra", "brb", "brc", "brd", "brf", "brg", "brh", "bri", "brj", "brk", "brl", "brm", "brn", "bro", "brp", "brq", "brr", "brs", "brt", "bru", "brv", "brw", "brx", "bry", "brz", "bs", "bsa", "bsb", "bsc", "bse", "bsf", "bsg", "bsh", "bsi", "bsj", "bsk", "bsl", "bsm", "bsn", "bso", "bsp", "bsq", "bsr", "bss", "bst", "bsu", "bsv", "bsw", "bsx", "bsy", "bta", "btb", "btc", "btd", "bte", "btf", "btg", "bth", "bti", "btj", "btk", "btl", "btm", "btn", "bto", "btp", "btq", "btr", "bts", "btt", "btu", "btv", "btw", "btx", "bty", "btz", "bua", "bub", "buc", "bud", "bue", "buf", "bug", "buh", "bui", "buj", "buk", "bum", "bun", "buo", "bup", "buq", "bus", "but", "buu", "buv", "buw", "bux", "buy", "buz", "bva", "bvb", "bvc", "bvd", "bve", "bvf", "bvg", "bvh", "bvi", "bvj", "bvk", "bvl", "bvm", "bvn", "bvo", "bvp", "bvq", "bvr", "bvt", "bvu", "bvv", "bvw", "bvx", "bvy", "bvz", "bwa", "bwb", "bwc", "bwd", "bwe", "bwf", "bwg", "bwh", "bwi", "bwj", "bwk", "bwl", "bwm", "bwn", "bwo", "bwp", "bwq", "bwr", "bws", "bwt", "bwu", "bww", "bwx", "bwy", "bwz", "bxa", "bxb", "bxc", "bxd", "bxe", "bxf", "bxg", "bxh", "bxi", "bxj", "bxk", "bxl", "bxm", "bxn", "bxo", "bxp", "bxq", "bxr", "bxs", "bxu", "bxv", "bxw", "bxx", "bxz", "bya", "byb", "byc", "byd", "bye", "byf", "byg", "byh", "byi", "byj", "byk", "byl", "bym", "byn", "byo", "byp", "byq", "byr", "bys", "byt", "byv", "byw", "byx", "byy", "byz", "bza", "bzb", "bzc", "bzd", "bze", "bzf", "bzg", "bzh", "bzi", "bzj", "bzk", "bzl", "bzm", "bzn", "bzo", "bzp", "bzq", "bzr", "bzs", "bzt", "bzu", "bzv", "bzw", "bzx", "bzy", "bzz", "ca", "caa", "cab", "cac", "cad", "cae", "caf", "cag", "cah", "cai", "caj", "cak", "cal", "cam", "can", "cao", "cap", "caq", "car", "cas", "cau", "cav", "caw", "cax", "cay", "caz", "cba", "cbb", "cbc", "cbd", "cbe", "cbg", "cbh", "cbi", "cbj", "cbk", "cbl", "cbn", "cbo", "cbq", "cbr", "cbs", "cbt", "cbu", "cbv", "cbw", "cby", "cca", "ccc", "ccd", "cce", "ccg", "cch", "ccj", "ccl", "ccm", "ccn", "cco", "ccp", "ccq", "ccr", "ccs", "cda", "cdc", "cdd", "cde", "cdf", "cdg", "cdh", "cdi", "cdj", "cdm", "cdn", "cdo", "cdr", "cds", "cdy", "cdz", "ce", "cea", "ceb", "ceg", "cek", "cel", "cen", "cet", "cey", "cfa", "cfd", "cfg", "cfm", "cga", "cgc", "cgg", "cgk", "ch", "chb", "chc", "chd", "chf", "chg", "chh", "chj", "chk", "chl", "chm", "chn", "cho", "chp", "chq", "chr", "cht", "chw", "chx", "chy", "chz", "cia", "cib", "cic", "cid", "cie", "cih", "cik", "cim", "cin", "cip", "cir", "ciw", "ciy", "cja", "cje", "cjh", "cji", "cjk", "cjm", "cjn", "cjo", "cjp", "cjr", "cjs", "cjv", "cjy", "cka", "ckb", "ckh", "ckl", "ckn", "cko", "ckq", "ckr", "cks", "ckt", "cku", "ckv", "ckx", "cky", "ckz", "cla", "clc", "cld", "cle", "clh", "cli", "clj", "clk", "cll", "clm", "clo", "clt", "clu", "clw", "cly", "cma", "cmc", "cme", "cmg", "cmi", "cmk", "cml", "cmm", "cmn", "cmo", "cmr", "cms", "cmt", "cna", "cnb", "cnc", "cng", "cnh", "cni", "cnk", "cnl", "cno", "cnr", "cns", "cnt", "cnu", "cnw", "cnx", "co", "coa", "cob", "coc", "cod", "coe", "cof", "cog", "coh", "coj", "cok", "col", "com", "con", "coo", "cop", "coq", "cot", "cou", "cov", "cow", "cox", "coy", "coz", "cpa", "cpb", "cpc", "cpe", "cpf", "cpg", "cpi", "cpn", "cpo", "cpp", "cps", "cpu", "cpx", "cpy", "cqd", "cqu", "cr", "cra", "crb", "crc", "crd", "crf", "crg", "crh", "cri", "crj", "crk", "crl", "crm", "crn", "cro", "crp", "crq", "crr", "crs", "crt", "crv", "crw", "crx", "cry", "crz", "cs", "csa", "csb", "csc", "csd", "cse", "csf", "csg", "csh", "csi", "csj", "csk", "csl", "csm", "csn", "cso", "csq", "csr", "css", "cst", "csu", "csv", "csw", "csy", "csz", "cta", "ctc", "ctd", "cte", "ctg", "cth", "ctl", "ctm", "ctn", "cto", "ctp", "cts", "ctt", "ctu", "ctz", "cu", "cua", "cub", "cuc", "cug", "cuh", "cui", "cuj", "cuk", "cul", "cum", "cuo", "cup", "cuq", "cur", "cus", "cut", "cuu", "cuv", "cuw", "cux", "cuy", "cv", "cvg", "cvn", "cwa", "cwb", "cwd", "cwe", "cwg", "cwt", "cy", "cya", "cyb", "cyo", "czh", "czk", "czn", "czo", "czt", "da", "daa", "dac", "dad", "dae", "daf", "dag", "dah", "dai", "daj", "dak", "dal", "dam", "dao", "dap", "daq", "dar", "das", "dau", "dav", "daw", "dax", "day", "daz", "dba", "dbb", "dbd", "dbe", "dbf", "dbg", "dbi", "dbj", "dbl", "dbm", "dbn", "dbo", "dbp", "dbq", "dbr", "dbt", "dbu", "dbv", "dbw", "dby", "dcc", "dcr", "dda", "ddd", "dde", "ddg", "ddi", "ddj", "ddn", "ddo", "ddr", "dds", "ddw", "de", "dec", "ded", "dee", "def", "deg", "deh", "dei", "dek", "del", "dem", "den", "dep", "deq", "der", "des", "dev", "dez", "dga", "dgb", "dgc", "dgd", "dge", "dgg", "dgh", "dgi", "dgk", "dgl", "dgn", "dgo", "dgr", "dgs", "dgt", "dgu", "dgw", "dgx", "dgz", "dha", "dhd", "dhg", "dhi", "dhl", "dhm", "dhn", "dho", "dhr", "dhs", "dhu", "dhv", "dhw", "dhx", "dia", "dib", "dic", "did", "dif", "dig", "dih", "dii", "dij", "dik", "dil", "dim", "din", "dio", "dip", "diq", "dir", "dis", "dit", "diu", "diw", "dix", "diy", "diz", "dja", "djb", "djc", "djd", "dje", "djf", "dji", "djj", "djk", "djl", "djm", "djn", "djo", "djr", "dju", "djw", "dka", "dkk", "dkl", "dkr", "dks", "dkx", "dlg", "dlk", "dlm", "dln", "dma", "dmb", "dmc", "dmd", "dme", "dmg", "dmk", "dml", "dmm", "dmn", "dmo", "dmr", "dms", "dmu", "dmv", "dmw", "dmx", "dmy", "dna", "dnd", "dne", "dng", "dni", "dnj", "dnk", "dnn", "dno", "dnr", "dnt", "dnu", "dnv", "dnw", "dny", "doa", "dob", "doc", "doe", "dof", "doh", "doi", "dok", "dol", "don", "doo", "dop", "doq", "dor", "dos", "dot", "dov", "dow", "dox", "doy", "doz", "dpp", "dra", "drb", "drc", "drd", "dre", "drg", "drh", "dri", "drl", "drn", "dro", "drq", "drr", "drs", "drt", "dru", "drw", "dry", "dsb", "dse", "dsh", "dsi", "dsl", "dsn", "dso", "dsq", "dta", "dtb", "dtd", "dth", "dti", "dtk", "dtm", "dtn", "dto", "dtp", "dtr", "dts", "dtt", "dtu", "dty", "dua", "dub", "duc", "dud", "due", "duf", "dug", "duh", "dui", "duj", "duk", "dul", "dum", "dun", "duo", "dup", "duq", "dur", "dus", "duu", "duv", "duw", "dux", "duy", "duz", "dv", "dva", "dwa", "dwl", "dwr", "dws", "dwu", "dww", "dwy", "dwz", "dya", "dyb", "dyd", "dyg", "dyi", "dym", "dyn", "dyo", "dyu", "dyy", "dz", "dza", "dzd", "dze", "dzg", "dzl", "dzn", "eaa", "ebg", "ebk", "ebo", "ebr", "ebu", "ecr", "ecs", "ecy", "ee", "eee", "efa", "efe", "efi", "ega", "egl", "ego", "egx", "egy", "ehu", "eip", "eit", "eiv", "eja", "eka", "ekc", "eke", "ekg", "eki", "ekk", "ekl", "ekm", "eko", "ekp", "ekr", "eky", "el", "ele", "elh", "eli", "elk", "elm", "elo", "elp", "elu", "elx", "ema", "emb", "eme", "emg", "emi", "emk", "emm", "emn", "emo", "emp", "ems", "emu", "emw", "emx", "emy", "en", "ena", "enb", "enc", "end", "enf", "enh", "enl", "enm", "enn", "eno", "enq", "enr", "enu", "env", "enw", "enx", "eo", "eot", "epi", "era", "erg", "erh", "eri", "erk", "ero", "err", "ers", "ert", "erw", "es", "ese", "esg", "esh", "esi", "esk", "esl", "esm", "esn", "eso", "esq", "ess", "esu", "esx", "esy", "et", "etb", "etc", "eth", "etn", "eto", "etr", "ets", "ett", "etu", "etx", "etz", "eu", "euq", "eve", "evh", "evn", "ewo", "ext", "eya", "eyo", "eza", "eze", "fa", "faa", "fab", "fad", "faf", "fag", "fah", "fai", "faj", "fak", "fal", "fam", "fan", "fap", "far", "fat", "fau", "fax", "fay", "faz", "fbl", "fcs", "fer", "ff", "ffi", "ffm", "fgr", "fi", "fia", "fie", "fil", "fip", "fir", "fit", "fiu", "fiw", "fj", "fkk", "fkv", "fla", "flh", "fli", "fll", "fln", "flr", "fly", "fmp", "fmu", "fnb", "fng", "fni", "fo", "fod", "foi", "fom", "fon", "for", "fos", "fox", "fpe", "fqs", "fr", "frc", "frd", "frk", "frm", "fro", "frp", "frq", "frr", "frs", "frt", "fse", "fsl", "fss", "fub", "fuc", "fud", "fue", "fuf", "fuh", "fui", "fuj", "fum", "fun", "fuq", "fur", "fut", "fuu", "fuv", "fuy", "fvr", "fwa", "fwe", "fy", "ga", "gaa", "gab", "gac", "gad", "gae", "gaf", "gag", "gah", "gai", "gaj", "gak", "gal", "gam", "gan", "gao", "gap", "gaq", "gar", "gas", "gat", "gau", "gav", "gaw", "gax", "gay", "gaz", "gba", "gbb", "gbc", "gbd", "gbe", "gbf", "gbg", "gbh", "gbi", "gbj", "gbk", "gbl", "gbm", "gbn", "gbo", "gbp", "gbq", "gbr", "gbs", "gbu", "gbv", "gbw", "gbx", "gby", "gbz", "gcc", "gcd", "gce", "gcf", "gcl", "gcn", "gcr", "gct", "gd", "gda", "gdb", "gdc", "gdd", "gde", "gdf", "gdg", "gdh", "gdi", "gdj", "gdk", "gdl", "gdm", "gdn", "gdo", "gdq", "gdr", "gds", "gdt", "gdu", "gdx", "gea", "geb", "gec", "ged", "geg", "geh", "gei", "gej", "gek", "gel", "gem", "geq", "ges", "gev", "gew", "gex", "gey", "gez", "gfk", "gft", "gfx", "gga", "ggb", "ggd", "gge", "ggg", "ggk", "ggl", "ggn", "ggo", "ggr", "ggt", "ggu", "ggw", "gha", "ghc", "ghe", "ghh", "ghk", "ghl", "ghn", "gho", "ghr", "ghs", "ght", "gia", "gib", "gic", "gid", "gie", "gig", "gih", "gil", "gim", "gin", "gio", "gip", "giq", "gir", "gis", "git", "giu", "giw", "gix", "giy", "giz", "gji", "gjk", "gjm", "gjn", "gjr", "gju", "gka", "gkd", "gke", "gkn", "gko", "gkp", "gku", "gl", "glc", "gld", "glh", "gli", "glj", "glk", "gll", "glo", "glr", "glu", "glw", "gly", "gma", "gmb", "gmd", "gme", "gmg", "gmh", "gml", "gmm", "gmn", "gmq", "gmu", "gmv", "gmw", "gmx", "gmy", "gmz", "gn", "gna", "gnb", "gnc", "gnd", "gne", "gng", "gnh", "gni", "gnj", "gnk", "gnl", "gnm", "gnn", "gno", "gnq", "gnr", "gnt", "gnu", "gnw", "gnz", "goa", "gob", "goc", "god", "goe", "gof", "gog", "goh", "goi", "goj", "gok", "gol", "gom", "gon", "goo", "gop", "goq", "gor", "gos", "got", "gou", "gow", "gox", "goy", "goz", "gpa", "gpe", "gpn", "gqa", "gqi", "gqn", "gqr", "gqu", "gra", "grb", "grc", "grd", "grg", "grh", "gri", "grj", "grk", "grm", "gro", "grq", "grr", "grs", "grt", "gru", "grv", "grw", "grx", "gry", "grz", "gse", "gsg", "gsl", "gsm", "gsn", "gso", "gsp", "gss", "gsw", "gta", "gti", "gtu", "gu", "gua", "gub", "guc", "gud", "gue", "guf", "gug", "guh", "gui", "guk", "gul", "gum", "gun", "guo", "gup", "guq", "gur", "gus", "gut", "guu", "guv", "guw", "gux", "guz", "gv", "gva", "gvc", "gve", "gvf", "gvj", "gvl", "gvm", "gvn", "gvo", "gvp", "gvr", "gvs", "gvy", "gwa", "gwb", "gwc", "gwd", "gwe", "gwf", "gwg", "gwi", "gwj", "gwm", "gwn", "gwr", "gwt", "gwu", "gww", "gwx", "gxx", "gya", "gyb", "gyd", "gye", "gyf", "gyg", "gyi", "gyl", "gym", "gyn", "gyo", "gyr", "gyy", "gza", "gzi", "gzn", "ha", "haa", "hab", "hac", "had", "hae", "haf", "hag", "hah", "hai", "haj", "hak", "hal", "ham", "han", "hao", "hap", "haq", "har", "has", "hav", "haw", "hax", "hay", "haz", "hba", "hbb", "hbn", "hbo", "hbu", "hca", "hch", "hdn", "hds", "hdy", "he", "hea", "hed", "heg", "heh", "hei", "hem", "hgm", "hgw", "hhi", "hhr", "hhy", "hi", "hia", "hib", "hid", "hif", "hig", "hih", "hii", "hij", "hik", "hil", "him", "hio", "hir", "hit", "hiw", "hix", "hji", "hka", "hke", "hkk", "hkn", "hks", "hla", "hlb", "hld", "hle", "hlt", "hlu", "hma", "hmb", "hmc", "hmd", "hme", "hmf", "hmg", "hmh", "hmi", "hmj", "hmk", "hml", "hmm", "hmn", "hmp", "hmq", "hmr", "hms", "hmt", "hmu", "hmv", "hmw", "hmx", "hmy", "hmz", "hna", "hnd", "hne", "hnh", "hni", "hnj", "hnn", "hno", "hns", "hnu", "ho", "hoa", "hob", "hoc", "hod", "hoe", "hoh", "hoi", "hoj", "hok", "hol", "hom", "hoo", "hop", "hor", "hos", "hot", "hov", "how", "hoy", "hoz", "hpo", "hps", "hr", "hra", "hrc", "hre", "hrk", "hrm", "hro", "hrp", "hrr", "hrt", "hru", "hrw", "hrx", "hrz", "hsb", "hsh", "hsl", "hsn", "hss", "ht", "hti", "hto", "hts", "htu", "htx", "hu", "hub", "huc", "hud", "hue", "huf", "hug", "huh", "hui", "huj", "huk", "hul", "hum", "huo", "hup", "huq", "hur", "hus", "hut", "huu", "huv", "huw", "hux", "huy", "huz", "hvc", "hve", "hvk", "hvn", "hvv", "hwa", "hwc", "hwo", "hy", "hya", "hyw", "hyx", "hz", "ia", "iai", "ian", "iap", "iar", "iba", "ibb", "ibd", "ibe", "ibg", "ibh", "ibi", "ibl", "ibm", "ibn", "ibr", "ibu", "iby", "ica", "ich", "icl", "icr", "id", "ida", "idb", "idc", "idd", "ide", "idi", "idr", "ids", "idt", "idu", "ie", "ifa", "ifb", "ife", "iff", "ifk", "ifm", "ifu", "ify", "ig", "igb", "ige", "igg", "igl", "igm", "ign", "igo", "igs", "igw", "ihb", "ihi", "ihp", "ihw", "ii", "iin", "iir", "ijc", "ije", "ijj", "ijn", "ijo", "ijs", "ik", "ike", "iki", "ikk", "ikl", "iko", "ikp", "ikr", "iks", "ikt", "ikv", "ikw", "ikx", "ikz", "ila", "ilb", "ilg", "ili", "ilk", "ill", "ilm", "ilo", "ilp", "ils", "ilu", "ilv", "ilw", "ima", "ime", "imi", "iml", "imn", "imo", "imr", "ims", "imy", "in", "inb", "inc", "ine", "ing", "inh", "inj", "inl", "inm", "inn", "ino", "inp", "ins", "int", "inz", "io", "ior", "iou", "iow", "ipi", "ipo", "iqu", "iqw", "ira", "ire", "irh", "iri", "irk", "irn", "iro", "irr", "iru", "irx", "iry", "is", "isa", "isc", "isd", "ise", "isg", "ish", "isi", "isk", "ism", "isn", "iso", "isr", "ist", "isu", "it", "itb", "itc", "itd", "ite", "iti", "itk", "itl", "itm", "ito", "itr", "its", "itt", "itv", "itw", "itx", "ity", "itz", "iu", "ium", "ivb", "ivv", "iw", "iwk", "iwm", "iwo", "iws", "ixc", "ixl", "iya", "iyo", "iyx", "izh", "izi", "izr", "izz", "ja", "jaa", "jab", "jac", "jad", "jae", "jaf", "jah", "jaj", "jak", "jal", "jam", "jan", "jao", "jaq", "jar", "jas", "jat", "jau", "jax", "jay", "jaz", "jbe", "jbi", "jbj", "jbk", "jbn", "jbo", "jbr", "jbt", "jbu", "jbw", "jcs", "jct", "jda", "jdg", "jdt", "jeb", "jee", "jeg", "jeh", "jei", "jek", "jel", "jen", "jer", "jet", "jeu", "jgb", "jge", "jgk", "jgo", "jhi", "jhs", "ji", "jia", "jib", "jic", "jid", "jie", "jig", "jih", "jii", "jil", "jim", "jio", "jiq", "jit", "jiu", "jiv", "jiy", "jje", "jjr", "jka", "jkm", "jko", "jkp", "jkr", "jku", "jle", "jls", "jma", "jmb", "jmc", "jmd", "jmi", "jml", "jmn", "jmr", "jms", "jmw", "jmx", "jna", "jnd", "jng", "jni", "jnj", "jnl", "jns", "job", "jod", "jog", "jor", "jos", "jow", "jpa", "jpr", "jpx", "jqr", "jra", "jrb", "jrr", "jrt", "jru", "jsl", "jua", "jub", "juc", "jud", "juh", "jui", "juk", "jul", "jum", "jun", "juo", "jup", "jur", "jus", "jut", "juu", "juw", "juy", "jv", "jvd", "jvn", "jw", "jwi", "jya", "jye", "jyy", "ka", "kaa", "kab", "kac", "kad", "kae", "kaf", "kag", "kah", "kai", "kaj", "kak", "kam", "kao", "kap", "kaq", "kar", "kav", "kaw", "kax", "kay", "kba", "kbb", "kbc", "kbd", "kbe", "kbf", "kbg", "kbh", "kbi", "kbj", "kbk", "kbl", "kbm", "kbn", "kbo", "kbp", "kbq", "kbr", "kbs", "kbt", "kbu", "kbv", "kbw", "kbx", "kby", "kbz", "kca", "kcb", "kcc", "kcd", "kce", "kcf", "kcg", "kch", "kci", "kcj", "kck", "kcl", "kcm", "kcn", "kco", "kcp", "kcq", "kcr", "kcs", "kct", "kcu", "kcv", "kcw", "kcx", "kcy", "kcz", "kda", "kdc", "kdd", "kde", "kdf", "kdg", "kdh", "kdi", "kdj", "kdk", "kdl", "kdm", "kdn", "kdo", "kdp", "kdq", "kdr", "kdt", "kdu", "kdv", "kdw", "kdx", "kdy", "kdz", "kea", "keb", "kec", "ked", "kee", "kef", "keg", "keh", "kei", "kej", "kek", "kel", "kem", "ken", "keo", "kep", "keq", "ker", "kes", "ket", "keu", "kev", "kew", "kex", "key", "kez", "kfa", "kfb", "kfc", "kfd", "kfe", "kff", "kfg", "kfh", "kfi", "kfj", "kfk", "kfl", "kfm", "kfn", "kfo", "kfp", "kfq", "kfr", "kfs", "kft", "kfu", "kfv", "kfw", "kfx", "kfy", "kfz", "kg", "kga", "kgb", "kgc", "kgd", "kge", "kgf", "kgg", "kgh", "kgi", "kgj", "kgk", "kgl", "kgm", "kgn", "kgo", "kgp", "kgq", "kgr", "kgs", "kgt", "kgu", "kgv", "kgw", "kgx", "kgy", "kha", "khb", "khc", "khd", "khe", "khf", "khg", "khh", "khi", "khj", "khk", "khl", "khn", "kho", "khp", "khq", "khr", "khs", "kht", "khu", "khv", "khw", "khx", "khy", "khz", "ki", "kia", "kib", "kic", "kid", "kie", "kif", "kig", "kih", "kii", "kij", "kil", "kim", "kio", "kip", "kiq", "kis", "kit", "kiu", "kiv", "kiw", "kix", "kiy", "kiz", "kj", "kja", "kjb", "kjc", "kjd", "kje", "kjf", "kjg", "kjh", "kji", "kjj", "kjk", "kjl", "kjm", "kjn", "kjo", "kjp", "kjq", "kjr", "kjs", "kjt", "kju", "kjv", "kjx", "kjy", "kjz", "kk", "kka", "kkb", "kkc", "kkd", "kke", "kkf", "kkg", "kkh", "kki", "kkj", "kkk", "kkl", "kkm", "kkn", "kko", "kkp", "kkq", "kkr", "kks", "kkt", "kku", "kkv", "kkw", "kkx", "kky", "kkz", "kl", "kla", "klb", "klc", "kld", "kle", "klf", "klg", "klh", "kli", "klj", "klk", "kll", "klm", "kln", "klo", "klp", "klq", "klr", "kls", "klt", "klu", "klv", "klw", "klx", "kly", "klz", "km", "kma", "kmb", "kmc", "kmd", "kme", "kmf", "kmg", "kmh", "kmi", "kmj", "kmk", "kml", "kmm", "kmn", "kmo", "kmp", "kmq", "kmr", "kms", "kmt", "kmu", "kmv", "kmw", "kmx", "kmy", "kmz", "kn", "kna", "knb", "knc", "knd", "kne", "knf", "kng", "kni", "knj", "knk", "knl", "knm", "knn", "kno", "knp", "knq", "knr", "kns", "knt", "knu", "knv", "knw", "knx", "kny", "knz", "ko", "koa", "koc", "kod", "koe", "kof", "kog", "koh", "koi", "koj", "kok", "kol", "koo", "kop", "koq", "kos", "kot", "kou", "kov", "kow", "kox", "koy", "koz", "kpa", "kpb", "kpc", "kpd", "kpe", "kpf", "kpg", "kph", "kpi", "kpj", "kpk", "kpl", "kpm", "kpn", "kpo", "kpp", "kpq", "kpr", "kps", "kpt", "kpu", "kpv", "kpw", "kpx", "kpy", "kpz", "kqa", "kqb", "kqc", "kqd", "kqe", "kqf", "kqg", "kqh", "kqi", "kqj", "kqk", "kql", "kqm", "kqn", "kqo", "kqp", "kqq", "kqr", "kqs", "kqt", "kqu", "kqv", "kqw", "kqx", "kqy", "kqz", "kr", "kra", "krb", "krc", "krd", "kre", "krf", "krh", "kri", "krj", "krk", "krl", "krm", "krn", "kro", "krp", "krr", "krs", "krt", "kru", "krv", "krw", "krx", "kry", "krz", "ks", "ksa", "ksb", "ksc", "ksd", "kse", "ksf", "ksg", "ksh", "ksi", "ksj", "ksk", "ksl", "ksm", "ksn", "kso", "ksp", "ksq", "ksr", "kss", "kst", "ksu", "ksv", "ksw", "ksx", "ksy", "ksz", "kta", "ktb", "ktc", "ktd", "kte", "ktf", "ktg", "kth", "kti", "ktj", "ktk", "ktl", "ktm", "ktn", "kto", "ktp", "ktq", "ktr", "kts", "ktt", "ktu", "ktv", "ktw", "ktx", "kty", "ktz", "ku", "kub", "kuc", "kud", "kue", "kuf", "kug", "kuh", "kui", "kuj", "kuk", "kul", "kum", "kun", "kuo", "kup", "kuq", "kus", "kut", "kuu", "kuv", "kuw", "kux", "kuy", "kuz", "kv", "kva", "kvb", "kvc", "kvd", "kve", "kvf", "kvg", "kvh", "kvi", "kvj", "kvk", "kvl", "kvm", "kvn", "kvo", "kvp", "kvq", "kvr", "kvs", "kvt", "kvu", "kvv", "kvw", "kvx", "kvy", "kvz", "kw", "kwa", "kwb", "kwc", "kwd", "kwe", "kwf", "kwg", "kwh", "kwi", "kwj", "kwk", "kwl", "kwm", "kwn", "kwo", "kwp", "kwq", "kwr", "kws", "kwt", "kwu", "kwv", "kww", "kwx", "kwy", "kwz", "kxa", "kxb", "kxc", "kxd", "kxe", "kxf", "kxh", "kxi", "kxj", "kxk", "kxl", "kxm", "kxn", "kxo", "kxp", "kxq", "kxr", "kxs", "kxt", "kxu", "kxv", "kxw", "kxx", "kxy", "kxz", "ky", "kya", "kyb", "kyc", "kyd", "kye", "kyf", "kyg", "kyh", "kyi", "kyj", "kyk", "kyl", "kym", "kyn", "kyo", "kyp", "kyq", "kyr", "kys", "kyt", "kyu", "kyv", "kyw", "kyx", "kyy", "kyz", "kza", "kzb", "kzc", "kzd", "kze", "kzf", "kzg", "kzh", "kzi", "kzj", "kzk", "kzl", "kzm", "kzn", "kzo", "kzp", "kzq", "kzr", "kzs", "kzt", "kzu", "kzv", "kzw", "kzx", "kzy", "kzz", "la", "laa", "lab", "lac", "lad", "lae", "laf", "lag", "lah", "lai", "laj", "lak", "lal", "lam", "lan", "lap", "laq", "lar", "las", "lau", "law", "lax", "lay", "laz", "lb", "lba", "lbb", "lbc", "lbe", "lbf", "lbg", "lbi", "lbj", "lbk", "lbl", "lbm", "lbn", "lbo", "lbq", "lbr", "lbs", "lbt", "lbu", "lbv", "lbw", "lbx", "lby", "lbz", "lcc", "lcd", "lce", "lcf", "lch", "lcl", "lcm", "lcp", "lcq", "lcs", "lda", "ldb", "ldd", "ldg", "ldh", "ldi", "ldj", "ldk", "ldl", "ldm", "ldn", "ldo", "ldp", "ldq", "lea", "leb", "lec", "led", "lee", "lef", "leg", "leh", "lei", "lej", "lek", "lel", "lem", "len", "leo", "lep", "leq", "ler", "les", "let", "leu", "lev", "lew", "lex", "ley", "lez", "lfa", "lfn", "lg", "lga", "lgb", "lgg", "lgh", "lgi", "lgk", "lgl", "lgm", "lgn", "lgq", "lgr", "lgt", "lgu", "lgz", "lha", "lhh", "lhi", "lhl", "lhm", "lhn", "lhp", "lhs", "lht", "lhu", "li", "lia", "lib", "lic", "lid", "lie", "lif", "lig", "lih", "lii", "lij", "lik", "lil", "lio", "lip", "liq", "lir", "lis", "liu", "liv", "liw", "lix", "liy", "liz", "lja", "lje", "lji", "ljl", "ljp", "ljw", "ljx", "lka", "lkb", "lkc", "lkd", "lke", "lkh", "lki", "lkj", "lkl", "lkm", "lkn", "lko", "lkr", "lks", "lkt", "lku", "lky", "lla", "llb", "llc", "lld", "lle", "llf", "llg", "llh", "lli", "llj", "llk", "lll", "llm", "lln", "llo", "llp", "llq", "lls", "llu", "llx", "lma", "lmb", "lmc", "lmd", "lme", "lmf", "lmg", "lmh", "lmi", "lmj", "lmk", "lml", "lmm", "lmn", "lmo", "lmp", "lmq", "lmr", "lmu", "lmv", "lmw", "lmx", "lmy", "lmz", "ln", "lna", "lnb", "lnd", "lng", "lnh", "lni", "lnj", "lnl", "lnm", "lnn", "lno", "lns", "lnu", "lnw", "lnz", "lo", "loa", "lob", "loc", "loe", "lof", "log", "loh", "loi", "loj", "lok", "lol", "lom", "lon", "loo", "lop", "loq", "lor", "los", "lot", "lou", "lov", "low", "lox", "loy", "loz", "lpa", "lpe", "lpn", "lpo", "lpx", "lra", "lrc", "lre", "lrg", "lri", "lrk", "lrl", "lrm", "lrn", "lro", "lrr", "lrt", "lrv", "lrz", "lsa", "lsd", "lse", "lsg", "lsh", "lsi", "lsl", "lsm", "lsn", "lso", "lsp", "lsr", "lss", "lst", "lsv", "lsy", "lt", "ltc", "ltg", "lth", "lti", "ltn", "lto", "lts", "ltu", "lu", "lua", "luc", "lud", "lue", "luf", "lui", "luj", "luk", "lul", "lum", "lun", "luo", "lup", "luq", "lur", "lus", "lut", "luu", "luv", "luw", "luy", "luz", "lv", "lva", "lvi", "lvk", "lvs", "lvu", "lwa", "lwe", "lwg", "lwh", "lwl", "lwm", "lwo", "lws", "lwt", "lwu", "lww", "lya", "lyg", "lyn", "lzh", "lzl", "lzn", "lzz", "maa", "mab", "mad", "mae", "maf", "mag", "mai", "maj", "mak", "mam", "man", "map", "maq", "mas", "mat", "mau", "mav", "maw", "max", "maz", "mba", "mbb", "mbc", "mbd", "mbe", "mbf", "mbh", "mbi", "mbj", "mbk", "mbl", "mbm", "mbn", "mbo", "mbp", "mbq", "mbr", "mbs", "mbt", "mbu", "mbv", "mbw", "mbx", "mby", "mbz", "mca", "mcb", "mcc", "mcd", "mce", "mcf", "mcg", "mch", "mci", "mcj", "mck", "mcl", "mcm", "mcn", "mco", "mcp", "mcq", "mcr", "mcs", "mct", "mcu", "mcv", "mcw", "mcx", "mcy", "mcz", "mda", "mdb", "mdc", "mdd", "mde", "mdf", "mdg", "mdh", "mdi", "mdj", "mdk", "mdl", "mdm", "mdn", "mdp", "mdq", "mdr", "mds", "mdt", "mdu", "mdv", "mdw", "mdx", "mdy", "mdz", "mea", "meb", "mec", "med", "mee", "mef", "meg", "meh", "mei", "mej", "mek", "mel", "mem", "men", "meo", "mep", "meq", "mer", "mes", "met", "meu", "mev", "mew", "mey", "mez", "mfa", "mfb", "mfc", "mfd", "mfe", "mff", "mfg", "mfh", "mfi", "mfj", "mfk", "mfl", "mfm", "mfn", "mfo", "mfp", "mfq", "mfr", "mfs", "mft", "mfu", "mfv", "mfw", "mfx", "mfy", "mfz", "mg", "mga", "mgb", "mgc", "mgd", "mge", "mgf", "mgg", "mgh", "mgi", "mgj", "mgk", "mgl", "mgm", "mgn", "mgo", "mgp", "mgq", "mgr", "mgs", "mgt", "mgu", "mgv", "mgw", "mgx", "mgy", "mgz", "mh", "mha", "mhb", "mhc", "mhd", "mhe", "mhf", "mhg", "mhh", "mhi", "mhj", "mhk", "mhl", "mhm", "mhn", "mho", "mhp", "mhq", "mhr", "mhs", "mht", "mhu", "mhw", "mhx", "mhy", "mhz", "mi", "mia", "mib", "mic", "mid", "mie", "mif", "mig", "mih", "mii", "mij", "mik", "mil", "mim", "min", "mio", "mip", "miq", "mir", "mis", "mit", "miu", "miw", "mix", "miy", "miz", "mja", "mjb", "mjc", "mjd", "mje", "mjg", "mjh", "mji", "mjj", "mjk", "mjl", "mjm", "mjn", "mjo", "mjp", "mjq", "mjr", "mjs", "mjt", "mju", "mjv", "mjw", "mjx", "mjy", "mjz", "mk", "mka", "mkb", "mkc", "mke", "mkf", "mkg", "mkh", "mki", "mkj", "mkk", "mkl", "mkm", "mkn", "mko", "mkp", "mkq", "mkr", "mks", "mkt", "mku", "mkv", "mkw", "mkx", "mky", "mkz", "ml", "mla", "mlb", "mlc", "mld", "mle", "mlf", "mlh", "mli", "mlj", "mlk", "mll", "mlm", "mln", "mlo", "mlp", "mlq", "mlr", "mls", "mlu", "mlv", "mlw", "mlx", "mlz", "mma", "mmb", "mmc", "mmd", "mme", "mmf", "mmg", "mmh", "mmi", "mmj", "mmk", "mml", "mmm", "mmn", "mmo", "mmp", "mmq", "mmr", "mmt", "mmu", "mmv", "mmw", "mmx", "mmy", "mmz", "mn", "mna", "mnb", "mnc", "mnd", "mne", "mnf", "mng", "mnh", "mni", "mnj", "mnk", "mnl", "mnm", "mnn", "mno", "mnp", "mnq", "mnr", "mns", "mnt", "mnu", "mnv", "mnw", "mnx", "mny", "mnz", "mo", "moa", "moc", "mod", "moe", "mof", "mog", "moh", "moi", "moj", "mok", "mom", "moo", "mop", "moq", "mor", "mos", "mot", "mou", "mov", "mow", "mox", "moy", "moz", "mpa", "mpb", "mpc", "mpd", "mpe", "mpg", "mph", "mpi", "mpj", "mpk", "mpl", "mpm", "mpn", "mpo", "mpp", "mpq", "mpr", "mps", "mpt", "mpu", "mpv", "mpw", "mpx", "mpy", "mpz", "mqa", "mqb", "mqc", "mqe", "mqf", "mqg", "mqh", "mqi", "mqj", "mqk", "mql", "mqm", "mqn", "mqo", "mqp", "mqq", "mqr", "mqs", "mqt", "mqu", "mqv", "mqw", "mqx", "mqy", "mqz", "mr", "mra", "mrb", "mrc", "mrd", "mre", "mrf", "mrg", "mrh", "mrj", "mrk", "mrl", "mrm", "mrn", "mro", "mrp", "mrq", "mrr", "mrs", "mrt", "mru", "mrv", "mrw", "mrx", "mry", "mrz", "ms", "msb", "msc", "msd", "mse", "msf", "msg", "msh", "msi", "msj", "msk", "msl", "msm", "msn", "mso", "msp", "msq", "msr", "mss", "mst", "msu", "msv", "msw", "msx", "msy", "msz", "mt", "mta", "mtb", "mtc", "mtd", "mte", "mtf", "mtg", "mth", "mti", "mtj", "mtk", "mtl", "mtm", "mtn", "mto", "mtp", "mtq", "mtr", "mts", "mtt", "mtu", "mtv", "mtw", "mtx", "mty", "mua", "mub", "muc", "mud", "mue", "mug", "muh", "mui", "muj", "muk", "mul", "mum", "mun", "muo", "mup", "muq", "mur", "mus", "mut", "muu", "muv", "mux", "muy", "muz", "mva", "mvb", "mvd", "mve", "mvf", "mvg", "mvh", "mvi", "mvk", "mvl", "mvm", "mvn", "mvo", "mvp", "mvq", "mvr", "mvs", "mvt", "mvu", "mvv", "mvw", "mvx", "mvy", "mvz", "mwa", "mwb", "mwc", "mwd", "mwe", "mwf", "mwg", "mwh", "mwi", "mwj", "mwk", "mwl", "mwm", "mwn", "mwo", "mwp", "mwq", "mwr", "mws", "mwt", "mwu", "mwv", "mww", "mwx", "mwy", "mwz", "mxa", "mxb", "mxc", "mxd", "mxe", "mxf", "mxg", "mxh", "mxi", "mxj", "mxk", "mxl", "mxm", "mxn", "mxo", "mxp", "mxq", "mxr", "mxs", "mxt", "mxu", "mxv", "mxw", "mxx", "mxy", "mxz", "my", "myb", "myc", "myd", "mye", "myf", "myg", "myh", "myi", "myj", "myk", "myl", "mym", "myn", "myo", "myp", "myq", "myr", "mys", "myt", "myu", "myv", "myw", "myx", "myy", "myz", "mza", "mzb", "mzc", "mzd", "mze", "mzg", "mzh", "mzi", "mzj", "mzk", "mzl", "mzm", "mzn", "mzo", "mzp", "mzq", "mzr", "mzs", "mzt", "mzu", "mzv", "mzw", "mzx", "mzy", "mzz", "na", "naa", "nab", "nac", "nad", "nae", "naf", "nag", "nah", "nai", "naj", "nak", "nal", "nam", "nan", "nao", "nap", "naq", "nar", "nas", "nat", "naw", "nax", "nay", "naz", "nb", "nba", "nbb", "nbc", "nbd", "nbe", "nbf", "nbg", "nbh", "nbi", "nbj", "nbk", "nbm", "nbn", "nbo", "nbp", "nbq", "nbr", "nbs", "nbt", "nbu", "nbv", "nbw", "nbx", "nby", "nca", "ncb", "ncc", "ncd", "nce", "ncf", "ncg", "nch", "nci", "ncj", "nck", "ncl", "ncm", "ncn", "nco", "ncp", "ncq", "ncr", "ncs", "nct", "ncu", "ncx", "ncz", "nd", "nda", "ndb", "ndc", "ndd", "ndf", "ndg", "ndh", "ndi", "ndj", "ndk", "ndl", "ndm", "ndn", "ndp", "ndq", "ndr", "nds", "ndt", "ndu", "ndv", "ndw", "ndx", "ndy", "ndz", "ne", "nea", "neb", "nec", "ned", "nee", "nef", "neg", "neh", "nei", "nej", "nek", "nem", "nen", "neo", "neq", "ner", "nes", "net", "neu", "nev", "new", "nex", "ney", "nez", "nfa", "nfd", "nfl", "nfr", "nfu", "ng", "nga", "ngb", "ngc", "ngd", "nge", "ngf", "ngg", "ngh", "ngi", "ngj", "ngk", "ngl", "ngm", "ngn", "ngo", "ngp", "ngq", "ngr", "ngs", "ngt", "ngu", "ngv", "ngw", "ngx", "ngy", "ngz", "nha", "nhb", "nhc", "nhd", "nhe", "nhf", "nhg", "nhh", "nhi", "nhk", "nhm", "nhn", "nho", "nhp", "nhq", "nhr", "nht", "nhu", "nhv", "nhw", "nhx", "nhy", "nhz", "nia", "nib", "nic", "nid", "nie", "nif", "nig", "nih", "nii", "nij", "nik", "nil", "nim", "nin", "nio", "niq", "nir", "nis", "nit", "niu", "niv", "niw", "nix", "niy", "niz", "nja", "njb", "njd", "njh", "nji", "njj", "njl", "njm", "njn", "njo", "njr", "njs", "njt", "nju", "njx", "njy", "njz", "nka", "nkb", "nkc", "nkd", "nke", "nkf", "nkg", "nkh", "nki", "nkj", "nkk", "nkm", "nkn", "nko", "nkp", "nkq", "nkr", "nks", "nkt", "nku", "nkv", "nkw", "nkx", "nkz", "nl", "nla", "nlc", "nle", "nlg", "nli", "nlj", "nlk", "nll", "nlm", "nln", "nlo", "nlq", "nlr", "nlu", "nlv", "nlw", "nlx", "nly", "nlz", "nma", "nmb", "nmc", "nmd", "nme", "nmf", "nmg", "nmh", "nmi", "nmj", "nmk", "nml", "nmm", "nmn", "nmo", "nmp", "nmq", "nmr", "nms", "nmt", "nmu", "nmv", "nmw", "nmx", "nmy", "nmz", "nn", "nna", "nnb", "nnc", "nnd", "nne", "nnf", "nng", "nnh", "nni", "nnj", "nnk", "nnl", "nnm", "nnn", "nnp", "nnq", "nnr", "nns", "nnt", "nnu", "nnv", "nnw", "nnx", "nny", "nnz", "no", "noa", "noc", "nod", "noe", "nof", "nog", "noh", "noi", "noj", "nok", "nol", "nom", "non", "noo", "nop", "noq", "nos", "not", "nou", "nov", "now", "noy", "noz", "npa", "npb", "npg", "nph", "npi", "npl", "npn", "npo", "nps", "npu", "npx", "npy", "nqg", "nqk", "nql", "nqm", "nqn", "nqo", "nqq", "nqy", "nr", "nra", "nrb", "nrc", "nre", "nrf", "nrg", "nri", "nrk", "nrl", "nrm", "nrn", "nrp", "nrr", "nrt", "nru", "nrx", "nrz", "nsa", "nsc", "nsd", "nse", "nsf", "nsg", "nsh", "nsi", "nsk", "nsl", "nsm", "nsn", "nso", "nsp", "nsq", "nsr", "nss", "nst", "nsu", "nsv", "nsw", "nsx", "nsy", "nsz", "ntd", "nte", "ntg", "nti", "ntj", "ntk", "ntm", "nto", "ntp", "ntr", "nts", "ntu", "ntw", "ntx", "nty", "ntz", "nua", "nub", "nuc", "nud", "nue", "nuf", "nug", "nuh", "nui", "nuj", "nuk", "nul", "num", "nun", "nuo", "nup", "nuq", "nur", "nus", "nut", "nuu", "nuv", "nuw", "nux", "nuy", "nuz", "nv", "nvh", "nvm", "nvo", "nwa", "nwb", "nwc", "nwe", "nwg", "nwi", "nwm", "nwo", "nwr", "nwx", "nwy", "nxa", "nxd", "nxe", "nxg", "nxi", "nxk", "nxl", "nxm", "nxn", "nxo", "nxq", "nxr", "nxu", "nxx", "ny", "nyb", "nyc", "nyd", "nye", "nyf", "nyg", "nyh", "nyi", "nyj", "nyk", "nyl", "nym", "nyn", "nyo", "nyp", "nyq", "nyr", "nys", "nyt", "nyu", "nyv", "nyw", "nyx", "nyy", "nza", "nzb", "nzd", "nzi", "nzk", "nzm", "nzs", "nzu", "nzy", "nzz", "oaa", "oac", "oar", "oav", "obi", "obk", "obl", "obm", "obo", "obr", "obt", "obu", "oc", "oca", "och", "oco", "ocu", "oda", "odk", "odt", "odu", "ofo", "ofs", "ofu", "ogb", "ogc", "oge", "ogg", "ogo", "ogu", "oht", "ohu", "oia", "oin", "oj", "ojb", "ojc", "ojg", "ojp", "ojs", "ojv", "ojw", "oka", "okb", "okd", "oke", "okg", "okh", "oki", "okj", "okk", "okl", "okm", "okn", "oko", "okr", "oks", "oku", "okv", "okx", "ola", "old", "ole", "olk", "olm", "olo", "olr", "olt", "olu", "om", "oma", "omb", "omc", "ome", "omg", "omi", "omk", "oml", "omn", "omo", "omp", "omq", "omr", "omt", "omu", "omv", "omw", "omx", "ona", "onb", "one", "ong", "oni", "onj", "onk", "onn", "ono", "onp", "onr", "ons", "ont", "onu", "onw", "onx", "ood", "oog", "oon", "oor", "oos", "opa", "opk", "opm", "opo", "opt", "opy", "or", "ora", "orc", "ore", "org", "orh", "orn", "oro", "orr", "ors", "ort", "oru", "orv", "orw", "orx", "ory", "orz", "os", "osa", "osc", "osi", "oso", "osp", "ost", "osu", "osx", "ota", "otb", "otd", "ote", "oti", "otk", "otl", "otm", "otn", "oto", "otq", "otr", "ots", "ott", "otu", "otw", "otx", "oty", "otz", "oua", "oub", "oue", "oui", "oum", "oun", "ovd", "owi", "owl", "oyb", "oyd", "oym", "oyy", "ozm", "pa", "paa", "pab", "pac", "pad", "pae", "paf", "pag", "pah", "pai", "pak", "pal", "pam", "pao", "pap", "paq", "par", "pas", "pat", "pau", "pav", "paw", "pax", "pay", "paz", "pbb", "pbc", "pbe", "pbf", "pbg", "pbh", "pbi", "pbl", "pbm", "pbn", "pbo", "pbp", "pbr", "pbs", "pbt", "pbu", "pbv", "pby", "pbz", "pca", "pcb", "pcc", "pcd", "pce", "pcf", "pcg", "pch", "pci", "pcj", "pck", "pcl", "pcm", "pcn", "pcp", "pcr", "pcw", "pda", "pdc", "pdi", "pdn", "pdo", "pdt", "pdu", "pea", "peb", "ped", "pee", "pef", "peg", "peh", "pei", "pej", "pek", "pel", "pem", "peo", "pep", "peq", "pes", "pev", "pex", "pey", "pez", "pfa", "pfe", "pfl", "pga", "pgd", "pgg", "pgi", "pgk", "pgl", "pgn", "pgs", "pgu", "pgy", "pgz", "pha", "phd", "phg", "phh", "phi", "phk", "phl", "phm", "phn", "pho", "phq", "phr", "pht", "phu", "phv", "phw", "pi", "pia", "pib", "pic", "pid", "pie", "pif", "pig", "pih", "pii", "pij", "pil", "pim", "pin", "pio", "pip", "pir", "pis", "pit", "piu", "piv", "piw", "pix", "piy", "piz", "pjt", "pka", "pkb", "pkc", "pkg", "pkh", "pkn", "pko", "pkp", "pkr", "pks", "pkt", "pku", "pl", "pla", "plb", "plc", "pld", "ple", "plf", "plg", "plh", "plj", "plk", "pll", "pln", "plo", "plp", "plq", "plr", "pls", "plt", "plu", "plv", "plw", "ply", "plz", "pma", "pmb", "pmc", "pmd", "pme", "pmf", "pmh", "pmi", "pmj", "pmk", "pml", "pmm", "pmn", "pmo", "pmq", "pmr", "pms", "pmt", "pmu", "pmw", "pmx", "pmy", "pmz", "pna", "pnb", "pnc", "pnd", "pne", "png", "pnh", "pni", "pnj", "pnk", "pnl", "pnm", "pnn", "pno", "pnp", "pnq", "pnr", "pns", "pnt", "pnu", "pnv", "pnw", "pnx", "pny", "pnz", "poc", "pod", "poe", "pof", "pog", "poh", "poi", "pok", "pom", "pon", "poo", "pop", "poq", "pos", "pot", "pov", "pow", "pox", "poy", "poz", "ppa", "ppe", "ppi", "ppk", "ppl", "ppm", "ppn", "ppo", "ppp", "ppq", "ppr", "pps", "ppt", "ppu", "pqa", "pqe", "pqm", "pqw", "pra", "prb", "prc", "prd", "pre", "prf", "prg", "prh", "pri", "prk", "prl", "prm", "prn", "pro", "prp", "prq", "prr", "prs", "prt", "pru", "prw", "prx", "pry", "prz", "ps", "psa", "psc", "psd", "pse", "psg", "psh", "psi", "psl", "psm", "psn", "pso", "psp", "psq", "psr", "pss", "pst", "psu", "psw", "psy", "pt", "pta", "pth", "pti", "ptn", "pto", "ptp", "ptq", "ptr", "ptt", "ptu", "ptv", "ptw", "pty", "pua", "pub", "puc", "pud", "pue", "puf", "pug", "pui", "puj", "puk", "pum", "puo", "pup", "puq", "pur", "put", "puu", "puw", "pux", "puy", "puz", "pwa", "pwb", "pwg", "pwi", "pwm", "pwn", "pwo", "pwr", "pww", "pxm", "pye", "pym", "pyn", "pys", "pyu", "pyx", "pyy", "pzn", "qu", "qua", "qub", "quc", "qud", "quf", "qug", "quh", "qui", "quk", "qul", "qum", "qun", "qup", "quq", "qur", "qus", "quv", "quw", "qux", "quy", "quz", "qva", "qvc", "qve", "qvh", "qvi", "qvj", "qvl", "qvm", "qvn", "qvo", "qvp", "qvs", "qvw", "qvy", "qvz", "qwa", "qwc", "qwe", "qwh", "qwm", "qws", "qwt", "qxa", "qxc", "qxh", "qxl", "qxn", "qxo", "qxp", "qxq", "qxr", "qxs", "qxt", "qxu", "qxw", "qya", "qyp", "raa", "rab", "rac", "rad", "raf", "rag", "rah", "rai", "raj", "rak", "ral", "ram", "ran", "rao", "rap", "raq", "rar", "ras", "rat", "rau", "rav", "raw", "rax", "ray", "raz", "rbb", "rbk", "rbl", "rbp", "rcf", "rdb", "rea", "reb", "ree", "reg", "rei", "rej", "rel", "rem", "ren", "rer", "res", "ret", "rey", "rga", "rge", "rgk", "rgn", "rgr", "rgs", "rgu", "rhg", "rhp", "ria", "rie", "rif", "ril", "rim", "rin", "rir", "rit", "riu", "rjg", "rji", "rjs", "rka", "rkb", "rkh", "rki", "rkm", "rkt", "rkw", "rm", "rma", "rmb", "rmc", "rmd", "rme", "rmf", "rmg", "rmh", "rmi", "rmk", "rml", "rmm", "rmn", "rmo", "rmp", "rmq", "rmr", "rms", "rmt", "rmu", "rmv", "rmw", "rmx", "rmy", "rmz", "rn", "rna", "rnd", "rng", "rnl", "rnn", "rnp", "rnr", "rnw", "ro", "roa", "rob", "roc", "rod", "roe", "rof", "rog", "rol", "rom", "roo", "rop", "ror", "rou", "row", "rpn", "rpt", "rri", "rro", "rrt", "rsb", "rsi", "rsl", "rsm", "rtc", "rth", "rtm", "rts", "rtw", "ru", "rub", "ruc", "rue", "ruf", "rug", "ruh", "rui", "ruk", "ruo", "rup", "ruq", "rut", "ruu", "ruy", "ruz", "rw", "rwa", "rwk", "rwm", "rwo", "rwr", "rxd", "rxw", "ryn", "rys", "ryu", "rzh", "sa", "saa", "sab", "sac", "sad", "sae", "saf", "sah", "sai", "saj", "sak", "sal", "sam", "sao", "sap", "saq", "sar", "sas", "sat", "sau", "sav", "saw", "sax", "say", "saz", "sba", "sbb", "sbc", "sbd", "sbe", "sbf", "sbg", "sbh", "sbi", "sbj", "sbk", "sbl", "sbm", "sbn", "sbo", "sbp", "sbq", "sbr", "sbs", "sbt", "sbu", "sbv", "sbw", "sbx", "sby", "sbz", "sc", "sca", "scb", "sce", "scf", "scg", "sch", "sci", "sck", "scl", "scn", "sco", "scp", "scq", "scs", "sct", "scu", "scv", "scw", "scx", "sd", "sda", "sdb", "sdc", "sde", "sdf", "sdg", "sdh", "sdj", "sdk", "sdl", "sdm", "sdn", "sdo", "sdp", "sdr", "sds", "sdt", "sdu", "sdv", "sdx", "sdz", "se", "sea", "seb", "sec", "sed", "see", "sef", "seg", "seh", "sei", "sej", "sek", "sel", "sem", "sen", "seo", "sep", "seq", "ser", "ses", "set", "seu", "sev", "sew", "sey", "sez", "sfb", "sfe", "sfm", "sfs", "sfw", "sg", "sga", "sgb", "sgc", "sgd", "sge", "sgg", "sgh", "sgi", "sgj", "sgk", "sgl", "sgm", "sgn", "sgo", "sgp", "sgr", "sgs", "sgt", "sgu", "sgw", "sgx", "sgy", "sgz", "sh", "sha", "shb", "shc", "shd", "she", "shg", "shh", "shi", "shj", "shk", "shl", "shm", "shn", "sho", "shp", "shq", "shr", "shs", "sht", "shu", "shv", "shw", "shx", "shy", "shz", "si", "sia", "sib", "sid", "sie", "sif", "sig", "sih", "sii", "sij", "sik", "sil", "sim", "sio", "sip", "siq", "sir", "sis", "sit", "siu", "siv", "siw", "six", "siy", "siz", "sja", "sjb", "sjd", "sje", "sjg", "sjk", "sjl", "sjm", "sjn", "sjo", "sjp", "sjr", "sjs", "sjt", "sju", "sjw", "sk", "ska", "skb", "skc", "skd", "ske", "skf", "skg", "skh", "ski", "skj", "skk", "skm", "skn", "sko", "skp", "skq", "skr", "sks", "skt", "sku", "skv", "skw", "skx", "sky", "skz", "sl", "sla", "slc", "sld", "sle", "slf", "slg", "slh", "sli", "slj", "sll", "slm", "sln", "slp", "slq", "slr", "sls", "slt", "slu", "slw", "slx", "sly", "slz", "sm", "sma", "smb", "smc", "smd", "smf", "smg", "smh", "smi", "smj", "smk", "sml", "smm", "smn", "smp", "smq", "smr", "sms", "smt", "smu", "smv", "smw", "smx", "smy", "smz", "sn", "snb", "snc", "sne", "snf", "sng", "snh", "sni", "snj", "snk", "snl", "snm", "snn", "sno", "snp", "snq", "snr", "sns", "snu", "snv", "snw", "snx", "sny", "snz", "so", "soa", "sob", "soc", "sod", "soe", "sog", "soh", "soi", "soj", "sok", "sol", "son", "soo", "sop", "soq", "sor", "sos", "sou", "sov", "sow", "sox", "soy", "soz", "spb", "spc", "spd", "spe", "spg", "spi", "spk", "spl", "spm", "spn", "spo", "spp", "spq", "spr", "sps", "spt", "spu", "spv", "spx", "spy", "sq", "sqa", "sqh", "sqj", "sqk", "sqm", "sqn", "sqo", "sqq", "sqr", "sqs", "sqt", "squ", "sr", "sra", "srb", "src", "sre", "srf", "srg", "srh", "sri", "srk", "srl", "srm", "srn", "sro", "srq", "srr", "srs", "srt", "sru", "srv", "srw", "srx", "sry", "srz", "ss", "ssa", "ssb", "ssc", "ssd", "sse", "ssf", "ssg", "ssh", "ssi", "ssj", "ssk", "ssl", "ssm", "ssn", "sso", "ssp", "ssq", "ssr", "sss", "sst", "ssu", "ssv", "ssx", "ssy", "ssz", "st", "sta", "stb", "std", "ste", "stf", "stg", "sth", "sti", "stj", "stk", "stl", "stm", "stn", "sto", "stp", "stq", "str", "sts", "stt", "stu", "stv", "stw", "sty", "su", "sua", "sub", "suc", "sue", "sug", "sui", "suj", "suk", "sul", "sum", "suq", "sur", "sus", "sut", "suv", "suw", "sux", "suy", "suz", "sv", "sva", "svb", "svc", "sve", "svk", "svm", "svr", "svs", "svx", "sw", "swb", "swc", "swf", "swg", "swh", "swi", "swj", "swk", "swl", "swm", "swn", "swo", "swp", "swq", "swr", "sws", "swt", "swu", "swv", "sww", "swx", "swy", "sxb", "sxc", "sxe", "sxg", "sxk", "sxl", "sxm", "sxn", "sxo", "sxr", "sxs", "sxu", "sxw", "sya", "syb", "syc", "syd", "syi", "syk", "syl", "sym", "syn", "syo", "syr", "sys", "syw", "syx", "syy", "sza", "szb", "szc", "szd", "sze", "szg", "szl", "szn", "szp", "szs", "szv", "szw", "szy", "ta", "taa", "tab", "tac", "tad", "tae", "taf", "tag", "tai", "taj", "tak", "tal", "tan", "tao", "tap", "taq", "tar", "tas", "tau", "tav", "taw", "tax", "tay", "taz", "tba", "tbb", "tbc", "tbd", "tbe", "tbf", "tbg", "tbh", "tbi", "tbj", "tbk", "tbl", "tbm", "tbn", "tbo", "tbp", "tbq", "tbr", "tbs", "tbt", "tbu", "tbv", "tbw", "tbx", "tby", "tbz", "tca", "tcb", "tcc", "tcd", "tce", "tcf", "tcg", "tch", "tci", "tck", "tcl", "tcm", "tcn", "tco", "tcp", "tcq", "tcs", "tct", "tcu", "tcw", "tcx", "tcy", "tcz", "tda", "tdb", "tdc", "tdd", "tde", "tdf", "tdg", "tdh", "tdi", "tdj", "tdk", "tdl", "tdm", "tdn", "tdo", "tdq", "tdr", "tds", "tdt", "tdu", "tdv", "tdx", "tdy", "te", "tea", "teb", "tec", "ted", "tee", "tef", "teg", "teh", "tei", "tek", "tem", "ten", "teo", "tep", "teq", "ter", "tes", "tet", "teu", "tev", "tew", "tex", "tey", "tez", "tfi", "tfn", "tfo", "tfr", "tft", "tg", "tga", "tgb", "tgc", "tgd", "tge", "tgf", "tgg", "tgh", "tgi", "tgj", "tgn", "tgo", "tgp", "tgq", "tgr", "tgs", "tgt", "tgu", "tgv", "tgw", "tgx", "tgy", "tgz", "th", "thc", "thd", "the", "thf", "thh", "thi", "thk", "thl", "thm", "thn", "thp", "thq", "thr", "ths", "tht", "thu", "thv", "thw", "thx", "thy", "thz", "ti", "tia", "tic", "tid", "tie", "tif", "tig", "tih", "tii", "tij", "tik", "til", "tim", "tin", "tio", "tip", "tiq", "tis", "tit", "tiu", "tiv", "tiw", "tix", "tiy", "tiz", "tja", "tjg", "tji", "tjj", "tjl", "tjm", "tjn", "tjo", "tjp", "tjs", "tju", "tjw", "tk", "tka", "tkb", "tkd", "tke", "tkf", "tkg", "tkk", "tkl", "tkm", "tkn", "tkp", "tkq", "tkr", "tks", "tkt", "tku", "tkv", "tkw", "tkx", "tkz", "tl", "tla", "tlb", "tlc", "tld", "tlf", "tlg", "tlh", "tli", "tlj", "tlk", "tll", "tlm", "tln", "tlo", "tlp", "tlq", "tlr", "tls", "tlt", "tlu", "tlv", "tlw", "tlx", "tly", "tma", "tmb", "tmc", "tmd", "tme", "tmf", "tmg", "tmh", "tmi", "tmj", "tmk", "tml", "tmm", "tmn", "tmo", "tmp", "tmq", "tmr", "tms", "tmt", "tmu", "tmv", "tmw", "tmy", "tmz", "tn", "tna", "tnb", "tnc", "tnd", "tne", "tnf", "tng", "tnh", "tni", "tnk", "tnl", "tnm", "tnn", "tno", "tnp", "tnq", "tnr", "tns", "tnt", "tnu", "tnv", "tnw", "tnx", "tny", "tnz", "to", "tob", "toc", "tod", "toe", "tof", "tog", "toh", "toi", "toj", "tol", "tom", "too", "top", "toq", "tor", "tos", "tou", "tov", "tow", "tox", "toy", "toz", "tpa", "tpc", "tpe", "tpf", "tpg", "tpi", "tpj", "tpk", "tpl", "tpm", "tpn", "tpo", "tpp", "tpq", "tpr", "tpt", "tpu", "tpv", "tpw", "tpx", "tpy", "tpz", "tqb", "tql", "tqm", "tqn", "tqo", "tqp", "tqq", "tqr", "tqt", "tqu", "tqw", "tr", "tra", "trb", "trc", "trd", "tre", "trf", "trg", "trh", "tri", "trj", "trk", "trl", "trm", "trn", "tro", "trp", "trq", "trr", "trs", "trt", "tru", "trv", "trw", "trx", "try", "trz", "ts", "tsa", "tsb", "tsc", "tsd", "tse", "tsf", "tsg", "tsh", "tsi", "tsj", "tsk", "tsl", "tsm", "tsp", "tsq", "tsr", "tss", "tst", "tsu", "tsv", "tsw", "tsx", "tsy", "tsz", "tt", "tta", "ttb", "ttc", "ttd", "tte", "ttf", "ttg", "tth", "tti", "ttj", "ttk", "ttl", "ttm", "ttn", "tto", "ttp", "ttq", "ttr", "tts", "ttt", "ttu", "ttv", "ttw", "tty", "ttz", "tua", "tub", "tuc", "tud", "tue", "tuf", "tug", "tuh", "tui", "tuj", "tul", "tum", "tun", "tuo", "tup", "tuq", "tus", "tut", "tuu", "tuv", "tuw", "tux", "tuy", "tuz", "tva", "tvd", "tve", "tvk", "tvl", "tvm", "tvn", "tvo", "tvs", "tvt", "tvu", "tvw", "tvx", "tvy", "tw", "twa", "twb", "twc", "twd", "twe", "twf", "twg", "twh", "twl", "twm", "twn", "two", "twp", "twq", "twr", "twt", "twu", "tww", "twx", "twy", "txa", "txb", "txc", "txe", "txg", "txh", "txi", "txj", "txm", "txn", "txo", "txq", "txr", "txs", "txt", "txu", "txx", "txy", "ty", "tya", "tye", "tyh", "tyi", "tyj", "tyl", "tyn", "typ", "tyr", "tys", "tyt", "tyu", "tyv", "tyx", "tyz", "tza", "tzh", "tzj", "tzl", "tzm", "tzn", "tzo", "tzx", "uam", "uan", "uar", "uba", "ubi", "ubl", "ubr", "ubu", "uby", "uda", "ude", "udg", "udi", "udj", "udl", "udm", "udu", "ues", "ufi", "ug", "uga", "ugb", "uge", "ugn", "ugo", "ugy", "uha", "uhn", "uis", "uiv", "uji", "uk", "uka", "ukg", "ukh", "ukk", "ukl", "ukp", "ukq", "uks", "uku", "ukw", "uky", "ula", "ulb", "ulc", "ule", "ulf", "uli", "ulk", "ull", "ulm", "uln", "ulu", "ulw", "uma", "umb", "umc", "umd", "umg", "umi", "umm", "umn", "umo", "ump", "umr", "ums", "umu", "una", "und", "une", "ung", "unk", "unm", "unn", "unp", "unr", "unu", "unx", "unz", "uok", "upi", "upv", "ur", "ura", "urb", "urc", "ure", "urf", "urg", "urh", "uri", "urj", "urk", "url", "urm", "urn", "uro", "urp", "urr", "urt", "uru", "urv", "urw", "urx", "ury", "urz", "usa", "ush", "usi", "usk", "usp", "uss", "usu", "uta", "ute", "uth", "utp", "utr", "utu", "uum", "uun", "uur", "uuu", "uve", "uvh", "uvl", "uwa", "uya", "uz", "uzn", "uzs", "vaa", "vae", "vaf", "vag", "vah", "vai", "vaj", "val", "vam", "van", "vao", "vap", "var", "vas", "vau", "vav", "vay", "vbb", "vbk", "ve", "vec", "ved", "vel", "vem", "veo", "vep", "ver", "vgr", "vgt", "vi", "vic", "vid", "vif", "vig", "vil", "vin", "vis", "vit", "viv", "vka", "vki", "vkj", "vkk", "vkl", "vkm", "vko", "vkp", "vkt", "vku", "vlp", "vls", "vma", "vmb", "vmc", "vmd", "vme", "vmf", "vmg", "vmh", "vmi", "vmj", "vmk", "vml", "vmm", "vmp", "vmq", "vmr", "vms", "vmu", "vmv", "vmw", "vmx", "vmy", "vmz", "vnk", "vnm", "vnp", "vo", "vor", "vot", "vra", "vro", "vrs", "vrt", "vsi", "vsl", "vsv", "vto", "vum", "vun", "vut", "vwa", "wa", "waa", "wab", "wac", "wad", "wae", "waf", "wag", "wah", "wai", "waj", "wak", "wal", "wam", "wan", "wao", "wap", "waq", "war", "was", "wat", "wau", "wav", "waw", "wax", "way", "waz", "wba", "wbb", "wbe", "wbf", "wbh", "wbi", "wbj", "wbk", "wbl", "wbm", "wbp", "wbq", "wbr", "wbs", "wbt", "wbv", "wbw", "wca", "wci", "wdd", "wdg", "wdj", "wdk", "wdu", "wdy", "wea", "wec", "wed", "weg", "weh", "wei", "wem", "wen", "weo", "wep", "wer", "wes", "wet", "weu", "wew", "wfg", "wga", "wgb", "wgg", "wgi", "wgo", "wgu", "wgw", "wgy", "wha", "whg", "whk", "whu", "wib", "wic", "wie", "wif", "wig", "wih", "wii", "wij", "wik", "wil", "wim", "win", "wir", "wit", "wiu", "wiv", "wiw", "wiy", "wja", "wji", "wka", "wkb", "wkd", "wkl", "wkr", "wku", "wkw", "wky", "wla", "wlc", "wle", "wlg", "wli", "wlk", "wll", "wlm", "wlo", "wlr", "wls", "wlu", "wlv", "wlw", "wlx", "wly", "wma", "wmb", "wmc", "wmd", "wme", "wmh", "wmi", "wmm", "wmn", "wmo", "wms", "wmt", "wmw", "wmx", "wnb", "wnc", "wnd", "wne", "wng", "wni", "wnk", "wnm", "wnn", "wno", "wnp", "wnu", "wnw", "wny", "wo", "woa", "wob", "woc", "wod", "woe", "wof", "wog", "woi", "wok", "wom", "won", "woo", "wor", "wos", "wow", "woy", "wpc", "wra", "wrb", "wrd", "wrg", "wrh", "wri", "wrk", "wrl", "wrm", "wrn", "wro", "wrp", "wrr", "wrs", "wru", "wrv", "wrw", "wrx", "wry", "wrz", "wsa", "wsg", "wsi", "wsk", "wsr", "wss", "wsu", "wsv", "wtf", "wth", "wti", "wtk", "wtm", "wtw", "wua", "wub", "wud", "wuh", "wul", "wum", "wun", "wur", "wut", "wuu", "wuv", "wux", "wuy", "wwa", "wwb", "wwo", "wwr", "www", "wxa", "wxw", "wya", "wyb", "wyi", "wym", "wyr", "wyy", "xaa", "xab", "xac", "xad", "xae", "xag", "xai", "xaj", "xak", "xal", "xam", "xan", "xao", "xap", "xaq", "xar", "xas", "xat", "xau", "xav", "xaw", "xay", "xba", "xbb", "xbc", "xbd", "xbe", "xbg", "xbi", "xbj", "xbm", "xbn", "xbo", "xbp", "xbr", "xbw", "xbx", "xby", "xcb", "xcc", "xce", "xcg", "xch", "xcl", "xcm", "xcn", "xco", "xcr", "xct", "xcu", "xcv", "xcw", "xcy", "xda", "xdc", "xdk", "xdm", "xdo", "xdy", "xeb", "xed", "xeg", "xel", "xem", "xep", "xer", "xes", "xet", "xeu", "xfa", "xga", "xgb", "xgd", "xgf", "xgg", "xgi", "xgl", "xgm", "xgn", "xgr", "xgu", "xgw", "xh", "xha", "xhc", "xhd", "xhe", "xhr", "xht", "xhu", "xhv", "xia", "xib", "xii", "xil", "xin", "xip", "xir", "xis", "xiv", "xiy", "xjb", "xjt", "xka", "xkb", "xkc", "xkd", "xke", "xkf", "xkg", "xkh", "xki", "xkj", "xkk", "xkl", "xkn", "xko", "xkp", "xkq", "xkr", "xks", "xkt", "xku", "xkv", "xkw", "xkx", "xky", "xkz", "xla", "xlb", "xlc", "xld", "xle", "xlg", "xli", "xln", "xlo", "xlp", "xls", "xlu", "xly", "xma", "xmb", "xmc", "xmd", "xme", "xmf", "xmg", "xmh", "xmj", "xmk", "xml", "xmm", "xmn", "xmo", "xmp", "xmq", "xmr", "xms", "xmt", "xmu", "xmv", "xmw", "xmx", "xmy", "xmz", "xna", "xnb", "xnd", "xng", "xnh", "xni", "xnk", "xnn", "xno", "xnr", "xns", "xnt", "xnu", "xny", "xnz", "xoc", "xod", "xog", "xoi", "xok", "xom", "xon", "xoo", "xop", "xor", "xow", "xpa", "xpc", "xpe", "xpg", "xpi", "xpj", "xpk", "xpm", "xpn", "xpo", "xpp", "xpq", "xpr", "xps", "xpt", "xpu", "xpy", "xqa", "xqt", "xra", "xrb", "xrd", "xre", "xrg", "xri", "xrm", "xrn", "xrq", "xrr", "xrt", "xru", "xrw", "xsa", "xsb", "xsc", "xsd", "xse", "xsh", "xsi", "xsj", "xsl", "xsm", "xsn", "xso", "xsp", "xsq", "xsr", "xss", "xsu", "xsv", "xsy", "xta", "xtb", "xtc", "xtd", "xte", "xtg", "xth", "xti", "xtj", "xtl", "xtm", "xtn", "xto", "xtp", "xtq", "xtr", "xts", "xtt", "xtu", "xtv", "xtw", "xty", "xtz", "xua", "xub", "xud", "xug", "xuj", "xul", "xum", "xun", "xuo", "xup", "xur", "xut", "xuu", "xve", "xvi", "xvn", "xvo", "xvs", "xwa", "xwc", "xwd", "xwe", "xwg", "xwj", "xwk", "xwl", "xwo", "xwr", "xwt", "xww", "xxb", "xxk", "xxm", "xxr", "xxt", "xya", "xyb", "xyj", "xyk", "xyl", "xyt", "xyy", "xzh", "xzm", "xzp", "yaa", "yab", "yac", "yad", "yae", "yaf", "yag", "yah", "yai", "yaj", "yak", "yal", "yam", "yan", "yao", "yap", "yaq", "yar", "yas", "yat", "yau", "yav", "yaw", "yax", "yay", "yaz", "yba", "ybb", "ybd", "ybe", "ybh", "ybi", "ybj", "ybk", "ybl", "ybm", "ybn", "ybo", "ybx", "yby", "ych", "ycl", "ycn", "ycp", "yda", "ydd", "yde", "ydg", "ydk", "yds", "yea", "yec", "yee", "yei", "yej", "yel", "yen", "yer", "yes", "yet", "yeu", "yev", "yey", "yga", "ygi", "ygl", "ygm", "ygp", "ygr", "ygs", "ygu", "ygw", "yha", "yhd", "yhl", "yhs", "yi", "yia", "yif", "yig", "yih", "yii", "yij", "yik", "yil", "yim", "yin", "yip", "yiq", "yir", "yis", "yit", "yiu", "yiv", "yix", "yiy", "yiz", "yka", "ykg", "yki", "ykk", "ykl", "ykm", "ykn", "yko", "ykr", "ykt", "yku", "yky", "yla", "ylb", "yle", "ylg", "yli", "yll", "ylm", "yln", "ylo", "ylr", "ylu", "yly", "yma", "ymb", "ymc", "ymd", "yme", "ymg", "ymh", "ymi", "ymk", "yml", "ymm", "ymn", "ymo", "ymp", "ymq", "ymr", "yms", "ymt", "ymx", "ymz", "yna", "ynd", "yne", "yng", "ynh", "ynk", "ynl", "ynn", "yno", "ynq", "yns", "ynu", "yo", "yob", "yog", "yoi", "yok", "yol", "yom", "yon", "yos", "yot", "yox", "yoy", "ypa", "ypb", "ypg", "yph", "ypk", "ypm", "ypn", "ypo", "ypp", "ypz", "yra", "yrb", "yre", "yri", "yrk", "yrl", "yrm", "yrn", "yro", "yrs", "yrw", "yry", "ysc", "ysd", "ysg", "ysl", "ysn", "yso", "ysp", "ysr", "yss", "ysy", "yta", "ytl", "ytp", "ytw", "yty", "yua", "yub", "yuc", "yud", "yue", "yuf", "yug", "yui", "yuj", "yuk", "yul", "yum", "yun", "yup", "yuq", "yur", "yut", "yuu", "yuw", "yux", "yuy", "yuz", "yva", "yvt", "ywa", "ywg", "ywl", "ywn", "ywq", "ywr", "ywt", "ywu", "yww", "yxa", "yxg", "yxl", "yxm", "yxu", "yxy", "yyr", "yyu", "yyz", "yzg", "yzk", "za", "zaa", "zab", "zac", "zad", "zae", "zaf", "zag", "zah", "zai", "zaj", "zak", "zal", "zam", "zao", "zap", "zaq", "zar", "zas", "zat", "zau", "zav", "zaw", "zax", "zay", "zaz", "zbc", "zbe", "zbl", "zbt", "zbw", "zca", "zch", "zdj", "zea", "zeg", "zeh", "zen", "zga", "zgb", "zgh", "zgm", "zgn", "zgr", "zh", "zhb", "zhd", "zhi", "zhn", "zhw", "zhx", "zia", "zib", "zik", "zil", "zim", "zin", "zir", "ziw", "ziz", "zka", "zkb", "zkd", "zkg", "zkh", "zkk", "zkn", "zko", "zkp", "zkr", "zkt", "zku", "zkv", "zkz", "zle", "zlj", "zlm", "zln", "zlq", "zls", "zlw", "zma", "zmb", "zmc", "zmd", "zme", "zmf", "zmg", "zmh", "zmi", "zmj", "zmk", "zml", "zmm", "zmn", "zmo", "zmp", "zmq", "zmr", "zms", "zmt", "zmu", "zmv", "zmw", "zmx", "zmy", "zmz", "zna", "znd", "zne", "zng", "znk", "zns", "zoc", "zoh", "zom", "zoo", "zoq", "zor", "zos", "zpa", "zpb", "zpc", "zpd", "zpe", "zpf", "zpg", "zph", "zpi", "zpj", "zpk", "zpl", "zpm", "zpn", "zpo", "zpp", "zpq", "zpr", "zps", "zpt", "zpu", "zpv", "zpw", "zpx", "zpy", "zpz", "zqe", "zra", "zrg", "zrn", "zro", "zrp", "zrs", "zsa", "zsk", "zsl", "zsm", "zsr", "zsu", "zte", "ztg", "ztl", "ztm", "ztn", "ztp", "ztq", "zts", "ztt", "ztu", "ztx", "zty", "zu", "zua", "zuh", "zum", "zun", "zuy", "zwa", "zxx", "zyb", "zyg", "zyj", "zyn", "zyp", "zza", "zzj"];
var j = ["aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "aed", "aen", "afb", "afg", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "ase", "asf", "asp", "asq", "asw", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "bfi", "bfk", "bjn", "bog", "bqn", "bqy", "btj", "bve", "bvl", "bvu", "bzs", "cdo", "cds", "cjy", "cmn", "coa", "cpx", "csc", "csd", "cse", "csf", "csg", "csl", "csn", "csq", "csr", "czh", "czo", "doq", "dse", "dsl", "dup", "ecs", "esl", "esn", "eso", "eth", "fcs", "fse", "fsl", "fss", "gan", "gds", "gom", "gse", "gsg", "gsm", "gss", "gus", "hab", "haf", "hak", "hds", "hji", "hks", "hos", "hps", "hsh", "hsl", "hsn", "icl", "iks", "ils", "inl", "ins", "ise", "isg", "isr", "jak", "jax", "jcs", "jhs", "jls", "jos", "jsl", "jus", "kgi", "knn", "kvb", "kvk", "kvr", "kxd", "lbs", "lce", "lcf", "liw", "lls", "lsg", "lsl", "lsn", "lso", "lsp", "lst", "lsv", "lsy", "ltg", "lvs", "lws", "lzh", "max", "mdl", "meo", "mfa", "mfb", "mfs", "min", "mnp", "mqg", "mre", "msd", "msi", "msr", "mui", "mzc", "mzg", "mzy", "nan", "nbs", "ncs", "nsi", "nsl", "nsp", "nsr", "nzs", "okl", "orn", "ors", "pel", "pga", "pgz", "pks", "prl", "prz", "psc", "psd", "pse", "psg", "psl", "pso", "psp", "psr", "pys", "rms", "rsi", "rsl", "rsm", "sdl", "sfb", "sfs", "sgg", "sgx", "shu", "slf", "sls", "sqk", "sqs", "ssh", "ssp", "ssr", "svk", "swc", "swh", "swl", "syy", "szs", "tmw", "tse", "tsm", "tsq", "tss", "tsy", "tza", "ugn", "ugy", "ukl", "uks", "urk", "uzn", "uzs", "vgt", "vkk", "vkt", "vsi", "vsl", "vsv", "wbs", "wuu", "xki", "xml", "xmm", "xms", "yds", "ygs", "yhs", "ysl", "yue", "zib", "zlm", "zmi", "zsl", "zsm"];
var v = ["art-lojban", "cel-gaulish", "en-gb-oed", "i-ami", "i-bnn", "i-default", "i-enochian", "i-hak", "i-klingon", "i-lux", "i-mingo", "i-navajo", "i-pwn", "i-tao", "i-tay", "i-tsu", "no-bok", "no-nyn", "sgn-be-fr", "sgn-be-nl", "sgn-ch-de", "zh-guoyu", "zh-hakka", "zh-min", "zh-min-nan", "zh-xiang"];
var $ = ["001", "002", "003", "005", "009", "011", "013", "014", "015", "017", "018", "019", "021", "029", "030", "034", "035", "039", "053", "054", "057", "061", "142", "143", "145", "150", "151", "154", "155", "202", "419", "aa", "ac", "ad", "ae", "af", "ag", "ai", "al", "am", "an", "ao", "aq", "ar", "as", "at", "au", "aw", "ax", "az", "ba", "bb", "bd", "be", "bf", "bg", "bh", "bi", "bj", "bl", "bm", "bn", "bo", "bq", "br", "bs", "bt", "bu", "bv", "bw", "by", "bz", "ca", "cc", "cd", "cf", "cg", "ch", "ci", "ck", "cl", "cm", "cn", "co", "cp", "cr", "cs", "cu", "cv", "cw", "cx", "cy", "cz", "dd", "de", "dg", "dj", "dk", "dm", "do", "dz", "ea", "ec", "ee", "eg", "eh", "er", "es", "et", "eu", "ez", "fi", "fj", "fk", "fm", "fo", "fr", "fx", "ga", "gb", "gd", "ge", "gf", "gg", "gh", "gi", "gl", "gm", "gn", "gp", "gq", "gr", "gs", "gt", "gu", "gw", "gy", "hk", "hm", "hn", "hr", "ht", "hu", "ic", "id", "ie", "il", "im", "in", "io", "iq", "ir", "is", "it", "je", "jm", "jo", "jp", "ke", "kg", "kh", "ki", "km", "kn", "kp", "kr", "kw", "ky", "kz", "la", "lb", "lc", "li", "lk", "lr", "ls", "lt", "lu", "lv", "ly", "ma", "mc", "md", "me", "mf", "mg", "mh", "mk", "ml", "mm", "mn", "mo", "mp", "mq", "mr", "ms", "mt", "mu", "mv", "mw", "mx", "my", "mz", "na", "nc", "ne", "nf", "ng", "ni", "nl", "no", "np", "nr", "nt", "nu", "nz", "om", "pa", "pe", "pf", "pg", "ph", "pk", "pl", "pm", "pn", "pr", "ps", "pt", "pw", "py", "qa", "re", "ro", "rs", "ru", "rw", "sa", "sb", "sc", "sd", "se", "sg", "sh", "si", "sj", "sk", "sl", "sm", "sn", "so", "sr", "ss", "st", "su", "sv", "sx", "sy", "sz", "ta", "tc", "td", "tf", "tg", "th", "tj", "tk", "tl", "tm", "tn", "to", "tp", "tr", "tt", "tv", "tw", "tz", "ua", "ug", "um", "un", "us", "uy", "uz", "va", "vc", "ve", "vg", "vi", "vn", "vu", "wf", "ws", "yd", "ye", "yt", "yu", "za", "zm", "zr", "zw", "zz"];
var q = ["adlm", "afak", "aghb", "ahom", "arab", "aran", "armi", "armn", "avst", "bali", "bamu", "bass", "batk", "beng", "bhks", "blis", "bopo", "brah", "brai", "bugi", "buhd", "cakm", "cans", "cari", "cham", "cher", "chrs", "cirt", "copt", "cpmn", "cprt", "cyrl", "cyrs", "deva", "diak", "dogr", "dsrt", "dupl", "egyd", "egyh", "egyp", "elba", "elym", "ethi", "geok", "geor", "glag", "gong", "gonm", "goth", "gran", "grek", "gujr", "guru", "hanb", "hang", "hani", "hano", "hans", "hant", "hatr", "hebr", "hira", "hluw", "hmng", "hmnp", "hrkt", "hung", "inds", "ital", "jamo", "java", "jpan", "jurc", "kali", "kana", "khar", "khmr", "khoj", "kitl", "kits", "knda", "kore", "kpel", "kthi", "lana", "laoo", "latf", "latg", "latn", "leke", "lepc", "limb", "lina", "linb", "lisu", "loma", "lyci", "lydi", "mahj", "maka", "mand", "mani", "marc", "maya", "medf", "mend", "merc", "mero", "mlym", "modi", "mong", "moon", "mroo", "mtei", "mult", "mymr", "nand", "narb", "nbat", "newa", "nkdb", "nkgb", "nkoo", "nshu", "ogam", "olck", "orkh", "orya", "osge", "osma", "palm", "pauc", "perm", "phag", "phli", "phlp", "phlv", "phnx", "piqd", "plrd", "prti", "rjng", "rohg", "roro", "runr", "samr", "sara", "sarb", "saur", "sgnw", "shaw", "shrd", "shui", "sidd", "sind", "sinh", "sogd", "sogo", "sora", "soyo", "sund", "sylo", "syrc", "syre", "syrj", "syrn", "tagb", "takr", "tale", "talu", "taml", "tang", "tavt", "telu", "teng", "tfng", "tglg", "thaa", "thai", "tibt", "tirh", "ugar", "vaii", "visp", "wara", "wcho", "wole", "xpeo", "xsux", "yezi", "yiii", "zanb", "zinh", "zmth", "zsye", "zsym", "zxxx", "zyyy", "zzzz"];
var E = ["1606nict", "1694acad", "1901", "1959acad", "1994", "1996", "abl1943", "akuapem", "alalc97", "aluku", "ao1990", "aranes", "arevela", "arevmda", "asante", "auvern", "baku1926", "balanka", "barla", "basiceng", "bauddha", "biscayan", "biske", "bohoric", "boont", "bornholm", "cisaup", "colb1945", "cornu", "creiss", "dajnko", "ekavsk", "emodeng", "fonipa", "fonkirsh", "fonnapa", "fonupa", "fonxsamp", "gascon", "grclass", "grital", "grmistr", "hepburn", "heploc", "hognorsk", "hsistemo", "ijekavsk", "itihasa", "ivanchov", "jauer", "jyutping", "kkcor", "kociewie", "kscor", "laukika", "lemosin", "lengadoc", "lipaw", "luna1918", "metelko", "monoton", "ndyuka", "nedis", "newfound", "nicard", "njiva", "nulik", "osojs", "oxendict", "pahawh2", "pahawh3", "pahawh4", "pamaka", "petr1708", "pinyin", "polyton", "provenc", "puter", "rigik", "rozaj", "rumgr", "scotland", "scouse", "simple", "solba", "sotav", "spanglis", "surmiran", "sursilv", "sutsilv", "tarask", "uccor", "ucrcor", "ulster", "unifon", "vaidika", "valencia", "vallader", "vivaraup", "wadegile", "xsistemo"];
function L(d) {
  return d instanceof RegExp;
}
function g(d, b) {
  return !Array.isArray(d) || !d.length ? false : d.some((e) => L(e) && b.match(e) || typeof e == "string" && b === e);
}
function en(d) {
  if (typeof d != "string")
    return { res: false, message: "Not a string given." };
  if (!d.trim())
    return { res: false, message: "Empty language tag string given." };
  let b = z, e = j, k = v, s = $, l = q, t = E, m = [], i = [], D = /^[a-z0-9]{1,8}(-[a-z0-9]{1,8})*$/gi, V = /^q[a-t][a-z]$/gi;
  b.push(V);
  let T = /^qa[a-b][a-x]$/gi;
  l.push(T);
  let M = /^q[m-z]$/gi;
  s.push(M);
  let R = /^x[a-z]$/gi;
  s.push(R);
  let x = /^[0-9a-wy-z]$/gi;
  if (!d.match(D))
    return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, { res: false, message: "Does not resemble a language tag." };
  if (g(k, d))
    return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, { res: true, message: null };
  let n = d.toLowerCase().split("-"), p2, r, h2, c, w, y, o;
  for (let a = 0, O = n.length; a < O; a++) {
    if (o = false, a === 0 && (p2 = n[0] === "x" ? "private" : "normal"), n[a] === "x")
      return n[a + 1] ? (b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: true, message: null }) : (b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: 'Ends with private use subtag, "x".' });
    if (c && s.includes(n[a])) {
      let u = `Two region subtags, "${c}" and "${n[a]}".`;
      return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: u };
    }
    if (a === 0)
      p2 === "normal" && g(b, n[a]) && (r = n[a], o = true);
    else if (a === 1) {
      if (p2 === "normal") {
        if (g(l, n[a]))
          h2 = n[a], o = true;
        else if (g(e, n[a]))
          y = n[a], o = true;
        else if (g(s, n[a]))
          c = n[a], o = true;
        else if (g(t, n[a]))
          if (w = n[a], o = true, !m.includes(n[a]))
            m.push(n[a]);
          else {
            let u = `Repeated variant subtag, "${n[a]}".`;
            return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: u };
          }
      }
    } else if (a === 2) {
      if (p2 === "normal") {
        if (r && y)
          g(l, n[a]) ? (h2 = n[a], o = true) : g(s, n[a]) && (c = n[a], o = true);
        else if (r && h2)
          g(s, n[a]) && (c = n[a], o = true);
        else if (r && c && g(t, n[a]))
          if (w = n[a], o = true, !m.includes(n[a]))
            m.push(n[a]);
          else {
            let u = `Repeated variant subtag, "${n[a]}".`;
            return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: u };
          }
      }
    } else
      a === 3 && p2 === "normal" && (r && y && h2 ? g(s, n[a]) && (c = n[a], o = true) : r && h2 && c && g(t, n[a]) && (w = n[a], o = true));
    if (n[a].match(x)) {
      if (a === 0) {
        let u = `Starts with singleton, "${n[a]}".`;
        return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: u };
      }
      if (!r)
        return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: "Extension must follow at least a primary language subtag." };
      if (!i.includes(n[a]))
        i.push(n[a]);
      else {
        let u = `Two extensions with same single-letter prefix "${n[a]}".`;
        return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: u };
      }
      if (n[a + 1])
        if (n[a + 1].match(x)) {
          let u = `Multiple singleton sequence "${n[a]}", "${n[a + 1]}".`;
          return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: u };
        } else {
          o = true, y = n[a], a += 1;
          continue;
        }
      else {
        let u = `Ends with singleton, "${n[a]}".`;
        return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: u };
      }
    }
    if (!o && w && g(t, n[a]))
      if (a && g(t, n[a - 1])) {
        if (!m.includes(n[a]))
          m.push(n[a]);
        else {
          let u = `Repeated variant subtag, "${n[a]}".`;
          return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: u };
        }
        o = true;
      } else {
        m.push(n[a]);
        let u = `Variant subtags ${m.map((S) => `"${S}"`).join(", ")}  not in a sequence.`;
        return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: u };
      }
    if (!o && r && y && n[a].length > 1 && (o = true), !o) {
      let u = `Unrecognised language subtag, "${n[a]}".`;
      return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: false, message: u };
    }
  }
  return b = void 0, e = void 0, k = void 0, s = void 0, l = void 0, t = void 0, m = void 0, i = void 0, n = void 0, { res: true, message: null };
}
const _withScopeId$3 = (n) => (pushScopeId("data-v-bc55357c"), n = n(), popScopeId(), n);
const _hoisted_1$8 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "col-auto" }, " Library ", -1));
const _hoisted_2$6 = { class: "col-auto q-ml-sm" };
const _hoisted_3$6 = { class: "column" };
const _hoisted_4$5 = {
  class: "col-auto",
  style: { "width": "200px", "padding": "8px 0 0 0" }
};
const _hoisted_5$4 = { class: "row" };
const _hoisted_6$4 = { class: "col-auto" };
const _hoisted_7$2 = { class: "col-auto" };
const _hoisted_8$2 = { class: "col-auto" };
const _hoisted_9$2 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_10$2 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_11$1 = { class: "row" };
const _hoisted_12 = { class: "col-auto" };
const _hoisted_13 = { class: "col-auto" };
const _hoisted_14 = {
  key: 0,
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_15 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_16 = { class: "row" };
const _hoisted_17 = { class: "col-auto" };
const _hoisted_18 = { class: "col-auto" };
const _hoisted_19 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_20 = { class: "row" };
const _hoisted_21 = {
  class: "col-auto",
  style: { "width": "200px", "margin": "0 16px 0 0" }
};
const _hoisted_22 = {
  class: "col-auto",
  style: { "width": "250px" }
};
const _hoisted_23 = {
  class: "col-auto",
  style: { "width": "200px", "padding": "8px 0 0 0" }
};
const _hoisted_24 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_25 = { class: "row" };
const _hoisted_26 = {
  key: 0,
  class: "col-auto",
  style: { "width": "200px", "margin": "0 16px 0 0" }
};
const _hoisted_27 = {
  class: "col-auto",
  style: { "width": "200px" }
};
const _hoisted_28 = { class: "column" };
const _hoisted_29 = {
  class: "col-auto",
  style: { "width": "200px", "padding": "8px 0 0 0" }
};
const _hoisted_30 = { class: "row" };
const _hoisted_31 = { class: "col-auto" };
const _hoisted_32 = { class: "col-auto" };
const _hoisted_33 = { class: "col-auto" };
const _hoisted_34 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_35 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_36 = { class: "row" };
const _hoisted_37 = { class: "col-auto" };
const _hoisted_38 = { class: "col-auto" };
const _hoisted_39 = {
  key: 0,
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_40 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_41 = { class: "row" };
const _hoisted_42 = { class: "col-auto" };
const _hoisted_43 = { class: "col-auto" };
const _hoisted_44 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_45 = { class: "row" };
const _hoisted_46 = {
  class: "col-auto",
  style: { "width": "200px", "margin": "0 16px 0 0" }
};
const _hoisted_47 = {
  class: "col-auto",
  style: { "width": "250px" }
};
const _hoisted_48 = {
  class: "col-auto",
  style: { "width": "200px", "padding": "8px 0 0 0" }
};
const _hoisted_49 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_50 = { class: "row" };
const _hoisted_51 = {
  key: 0,
  class: "col-auto",
  style: { "width": "200px", "margin": "0 16px 0 0" }
};
const _hoisted_52 = {
  class: "col-auto",
  style: { "width": "200px" }
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "ProcessingSettingsTab",
  setup(__props) {
    const settings = useSettingsStore();
    let config = useConfigUpdateStore();
    const updateModeOptions = ["API", "COMIC_INFO", "OPF"];
    const libraryTypeOptions = ["MANGA", "NOVEL", "COMIC"];
    const readingDirectionOptions = ["LEFT_TO_RIGHT", "RIGHT_TO_LEFT", "VERTICAL", "WEBTOON"];
    const model = settings.mediaServer === MediaServer.Kavita ? config.kavitaMetadata : config.komgaMetadata;
    const tab = ref("default");
    const tabsKey2 = computed(() => model.library.map((p2) => p2.deleted).join());
    const tabPanel = ref(null);
    async function addLibrary(id2) {
      var _a2, _b, _c, _d;
      let existing = model.library.find((library) => library.id == id2);
      if (existing) {
        existing.deleted = false;
        await nextTick();
        (_a2 = tabPanel.value) == null ? void 0 : _a2.goTo(id2);
        return;
      }
      model.library.push({
        id: id2,
        name: (_c = (_b = config.libraries.find((l) => l.id == id2)) == null ? void 0 : _b.name) != null ? _c : "",
        deleted: false,
        libraryType: "MANGA",
        aggregateMetadata: false,
        mergeTags: false,
        mergeGenres: false,
        modes: ["API"],
        bookCovers: false,
        seriesCovers: false,
        overrideExistingCovers: true,
        seriesTitle: false,
        seriesTitleLanguage: "en",
        alternativeTitles: false,
        alternativeTitleLanguages: ["en", "ja", "ja-ro"],
        orderBooks: false,
        readingDirectionValue: null,
        languageValue: null
      });
      await nextTick();
      (_d = tabPanel.value) == null ? void 0 : _d.goTo(id2);
    }
    function removeLibrary(index2) {
      var _a2;
      model.library[index2].deleted = true;
      (_a2 = tabPanel.value) == null ? void 0 : _a2.goTo("default");
    }
    function getLibraries() {
      let libraryConfigs = model.library;
      return config.libraries.filter((library) => !libraryConfigs.find((conf) => !conf.deleted && conf.id == library.id));
    }
    function createValue(val, done) {
      if (en(val).res)
        done(val, "add-unique");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        (openBlock(), createBlock(QTabs, {
          modelValue: tab.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => tab.value = $event),
          dense: "",
          class: "text-grey",
          "active-color": "primary",
          "indicator-color": "primary",
          align: "justify",
          "narrow-indicator": "",
          key: unref(tabsKey2)
        }, {
          default: withCtx(() => [
            createVNode(QTab, {
              name: "default",
              label: "Default",
              "no-caps": ""
            }),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(model).library, (library, index2) => {
              return openBlock(), createElementBlock(Fragment, {
                key: library.id
              }, [
                !library.deleted ? (openBlock(), createBlock(QTab, {
                  key: 0,
                  name: library.id,
                  "no-caps": ""
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", null, [
                      createTextVNode(toDisplayString(`${library.name} (${library.id})`) + " ", 1),
                      createVNode(QBtn, {
                        flat: "",
                        size: "xs",
                        "icon-right": unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-close" : "fa fa-xmark",
                        onClick: ($event) => removeLibrary(index2)
                      }, null, 8, ["icon-right", "onClick"])
                    ])
                  ]),
                  _: 2
                }, 1032, ["name"])) : createCommentVNode("", true)
              ], 64);
            }), 128)),
            getLibraries().length ? (openBlock(), createBlock(QBtn, {
              key: 0,
              flat: ""
            }, {
              default: withCtx(() => [
                _hoisted_1$8,
                createBaseVNode("div", _hoisted_2$6, [
                  createVNode(QIcon, {
                    name: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-plus" : "fa fa-plus"
                  }, null, 8, ["name"])
                ]),
                createVNode(QMenu, { fit: "" }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(getLibraries(), (library, index2) => {
                      return openBlock(), createBlock(QList, { dense: "" }, {
                        default: withCtx(() => [
                          withDirectives((openBlock(), createBlock(QItem, {
                            clickable: "",
                            onClick: ($event) => addLibrary(library.id)
                          }, {
                            default: withCtx(() => [
                              createVNode(QItemSection, null, {
                                default: withCtx(() => [
                                  createVNode(QItemLabel, null, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString(library.name), 1)
                                    ]),
                                    _: 2
                                  }, 1024)
                                ]),
                                _: 2
                              }, 1024)
                            ]),
                            _: 2
                          }, 1032, ["onClick"])), [
                            [ClosePopup]
                          ])
                        ]),
                        _: 2
                      }, 1024);
                    }), 256))
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["modelValue"])),
        createVNode(QSeparator),
        createVNode(unref(QTabPanels), {
          modelValue: tab.value,
          "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => tab.value = $event),
          ref_key: "tabPanel",
          ref: tabPanel,
          animated: ""
        }, {
          default: withCtx(() => [
            createVNode(QTabPanel, {
              name: "default",
              style: { "padding": "8px 0 0 0" }
            }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_3$6, [
                  createBaseVNode("div", _hoisted_4$5, [
                    createVNode(unref(QSelect), {
                      filled: "",
                      dense: "",
                      modelValue: unref(model).default.libraryType,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(model).default.libraryType = $event),
                      options: libraryTypeOptions,
                      label: "Library type",
                      "dropdown-icon": "mdi-menu-down"
                    }, null, 8, ["modelValue"])
                  ]),
                  createBaseVNode("div", _hoisted_5$4, [
                    createBaseVNode("div", _hoisted_6$4, [
                      createVNode(QCheckbox, {
                        modelValue: unref(model).default.aggregateMetadata,
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(model).default.aggregateMetadata = $event),
                        label: "Aggregate from all providers"
                      }, null, 8, ["modelValue"])
                    ]),
                    createBaseVNode("div", _hoisted_7$2, [
                      createVNode(QCheckbox, {
                        modelValue: unref(model).default.mergeGenres,
                        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(model).default.mergeGenres = $event),
                        disable: !unref(model).default.aggregateMetadata,
                        label: "Merge Genres"
                      }, null, 8, ["modelValue", "disable"])
                    ]),
                    createBaseVNode("div", _hoisted_8$2, [
                      createVNode(QCheckbox, {
                        modelValue: unref(model).default.mergeTags,
                        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(model).default.mergeTags = $event),
                        disable: !unref(model).default.aggregateMetadata,
                        label: "Merge Tags"
                      }, null, 8, ["modelValue", "disable"])
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_9$2, [
                    createVNode(QCheckbox, {
                      modelValue: unref(model).default.orderBooks,
                      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(model).default.orderBooks = $event),
                      label: "Order Books"
                    }, null, 8, ["modelValue"])
                  ]),
                  createBaseVNode("div", _hoisted_10$2, [
                    createBaseVNode("div", _hoisted_11$1, [
                      createBaseVNode("div", _hoisted_12, [
                        createVNode(QCheckbox, {
                          modelValue: unref(model).default.seriesCovers,
                          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(model).default.seriesCovers = $event),
                          label: "Series Cover"
                        }, null, 8, ["modelValue"])
                      ]),
                      createBaseVNode("div", _hoisted_13, [
                        createVNode(QCheckbox, {
                          modelValue: unref(model).default.bookCovers,
                          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(model).default.bookCovers = $event),
                          label: "Book Cover"
                        }, null, 8, ["modelValue"])
                      ])
                    ])
                  ]),
                  unref(settings).mediaServer === unref(MediaServer).Komga ? (openBlock(), createElementBlock("div", _hoisted_14, [
                    createVNode(QCheckbox, {
                      modelValue: unref(model).default.overrideExistingCovers,
                      "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => unref(model).default.overrideExistingCovers = $event),
                      label: "Override Existing Covers"
                    }, null, 8, ["modelValue"])
                  ])) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_15, [
                    createBaseVNode("div", _hoisted_16, [
                      createBaseVNode("div", _hoisted_17, [
                        createVNode(QCheckbox, {
                          modelValue: unref(model).default.seriesTitle,
                          "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => unref(model).default.seriesTitle = $event),
                          label: "Series Title"
                        }, null, 8, ["modelValue"])
                      ]),
                      createBaseVNode("div", _hoisted_18, [
                        createVNode(QCheckbox, {
                          modelValue: unref(model).default.alternativeTitles,
                          "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => unref(model).default.alternativeTitles = $event),
                          label: "Alternative Series Titles"
                        }, null, 8, ["modelValue"])
                      ])
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_19, [
                    createBaseVNode("div", _hoisted_20, [
                      createBaseVNode("div", _hoisted_21, [
                        createVNode(unref(QInput), {
                          modelValue: unref(model).default.seriesTitleLanguage,
                          "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => unref(model).default.seriesTitleLanguage = $event),
                          label: "Title Language",
                          filled: "",
                          dense: "",
                          hint: "BCP 47 language tag. ja-ro for romanized",
                          "hide-hint": "",
                          rules: [(val) => unref(en)(val).res]
                        }, null, 8, ["modelValue", "rules"])
                      ]),
                      createBaseVNode("div", _hoisted_22, [
                        createVNode(unref(QSelect), {
                          modelValue: unref(model).default.alternativeTitleLanguages,
                          "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => unref(model).default.alternativeTitleLanguages = $event),
                          label: "Alternative Title Languages",
                          filled: "",
                          dense: "",
                          "use-input": "",
                          "use-chips": "",
                          multiple: "",
                          "hide-dropdown-icon": "",
                          "input-debounce": "0",
                          onNewValue: createValue,
                          hint: "BCP 47 language tag. ja-ro for romanized",
                          "hide-hint": ""
                        }, null, 8, ["modelValue"])
                      ])
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_23, [
                    createVNode(unref(QSelect), {
                      filled: "",
                      dense: "",
                      modelValue: unref(model).default.modes,
                      "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => unref(model).default.modes = $event),
                      multiple: "",
                      options: updateModeOptions,
                      label: "Update modes",
                      "dropdown-icon": "mdi-menu-down"
                    }, null, 8, ["modelValue"])
                  ]),
                  createBaseVNode("div", _hoisted_24, [
                    createBaseVNode("div", _hoisted_25, [
                      unref(settings).mediaServer === unref(MediaServer).Komga ? (openBlock(), createElementBlock("div", _hoisted_26, [
                        createVNode(unref(QSelect), {
                          filled: "",
                          dense: "",
                          clearable: "",
                          modelValue: unref(model).default.readingDirectionValue,
                          "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => unref(model).default.readingDirectionValue = $event),
                          options: readingDirectionOptions,
                          label: "Default Reading Direction",
                          "dropdown-icon": "mdi-menu-down"
                        }, null, 8, ["modelValue"])
                      ])) : createCommentVNode("", true),
                      createBaseVNode("div", _hoisted_27, [
                        createVNode(unref(QInput), {
                          modelValue: unref(model).default.languageValue,
                          "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => unref(model).default.languageValue = $event),
                          label: "Series Default Language",
                          dense: "",
                          filled: "",
                          clearable: "",
                          hint: "IETF BCP 47 language tag",
                          "hide-hint": "",
                          rules: [(val) => val === "" || val == null || unref(en)(val).res]
                        }, null, 8, ["modelValue", "rules"])
                      ])
                    ])
                  ])
                ])
              ]),
              _: 1
            }),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(model).library, (library, libraryIndex) => {
              return openBlock(), createElementBlock(Fragment, {
                key: library.id
              }, [
                !library.deleted ? (openBlock(), createBlock(QTabPanel, {
                  key: 0,
                  name: library.id,
                  style: { "padding": "8px 0 0 0" }
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_28, [
                      createBaseVNode("div", _hoisted_29, [
                        createVNode(unref(QSelect), {
                          filled: "",
                          dense: "",
                          modelValue: unref(model).library[libraryIndex].libraryType,
                          "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].libraryType = $event,
                          options: libraryTypeOptions,
                          label: "Library type",
                          "dropdown-icon": "mdi-menu-down"
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                      ]),
                      createBaseVNode("div", _hoisted_30, [
                        createBaseVNode("div", _hoisted_31, [
                          createVNode(QCheckbox, {
                            modelValue: unref(model).library[libraryIndex].aggregateMetadata,
                            "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].aggregateMetadata = $event,
                            label: "Aggregate from all providers"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ]),
                        createBaseVNode("div", _hoisted_32, [
                          createVNode(QCheckbox, {
                            modelValue: unref(model).library[libraryIndex].mergeGenres,
                            "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].mergeGenres = $event,
                            disable: !unref(model).library[libraryIndex].aggregateMetadata,
                            label: "Merge Genres"
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"])
                        ]),
                        createBaseVNode("div", _hoisted_33, [
                          createVNode(QCheckbox, {
                            modelValue: unref(model).library[libraryIndex].mergeTags,
                            "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].mergeTags = $event,
                            disable: !unref(model).library[libraryIndex].aggregateMetadata,
                            label: "Merge Tags"
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "disable"])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_34, [
                        createVNode(QCheckbox, {
                          modelValue: unref(model).library[libraryIndex].orderBooks,
                          "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].orderBooks = $event,
                          label: "Order Books"
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                      ]),
                      createBaseVNode("div", _hoisted_35, [
                        createBaseVNode("div", _hoisted_36, [
                          createBaseVNode("div", _hoisted_37, [
                            createVNode(QCheckbox, {
                              modelValue: unref(model).library[libraryIndex].seriesCovers,
                              "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].seriesCovers = $event,
                              label: "Series Cover"
                            }, null, 8, ["modelValue", "onUpdate:modelValue"])
                          ]),
                          createBaseVNode("div", _hoisted_38, [
                            createVNode(QCheckbox, {
                              modelValue: unref(model).library[libraryIndex].bookCovers,
                              "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].bookCovers = $event,
                              label: "Book Cover"
                            }, null, 8, ["modelValue", "onUpdate:modelValue"])
                          ])
                        ])
                      ]),
                      unref(settings).mediaServer === unref(MediaServer).Komga ? (openBlock(), createElementBlock("div", _hoisted_39, [
                        createVNode(QCheckbox, {
                          modelValue: unref(model).library[libraryIndex].overrideExistingCovers,
                          "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].overrideExistingCovers = $event,
                          label: "Override Existing Covers"
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                      ])) : createCommentVNode("", true),
                      createBaseVNode("div", _hoisted_40, [
                        createBaseVNode("div", _hoisted_41, [
                          createBaseVNode("div", _hoisted_42, [
                            createVNode(QCheckbox, {
                              modelValue: unref(model).library[libraryIndex].seriesTitle,
                              "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].seriesTitle = $event,
                              label: "Series Title"
                            }, null, 8, ["modelValue", "onUpdate:modelValue"])
                          ]),
                          createBaseVNode("div", _hoisted_43, [
                            createVNode(QCheckbox, {
                              modelValue: unref(model).library[libraryIndex].alternativeTitles,
                              "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].alternativeTitles = $event,
                              label: "Alternative Series Titles"
                            }, null, 8, ["modelValue", "onUpdate:modelValue"])
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_44, [
                        createBaseVNode("div", _hoisted_45, [
                          createBaseVNode("div", _hoisted_46, [
                            createVNode(unref(QInput), {
                              modelValue: unref(model).library[libraryIndex].seriesTitleLanguage,
                              "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].seriesTitleLanguage = $event,
                              label: "Title Language",
                              filled: "",
                              dense: "",
                              hint: "BCP 47 language tag. ja-ro for romanized",
                              "hide-hint": "",
                              rules: [(val) => unref(en)(val).res]
                            }, null, 8, ["modelValue", "onUpdate:modelValue", "rules"])
                          ]),
                          createBaseVNode("div", _hoisted_47, [
                            createVNode(unref(QSelect), {
                              modelValue: unref(model).library[libraryIndex].alternativeTitleLanguages,
                              "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].alternativeTitleLanguages = $event,
                              label: "Alternative Title Languages",
                              filled: "",
                              dense: "",
                              "use-input": "",
                              "use-chips": "",
                              multiple: "",
                              "hide-dropdown-icon": "",
                              "input-debounce": "0",
                              "new-value-mode": "add-unique",
                              hint: "BCP 47 language tag. ja-ro for romanized",
                              "hide-hint": ""
                            }, null, 8, ["modelValue", "onUpdate:modelValue"])
                          ])
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_48, [
                        createVNode(unref(QSelect), {
                          filled: "",
                          dense: "",
                          modelValue: unref(model).library[libraryIndex].modes,
                          "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].modes = $event,
                          multiple: "",
                          options: updateModeOptions,
                          label: "Update modes",
                          "dropdown-icon": "mdi-menu-down"
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                      ]),
                      createBaseVNode("div", _hoisted_49, [
                        createBaseVNode("div", _hoisted_50, [
                          unref(settings).mediaServer === unref(MediaServer).Komga ? (openBlock(), createElementBlock("div", _hoisted_51, [
                            createVNode(unref(QSelect), {
                              filled: "",
                              dense: "",
                              clearable: "",
                              modelValue: unref(model).library[libraryIndex].readingDirectionValue,
                              "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].readingDirectionValue = $event,
                              options: readingDirectionOptions,
                              label: "Default Reading Direction",
                              "dropdown-icon": "mdi-menu-down"
                            }, null, 8, ["modelValue", "onUpdate:modelValue"])
                          ])) : createCommentVNode("", true),
                          createBaseVNode("div", _hoisted_52, [
                            createVNode(unref(QInput), {
                              modelValue: unref(model).library[libraryIndex].languageValue,
                              "onUpdate:modelValue": ($event) => unref(model).library[libraryIndex].languageValue = $event,
                              label: "Series Default Language",
                              dense: "",
                              filled: "",
                              clearable: "",
                              hint: "IETF BCP 47 language tag",
                              "hide-hint": "",
                              rules: [(val) => val === "" || val == null || unref(en)(val).res]
                            }, null, 8, ["modelValue", "onUpdate:modelValue", "rules"])
                          ])
                        ])
                      ])
                    ])
                  ]),
                  _: 2
                }, 1032, ["name"])) : createCommentVNode("", true)
              ], 64);
            }), 128))
          ]),
          _: 1
        }, 8, ["modelValue"])
      ], 64);
    };
  }
});
const ProcessingSettingsTab_vue_vue_type_style_index_0_scoped_bc55357c_lang = "";
const ProcessingSettingsTab = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-bc55357c"]]);
const _withScopeId$2 = (n) => (pushScopeId("data-v-900556a4"), n = n(), popScopeId(), n);
const _hoisted_1$7 = { class: "column" };
const _hoisted_2$5 = { class: "text-h6 gt-xs q-pb-lg" };
const _hoisted_3$5 = { class: "col-auto" };
const _hoisted_4$4 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_5$3 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_6$3 = { class: "row" };
const _hoisted_7$1 = {
  class: "col",
  style: { "padding": "0" }
};
const _hoisted_8$1 = {
  key: 0,
  class: "col-auto",
  style: { "padding": "0" }
};
const _hoisted_9$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "text-body2 q-pt-sm" }, "Event Listener", -1));
const _hoisted_10$1 = { class: "col-auto" };
const _hoisted_11 = { class: "col-auto" };
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "KomgaSettingsTab",
  setup(__props) {
    let isPwd = ref(true);
    let configStore = useConfigUpdateStore();
    let config = configStore.komga;
    function libraryLabel(library) {
      return `${library.name} (${library.id})`;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        createBaseVNode("div", _hoisted_2$5, [
          createVNode(QIcon, { name: "mdi-server" }),
          createTextVNode(" Komga ")
        ]),
        createBaseVNode("div", _hoisted_3$5, [
          createVNode(QInput, {
            modelValue: unref(config).baseUri,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(config).baseUri = $event),
            label: "Base Uri",
            filled: ""
          }, null, 8, ["modelValue"])
        ]),
        createBaseVNode("div", _hoisted_4$4, [
          createVNode(QInput, {
            modelValue: unref(config).user,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(config).user = $event),
            label: "User",
            filled: ""
          }, null, 8, ["modelValue"])
        ]),
        createBaseVNode("div", _hoisted_5$3, [
          createBaseVNode("div", _hoisted_6$3, [
            createBaseVNode("div", _hoisted_7$1, [
              createVNode(QInput, {
                modelValue: unref(config).password,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(config).password = $event),
                label: "Password",
                type: unref(isPwd) ? "password" : "text",
                filled: "",
                disable: unref(config).passwordDisabled
              }, createSlots({ _: 2 }, [
                !unref(config).passwordDisabled ? {
                  name: "append",
                  fn: withCtx(() => [
                    createVNode(QIcon, {
                      name: unref(isPwd) ? "mdi-eye-off" : "mdi-eye",
                      class: "cursor-pointer",
                      onClick: _cache[2] || (_cache[2] = ($event) => isRef(isPwd) ? isPwd.value = !unref(isPwd) : isPwd = !unref(isPwd))
                    }, null, 8, ["name"])
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["modelValue", "type", "disable"])
            ]),
            unref(config).passwordDisabled ? (openBlock(), createElementBlock("div", _hoisted_8$1, [
              createVNode(QBtn, {
                onClick: _cache[4] || (_cache[4] = ($event) => {
                  unref(config).password = "";
                  unref(config).passwordDisabled = false;
                }),
                flat: "",
                round: "",
                icon: "mdi-pencil",
                size: "md"
              })
            ])) : createCommentVNode("", true)
          ])
        ]),
        _hoisted_9$1,
        createBaseVNode("div", _hoisted_10$1, [
          createVNode(QCheckbox, {
            modelValue: unref(config).eventListener.enabled,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(config).eventListener.enabled = $event),
            label: "Enable Event Listener"
          }, null, 8, ["modelValue"])
        ]),
        createBaseVNode("div", _hoisted_11, [
          createVNode(QSelect, {
            filled: "",
            modelValue: unref(config).eventListener.libraries,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(config).eventListener.libraries = $event),
            multiple: "",
            clearable: "",
            options: unref(configStore).libraries,
            "option-label": libraryLabel,
            label: "Listen Libraries",
            hint: "will match all libraries if empty"
          }, null, 8, ["modelValue", "options"])
        ])
      ]);
    };
  }
});
const KomgaSettingsTab_vue_vue_type_style_index_0_scoped_900556a4_lang = "";
const KomgaSettingsTab = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-900556a4"]]);
const _withScopeId$1 = (n) => (pushScopeId("data-v-a40fbadc"), n = n(), popScopeId(), n);
const _hoisted_1$6 = { class: "column" };
const _hoisted_2$4 = { class: "text-h6 gt-xs q-pb-lg" };
const _hoisted_3$4 = { class: "col-auto" };
const _hoisted_4$3 = {
  class: "col-auto",
  style: { "padding": "8px 0 0 0" }
};
const _hoisted_5$2 = { class: "row" };
const _hoisted_6$2 = {
  class: "col",
  style: { "padding": "0" }
};
const _hoisted_7 = {
  key: 0,
  class: "col-auto",
  style: { "padding": "0" }
};
const _hoisted_8 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "text-body2 q-pt-sm" }, "Event Listener", -1));
const _hoisted_9 = { class: "col-auto" };
const _hoisted_10 = { class: "col-auto" };
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "KavitaSettingsTab",
  setup(__props) {
    const configStore = useConfigUpdateStore();
    const config = configStore.kavita;
    const apiKeyDisabled = ref(config.apiKey == "");
    function libraryLabel(library) {
      return `${library.name} (${library.id})`;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createBaseVNode("div", _hoisted_2$4, [
          createVNode(QIcon, { name: "fa fa-server" }),
          createTextVNode(" Kavita ")
        ]),
        createBaseVNode("div", _hoisted_3$4, [
          createVNode(QInput, {
            modelValue: unref(config).baseUri,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(config).baseUri = $event),
            label: "Base Uri",
            filled: ""
          }, null, 8, ["modelValue"])
        ]),
        createBaseVNode("div", _hoisted_4$3, [
          createBaseVNode("div", _hoisted_5$2, [
            createBaseVNode("div", _hoisted_6$2, [
              createVNode(QInput, {
                modelValue: unref(config).apiKey,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(config).apiKey = $event),
                label: "API Key",
                filled: "",
                disable: apiKeyDisabled.value
              }, null, 8, ["modelValue", "disable"])
            ]),
            apiKeyDisabled.value ? (openBlock(), createElementBlock("div", _hoisted_7, [
              createVNode(QBtn, {
                onClick: _cache[2] || (_cache[2] = ($event) => {
                  unref(config).apiKey = "";
                  apiKeyDisabled.value = false;
                }),
                flat: "",
                round: "",
                icon: "fa fa-pencil",
                size: "sm"
              })
            ])) : createCommentVNode("", true)
          ])
        ]),
        _hoisted_8,
        createBaseVNode("div", _hoisted_9, [
          createVNode(QCheckbox, {
            modelValue: unref(config).eventListener.enabled,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(config).eventListener.enabled = $event),
            label: "Enable Event Listener"
          }, null, 8, ["modelValue"])
        ]),
        createBaseVNode("div", _hoisted_10, [
          createVNode(QSelect, {
            filled: "",
            modelValue: unref(config).eventListener.libraries,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => unref(config).eventListener.libraries = $event),
            multiple: "",
            clearable: "",
            options: unref(configStore).libraries,
            "option-label": libraryLabel,
            label: "Listen Libraries",
            hint: "will match all libraries if empty"
          }, null, 8, ["modelValue", "options"])
        ])
      ]);
    };
  }
});
const KavitaSettingsTab_vue_vue_type_style_index_0_scoped_a40fbadc_lang = "";
const KavitaSettingsTab = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-a40fbadc"]]);
const _hoisted_1$5 = {
  class: "flex",
  style: { "max-width": "800px", "width": "800px", "max-height": "850px" }
};
const _hoisted_2$3 = { class: "text-h6 gt-xs q-pb-lg" };
const _hoisted_3$3 = { class: "row justify-start" };
const _hoisted_4$2 = { class: "col-auto" };
const _hoisted_5$1 = {
  key: 0,
  class: "col-auto offset-md-1"
};
const _hoisted_6$1 = {
  key: 1,
  class: "col-auto offset-md-1"
};
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "SettingsDialog",
  emits: [
    ...useDialogPluginComponent.emits
  ],
  setup(__props) {
    const { dialogRef, onDialogHide, onDialogOK, onDialogCancel } = useDialogPluginComponent();
    const quasar = useQuasar();
    inject(komfMetadataKey);
    const configService = inject(komfConfigKey);
    const settings = useSettingsStore();
    const configUpdateStore = useConfigUpdateStore();
    const tab = ref("connection");
    const splitterModel = ref(20);
    const connectionLoading = ref(false);
    const connectionError = ref("");
    const connectionSuccess = ref(false);
    const configUpdating = ref(false);
    const komfUrl = ref(settings.komfUrl);
    loadConfig();
    function dialogCancel() {
      komfUrl.value = settings.komfUrl;
    }
    async function dialogConfirm() {
      settings.komfUrl = komfUrl.value.replace(/\/$/, "");
      if (connectionSuccess.value) {
        await updateConfig();
      }
      onDialogOK();
    }
    async function updateConfig() {
      configUpdating.value = true;
      let config = configUpdateStore.getUpdates();
      if (Object.entries(config).every((val) => val[1] === void 0)) {
        configUpdating.value = false;
        return;
      }
      try {
        await configService.updateConfig(config);
      } catch (e) {
        errorNotification(e, quasar);
        dialogCancel();
        onDialogCancel();
        return;
      }
      await loadConfig();
      let pollRetries = 0;
      while (!connectionSuccess.value && pollRetries <= 5) {
        pollRetries += 1;
        await new Promise((resolve2) => setTimeout(resolve2, 1e3));
        await loadConfig();
      }
      configUpdating.value = false;
      if (pollRetries >= 5) {
        quasar.notify({
          message: "Connection Timeout",
          color: "negative",
          closeBtn: true,
          timeout: 5e3
        });
      }
    }
    async function loadConfig() {
      connectionError.value = "";
      connectionSuccess.value = false;
      connectionLoading.value = true;
      let config;
      try {
        config = await configService.getConfigFromUrl(komfUrl.value.replace(/\/$/, ""));
      } catch (e) {
        if (e instanceof Error)
          connectionError.value = e.message;
        else
          connectionError.value = String(e);
        connectionLoading.value = false;
        return;
      }
      configUpdateStore.reset(config);
      connectionSuccess.value = true;
      connectionLoading.value = false;
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(QDialog, {
        ref_key: "dialogRef",
        ref: dialogRef,
        onHide: unref(onDialogHide),
        onBeforeHide: dialogCancel,
        "allow-focus-outside": "",
        persistent: configUpdating.value
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$5, [
            createVNode(QCard, { class: "q-dialog-plugin full-width" }, {
              default: withCtx(() => [
                createVNode(QCardSection, { horizontal: "" }, {
                  default: withCtx(() => [
                    createVNode(QSplitter, {
                      modelValue: splitterModel.value,
                      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => splitterModel.value = $event),
                      disable: "",
                      style: { "min-height": "300px" }
                    }, {
                      before: withCtx(() => [
                        createVNode(QTabs, {
                          modelValue: tab.value,
                          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => tab.value = $event),
                          vertical: "",
                          shrink: "",
                          "inline-label": "",
                          "active-color": "info",
                          class: normalizeClass({ "text-teal": connectionSuccess.value, "text-blue-grey": !connectionSuccess.value })
                        }, {
                          default: withCtx(() => [
                            createVNode(QTab, {
                              name: "connection",
                              label: "Connection",
                              icon: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-connection" : "fa fa-plug"
                            }, null, 8, ["icon"]),
                            unref(settings).mediaServer === unref(MediaServer).Komga ? (openBlock(), createBlock(QTab, {
                              key: 0,
                              name: "komga",
                              label: "Komga",
                              disable: !connectionSuccess.value,
                              icon: "mdi-server"
                            }, null, 8, ["disable"])) : createCommentVNode("", true),
                            unref(settings).mediaServer === unref(MediaServer).Kavita ? (openBlock(), createBlock(QTab, {
                              key: 1,
                              name: "kavita",
                              label: "Kavita",
                              disable: !connectionSuccess.value,
                              icon: "fa fa-server"
                            }, null, 8, ["disable"])) : createCommentVNode("", true),
                            createVNode(QTab, {
                              name: "providers",
                              label: "Providers",
                              disable: !connectionSuccess.value,
                              icon: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-file-document" : "fa fa-file-lines"
                            }, null, 8, ["disable", "icon"]),
                            createVNode(QTab, {
                              name: "processing",
                              label: "Processing",
                              disable: !connectionSuccess.value,
                              icon: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-file-refresh" : "fa fa-file-code"
                            }, null, 8, ["disable", "icon"]),
                            createVNode(QTab, {
                              name: "notifications",
                              label: "Notifications",
                              disable: !connectionSuccess.value,
                              icon: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-bell" : "fa fa-bell"
                            }, null, 8, ["disable", "icon"])
                          ]),
                          _: 1
                        }, 8, ["modelValue", "class"])
                      ]),
                      after: withCtx(() => [
                        createVNode(QTabPanels, {
                          modelValue: tab.value,
                          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => tab.value = $event),
                          animated: "",
                          vertical: "",
                          draggable: "false",
                          "transition-prev": "fade",
                          "transition-next": "fade"
                        }, {
                          default: withCtx(() => [
                            createVNode(QTabPanel, { name: "connection" }, {
                              default: withCtx(() => [
                                createBaseVNode("div", _hoisted_2$3, [
                                  createVNode(QIcon, {
                                    name: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-connection" : "fa fa-plug"
                                  }, null, 8, ["name"]),
                                  createTextVNode(" Connection ")
                                ]),
                                createVNode(QCard, { flat: "" }, {
                                  default: withCtx(() => [
                                    createVNode(QInput, {
                                      class: "q-pt-sm q-pb-sm",
                                      modelValue: komfUrl.value,
                                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => komfUrl.value = $event),
                                      label: "komf url",
                                      filled: ""
                                    }, null, 8, ["modelValue"]),
                                    createBaseVNode("div", _hoisted_3$3, [
                                      createBaseVNode("div", _hoisted_4$2, [
                                        createVNode(QBtn, {
                                          class: "text-body2",
                                          color: "secondary",
                                          "no-caps": "",
                                          onClick: loadConfig
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("Check connection ")
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      connectionSuccess.value && !configUpdating.value ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
                                        createTextVNode(" Connected "),
                                        createVNode(QIcon, {
                                          name: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-check" : "fa fa-check",
                                          color: "positive"
                                        }, null, 8, ["name"])
                                      ])) : createCommentVNode("", true),
                                      connectionError.value && !configUpdating.value ? (openBlock(), createElementBlock("div", _hoisted_6$1, [
                                        createTextVNode(toDisplayString(connectionError.value) + " ", 1),
                                        createVNode(QIcon, {
                                          name: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-alert-circle" : "fa fa-circle-exclamation",
                                          color: "negative"
                                        }, null, 8, ["name"])
                                      ])) : createCommentVNode("", true)
                                    ])
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            }),
                            createVNode(QTabPanel, { name: "komga" }, {
                              default: withCtx(() => [
                                createVNode(KomgaSettingsTab)
                              ]),
                              _: 1
                            }),
                            createVNode(QTabPanel, { name: "kavita" }, {
                              default: withCtx(() => [
                                createVNode(KavitaSettingsTab)
                              ]),
                              _: 1
                            }),
                            createVNode(QTabPanel, { name: "providers" }, {
                              default: withCtx(() => [
                                createVNode(MetadataProvidersSettingsTab)
                              ]),
                              _: 1
                            }),
                            createVNode(QTabPanel, { name: "processing" }, {
                              default: withCtx(() => [
                                createVNode(ProcessingSettingsTab)
                              ]),
                              _: 1
                            }),
                            createVNode(QTabPanel, { name: "notifications" }, {
                              default: withCtx(() => [
                                createVNode(NotificationsSettingsTab)
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    }, 8, ["modelValue"])
                  ]),
                  _: 1
                }),
                createVNode(QCardActions, {
                  align: "right",
                  class: "q-pt-xs q-pb-md q-pr-md"
                }, {
                  default: withCtx(() => [
                    createVNode(QBtn, {
                      disable: configUpdating.value,
                      flat: "",
                      onClick: unref(onDialogCancel)
                    }, {
                      default: withCtx(() => [
                        createTextVNode("Cancel")
                      ]),
                      _: 1
                    }, 8, ["disable", "onClick"]),
                    createVNode(QBtn, {
                      color: "secondary",
                      loading: configUpdating.value,
                      onClick: _cache[4] || (_cache[4] = ($event) => dialogConfirm())
                    }, {
                      default: withCtx(() => [
                        createTextVNode(" Save ")
                      ]),
                      _: 1
                    }, 8, ["loading"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ])
        ]),
        _: 1
      }, 8, ["onHide", "persistent"]);
    };
  }
});
const SettingsDialog_vue_vue_type_style_index_0_scoped_4ca1e240_lang = "";
const SettingsDialog = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-4ca1e240"]]);
const useCircularCommonProps = {
  ...useSizeProps,
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  color: String,
  centerColor: String,
  trackColor: String,
  fontSize: String,
  rounded: Boolean,
  thickness: {
    type: Number,
    default: 0.2,
    validator: (v2) => v2 >= 0 && v2 <= 1
  },
  angle: {
    type: Number,
    default: 0
  },
  showValue: Boolean,
  reverse: Boolean,
  instantFeedback: Boolean
};
const radius = 50, diameter = 2 * radius, circumference = diameter * Math.PI, strokeDashArray = Math.round(circumference * 1e3) / 1e3;
const QCircularProgress = createComponent({
  name: "QCircularProgress",
  props: {
    ...useCircularCommonProps,
    value: {
      type: Number,
      default: 0
    },
    animationSpeed: {
      type: [String, Number],
      default: 600
    },
    indeterminate: Boolean
  },
  setup(props, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const sizeStyle = useSize(props);
    const svgStyle = computed(() => {
      const angle = ($q.lang.rtl === true ? -1 : 1) * props.angle;
      return {
        transform: props.reverse !== ($q.lang.rtl === true) ? `scale3d(-1, 1, 1) rotate3d(0, 0, 1, ${-90 - angle}deg)` : `rotate3d(0, 0, 1, ${angle - 90}deg)`
      };
    });
    const circleStyle = computed(() => props.instantFeedback !== true && props.indeterminate !== true ? { transition: `stroke-dashoffset ${props.animationSpeed}ms ease 0s, stroke ${props.animationSpeed}ms ease` } : "");
    const viewBox = computed(() => diameter / (1 - props.thickness / 2));
    const viewBoxAttr = computed(
      () => `${viewBox.value / 2} ${viewBox.value / 2} ${viewBox.value} ${viewBox.value}`
    );
    const normalized = computed(() => between(props.value, props.min, props.max));
    const strokeDashOffset = computed(() => circumference * (1 - (normalized.value - props.min) / (props.max - props.min)));
    const strokeWidth = computed(() => props.thickness / 2 * viewBox.value);
    function getCircle({ thickness, offset, color, cls, rounded }) {
      return h("circle", {
        class: "q-circular-progress__" + cls + (color !== void 0 ? ` text-${color}` : ""),
        style: circleStyle.value,
        fill: "transparent",
        stroke: "currentColor",
        "stroke-width": thickness,
        "stroke-dasharray": strokeDashArray,
        "stroke-dashoffset": offset,
        "stroke-linecap": rounded,
        cx: viewBox.value,
        cy: viewBox.value,
        r: radius
      });
    }
    return () => {
      const svgChild = [];
      props.centerColor !== void 0 && props.centerColor !== "transparent" && svgChild.push(
        h("circle", {
          class: `q-circular-progress__center text-${props.centerColor}`,
          fill: "currentColor",
          r: radius - strokeWidth.value / 2,
          cx: viewBox.value,
          cy: viewBox.value
        })
      );
      props.trackColor !== void 0 && props.trackColor !== "transparent" && svgChild.push(
        getCircle({
          cls: "track",
          thickness: strokeWidth.value,
          offset: 0,
          color: props.trackColor
        })
      );
      svgChild.push(
        getCircle({
          cls: "circle",
          thickness: strokeWidth.value,
          offset: strokeDashOffset.value,
          color: props.color,
          rounded: props.rounded === true ? "round" : void 0
        })
      );
      const child = [
        h("svg", {
          class: "q-circular-progress__svg",
          style: svgStyle.value,
          viewBox: viewBoxAttr.value,
          "aria-hidden": "true"
        }, svgChild)
      ];
      props.showValue === true && child.push(
        h("div", {
          class: "q-circular-progress__text absolute-full row flex-center content-center",
          style: { fontSize: props.fontSize }
        }, slots.default !== void 0 ? slots.default() : [h("div", normalized.value)])
      );
      return h("div", {
        class: `q-circular-progress q-circular-progress--${props.indeterminate === true ? "in" : ""}determinate`,
        style: sizeStyle.value,
        role: "progressbar",
        "aria-valuemin": props.min,
        "aria-valuemax": props.max,
        "aria-valuenow": props.indeterminate === true ? void 0 : normalized.value
      }, hMergeSlotSafely(slots.internal, child));
    };
  }
});
const _hoisted_1$4 = { class: "text-h6" };
const _hoisted_2$2 = { class: "row q-pa-md" };
const _hoisted_3$2 = {
  key: 0,
  class: "col text-body2"
};
const _hoisted_4$1 = ["innerHTML"];
const _hoisted_5 = {
  key: 0,
  class: "row"
};
const _hoisted_6 = { class: "col text-body2" };
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "ConfirmationDialog",
  props: {
    value: Boolean,
    title: {
      type: String,
      required: true
    },
    body: {
      type: String,
      required: false
    },
    bodyHtml: {
      type: String,
      required: false
    },
    confirmText: {
      type: String,
      required: false
    },
    buttonCancel: {
      type: String,
      required: false
    },
    buttonConfirm: {
      type: String,
      required: true
    },
    buttonConfirmColor: {
      type: String,
      default: "primary"
    }
  },
  emits: [
    ...useDialogPluginComponent.emits
  ],
  setup(__props) {
    const props = __props;
    const { dialogRef, onDialogHide, onDialogOK, onDialogCancel } = useDialogPluginComponent();
    const confirmation = ref(false);
    const buttonColor = computed(() => confirmation.value ? props.buttonConfirmColor : "");
    function dialogCancel() {
      confirmation.value = false;
    }
    function dialogConfirm() {
      onDialogOK();
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(QDialog, {
        ref_key: "dialogRef",
        ref: dialogRef,
        onHide: unref(onDialogHide),
        onBeforeHide: dialogCancel
      }, {
        default: withCtx(() => [
          createVNode(QCard, {
            class: "q-dialog-plugin",
            style: { "max-width": "450px", "width": "450px" }
          }, {
            default: withCtx(() => [
              createVNode(QCardSection, null, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_1$4, toDisplayString(__props.title), 1),
                  createBaseVNode("div", _hoisted_2$2, [
                    __props.body && !__props.bodyHtml ? (openBlock(), createElementBlock("div", _hoisted_3$2, toDisplayString(__props.body), 1)) : createCommentVNode("", true),
                    __props.bodyHtml ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: "col text-body2",
                      innerHTML: __props.bodyHtml
                    }, null, 8, _hoisted_4$1)) : createCommentVNode("", true)
                  ]),
                  __props.confirmText ? (openBlock(), createElementBlock("div", _hoisted_5, [
                    createBaseVNode("div", _hoisted_6, [
                      createVNode(QCheckbox, {
                        modelValue: confirmation.value,
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => confirmation.value = $event),
                        color: __props.buttonConfirmColor,
                        label: __props.confirmText
                      }, null, 8, ["modelValue", "color", "label"])
                    ])
                  ])) : createCommentVNode("", true)
                ]),
                _: 1
              }),
              createVNode(QCardActions, { align: "right" }, {
                default: withCtx(() => [
                  createVNode(QBtn, { onClick: unref(onDialogCancel) }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(__props.buttonCancel || "Cancel"), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  createVNode(QBtn, {
                    color: unref(buttonColor),
                    onClick: dialogConfirm,
                    disable: __props.confirmText != null && !confirmation.value
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(__props.buttonConfirm), 1)
                    ]),
                    _: 1
                  }, 8, ["color", "disable"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["onHide"]);
    };
  }
});
const ConfirmationDialog_vue_vue_type_style_index_0_scoped_b23b5d99_lang = "";
const ConfirmationDialog = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-b23b5d99"]]);
const QToolbarTitle = createComponent({
  name: "QToolbarTitle",
  props: {
    shrink: Boolean
  },
  setup(props, { slots }) {
    const classes = computed(
      () => "q-toolbar__title ellipsis" + (props.shrink === true ? " col-shrink" : "")
    );
    return () => h("div", { class: classes.value }, hSlot(slots.default));
  }
});
const QToolbar = createComponent({
  name: "QToolbar",
  props: {
    inset: Boolean
  },
  setup(props, { slots }) {
    const classes = computed(
      () => "q-toolbar row no-wrap items-center" + (props.inset === true ? " q-toolbar--inset" : "")
    );
    return () => h("div", { class: classes.value, role: "toolbar" }, hSlot(slots.default));
  }
});
const useRatioProps = {
  ratio: [String, Number]
};
function useRatio(props, naturalRatio) {
  return computed(() => {
    const ratio = Number(
      props.ratio || (naturalRatio !== void 0 ? naturalRatio.value : void 0)
    );
    return isNaN(ratio) !== true && ratio > 0 ? { paddingBottom: `${100 / ratio}%` } : null;
  });
}
const defaultRatio = 16 / 9;
const QImg = createComponent({
  name: "QImg",
  props: {
    ...useRatioProps,
    src: String,
    srcset: String,
    sizes: String,
    alt: String,
    crossorigin: String,
    decoding: String,
    referrerpolicy: String,
    draggable: Boolean,
    loading: {
      type: String,
      default: "lazy"
    },
    fetchpriority: {
      type: String,
      default: "auto"
    },
    width: String,
    height: String,
    initialRatio: {
      type: [Number, String],
      default: defaultRatio
    },
    placeholderSrc: String,
    fit: {
      type: String,
      default: "cover"
    },
    position: {
      type: String,
      default: "50% 50%"
    },
    imgClass: String,
    imgStyle: Object,
    noSpinner: Boolean,
    noNativeMenu: Boolean,
    noTransition: Boolean,
    spinnerColor: String,
    spinnerSize: String
  },
  emits: ["load", "error"],
  setup(props, { slots, emit }) {
    const naturalRatio = ref(props.initialRatio);
    const ratioStyle = useRatio(props, naturalRatio);
    let loadTimer;
    const images = [
      ref(null),
      ref(getPlaceholderSrc())
    ];
    const position2 = ref(0);
    const isLoading = ref(false);
    const hasError = ref(false);
    const classes = computed(
      () => `q-img q-img--${props.noNativeMenu === true ? "no-" : ""}menu`
    );
    const style = computed(() => ({
      width: props.width,
      height: props.height
    }));
    const imgClass = computed(
      () => `q-img__image ${props.imgClass !== void 0 ? props.imgClass + " " : ""}q-img__image--with${props.noTransition === true ? "out" : ""}-transition`
    );
    const imgStyle = computed(() => ({
      ...props.imgStyle,
      objectFit: props.fit,
      objectPosition: props.position
    }));
    watch(() => getCurrentSrc(), addImage);
    function getCurrentSrc() {
      return props.src || props.srcset || props.sizes ? {
        src: props.src,
        srcset: props.srcset,
        sizes: props.sizes
      } : null;
    }
    function getPlaceholderSrc() {
      return props.placeholderSrc !== void 0 ? { src: props.placeholderSrc } : null;
    }
    function addImage(imgProps) {
      clearTimeout(loadTimer);
      hasError.value = false;
      if (imgProps === null) {
        isLoading.value = false;
        images[position2.value ^ 1].value = getPlaceholderSrc();
      } else {
        isLoading.value = true;
      }
      images[position2.value].value = imgProps;
    }
    function onLoad({ target: target2 }) {
      if (loadTimer === null) {
        return;
      }
      clearTimeout(loadTimer);
      naturalRatio.value = target2.naturalHeight === 0 ? 0.5 : target2.naturalWidth / target2.naturalHeight;
      waitForCompleteness(target2, 1);
    }
    function waitForCompleteness(target2, count) {
      if (loadTimer === null || count === 1e3) {
        return;
      }
      if (target2.complete === true) {
        onReady(target2);
      } else {
        loadTimer = setTimeout(() => {
          waitForCompleteness(target2, count + 1);
        }, 50);
      }
    }
    function onReady(img) {
      if (loadTimer === null) {
        return;
      }
      position2.value = position2.value ^ 1;
      images[position2.value].value = null;
      isLoading.value = false;
      hasError.value = false;
      emit("load", img.currentSrc || img.src);
    }
    function onError(err) {
      clearTimeout(loadTimer);
      isLoading.value = false;
      hasError.value = true;
      images[position2.value].value = null;
      images[position2.value ^ 1].value = getPlaceholderSrc();
      emit("error", err);
    }
    function getImage(index2) {
      const img = images[index2].value;
      const data = {
        key: "img_" + index2,
        class: imgClass.value,
        style: imgStyle.value,
        crossorigin: props.crossorigin,
        decoding: props.decoding,
        referrerpolicy: props.referrerpolicy,
        height: props.height,
        width: props.width,
        loading: props.loading,
        fetchpriority: props.fetchpriority,
        "aria-hidden": "true",
        draggable: props.draggable,
        ...img
      };
      if (position2.value === index2) {
        data.class += " q-img__image--waiting";
        Object.assign(data, { onLoad, onError });
      } else {
        data.class += " q-img__image--loaded";
      }
      return h(
        "div",
        { class: "q-img__container absolute-full", key: "img" + index2 },
        h("img", data)
      );
    }
    function getContent() {
      if (isLoading.value !== true) {
        return h("div", {
          key: "content",
          class: "q-img__content absolute-full q-anchor--skip"
        }, hSlot(slots[hasError.value === true ? "error" : "default"]));
      }
      return h("div", {
        key: "loading",
        class: "q-img__loading absolute-full flex flex-center"
      }, slots.loading !== void 0 ? slots.loading() : props.noSpinner === true ? void 0 : [
        h(QSpinner, {
          color: props.spinnerColor,
          size: props.spinnerSize
        })
      ]);
    }
    {
      {
        addImage(getCurrentSrc());
      }
      onBeforeUnmount(() => {
        clearTimeout(loadTimer);
        loadTimer = null;
      });
    }
    return () => {
      const content = [];
      if (ratioStyle.value !== null) {
        content.push(
          h("div", { key: "filler", style: ratioStyle.value })
        );
      }
      if (hasError.value !== true) {
        if (images[0].value !== null) {
          content.push(getImage(0));
        }
        if (images[1].value !== null) {
          content.push(getImage(1));
        }
      }
      content.push(
        h(Transition, { name: "q-transition--fade" }, getContent)
      );
      return h("div", {
        class: classes.value,
        style: style.value,
        role: "img",
        "aria-label": props.alt
      }, content);
    };
  }
});
const QTooltip = createComponent({
  name: "QTooltip",
  inheritAttrs: false,
  props: {
    ...useAnchorProps,
    ...useModelToggleProps,
    ...useTransitionProps,
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    },
    transitionShow: {
      default: "jump-down"
    },
    transitionHide: {
      default: "jump-up"
    },
    anchor: {
      type: String,
      default: "bottom middle",
      validator: validatePosition
    },
    self: {
      type: String,
      default: "top middle",
      validator: validatePosition
    },
    offset: {
      type: Array,
      default: () => [14, 14],
      validator: validateOffset
    },
    scrollTarget: {
      default: void 0
    },
    delay: {
      type: Number,
      default: 0
    },
    hideDelay: {
      type: Number,
      default: 0
    }
  },
  emits: [
    ...useModelToggleEmits
  ],
  setup(props, { slots, emit, attrs }) {
    let unwatchPosition, observer;
    const vm = getCurrentInstance();
    const { proxy: { $q } } = vm;
    const innerRef = ref(null);
    const showing = ref(false);
    const anchorOrigin = computed(() => parsePosition(props.anchor, $q.lang.rtl));
    const selfOrigin = computed(() => parsePosition(props.self, $q.lang.rtl));
    const hideOnRouteChange = computed(() => props.persistent !== true);
    const { registerTick, removeTick } = useTick();
    const { registerTimeout } = useTimeout();
    const { transitionProps, transitionStyle } = useTransition(props);
    const { localScrollTarget, changeScrollEvent, unconfigureScrollTarget } = useScrollTarget(props, configureScrollTarget);
    const { anchorEl, canShow, anchorEvents } = useAnchor({ showing, configureAnchorEl });
    const { show, hide } = useModelToggle({
      showing,
      canShow,
      handleShow,
      handleHide,
      hideOnRouteChange,
      processOnMount: true
    });
    Object.assign(anchorEvents, { delayShow, delayHide });
    const { showPortal, hidePortal, renderPortal } = usePortal(vm, innerRef, renderPortalContent);
    if ($q.platform.is.mobile === true) {
      const clickOutsideProps = {
        anchorEl,
        innerRef,
        onClickOutside(e) {
          hide(e);
          if (e.target.classList.contains("q-dialog__backdrop")) {
            stopAndPrevent(e);
          }
          return true;
        }
      };
      const hasClickOutside = computed(
        () => props.modelValue === null && props.persistent !== true && showing.value === true
      );
      watch(hasClickOutside, (val) => {
        const fn = val === true ? addClickOutside : removeClickOutside;
        fn(clickOutsideProps);
      });
      onBeforeUnmount(() => {
        removeClickOutside(clickOutsideProps);
      });
    }
    function handleShow(evt) {
      showPortal();
      registerTick(() => {
        observer = new MutationObserver(() => updatePosition());
        observer.observe(innerRef.value, { attributes: false, childList: true, characterData: true, subtree: true });
        updatePosition();
        configureScrollTarget();
      });
      if (unwatchPosition === void 0) {
        unwatchPosition = watch(
          () => $q.screen.width + "|" + $q.screen.height + "|" + props.self + "|" + props.anchor + "|" + $q.lang.rtl,
          updatePosition
        );
      }
      registerTimeout(() => {
        showPortal(true);
        emit("show", evt);
      }, props.transitionDuration);
    }
    function handleHide(evt) {
      removeTick();
      hidePortal();
      anchorCleanup();
      registerTimeout(() => {
        hidePortal(true);
        emit("hide", evt);
      }, props.transitionDuration);
    }
    function anchorCleanup() {
      if (observer !== void 0) {
        observer.disconnect();
        observer = void 0;
      }
      if (unwatchPosition !== void 0) {
        unwatchPosition();
        unwatchPosition = void 0;
      }
      unconfigureScrollTarget();
      cleanEvt(anchorEvents, "tooltipTemp");
    }
    function updatePosition() {
      const el = innerRef.value;
      if (anchorEl.value === null || !el) {
        return;
      }
      setPosition({
        el,
        offset: props.offset,
        anchorEl: anchorEl.value,
        anchorOrigin: anchorOrigin.value,
        selfOrigin: selfOrigin.value,
        maxHeight: props.maxHeight,
        maxWidth: props.maxWidth
      });
    }
    function delayShow(evt) {
      if ($q.platform.is.mobile === true) {
        clearSelection();
        document.body.classList.add("non-selectable");
        const target2 = anchorEl.value;
        const evts = ["touchmove", "touchcancel", "touchend", "click"].map((e) => [target2, e, "delayHide", "passiveCapture"]);
        addEvt(anchorEvents, "tooltipTemp", evts);
      }
      registerTimeout(() => {
        show(evt);
      }, props.delay);
    }
    function delayHide(evt) {
      if ($q.platform.is.mobile === true) {
        cleanEvt(anchorEvents, "tooltipTemp");
        clearSelection();
        setTimeout(() => {
          document.body.classList.remove("non-selectable");
        }, 10);
      }
      registerTimeout(() => {
        hide(evt);
      }, props.hideDelay);
    }
    function configureAnchorEl() {
      if (props.noParentEvent === true || anchorEl.value === null) {
        return;
      }
      const evts = $q.platform.is.mobile === true ? [
        [anchorEl.value, "touchstart", "delayShow", "passive"]
      ] : [
        [anchorEl.value, "mouseenter", "delayShow", "passive"],
        [anchorEl.value, "mouseleave", "delayHide", "passive"]
      ];
      addEvt(anchorEvents, "anchor", evts);
    }
    function configureScrollTarget() {
      if (anchorEl.value !== null || props.scrollTarget !== void 0) {
        localScrollTarget.value = getScrollTarget(anchorEl.value, props.scrollTarget);
        const fn = props.noParentEvent === true ? updatePosition : hide;
        changeScrollEvent(localScrollTarget.value, fn);
      }
    }
    function getTooltipContent() {
      return showing.value === true ? h("div", {
        ...attrs,
        ref: innerRef,
        class: [
          "q-tooltip q-tooltip--style q-position-engine no-pointer-events",
          attrs.class
        ],
        style: [
          attrs.style,
          transitionStyle.value
        ],
        role: "tooltip"
      }, hSlot(slots.default)) : null;
    }
    function renderPortalContent() {
      return h(Transition, transitionProps.value, getTooltipContent);
    }
    onBeforeUnmount(anchorCleanup);
    Object.assign(vm.proxy, { updatePosition });
    return renderPortal;
  }
});
const _withScopeId = (n) => (pushScopeId("data-v-3428dc69"), n = n(), popScopeId(), n);
const _hoisted_1$3 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "q-focus-helper" }, null, -1));
const _hoisted_2$1 = {
  class: "full-width",
  style: { "padding": "0" }
};
const _hoisted_3$1 = {
  class: "text-center ellipsis-2-lines",
  style: { "max-height": "42px", "height": "42px" }
};
const _hoisted_4 = { class: "text-center text-weight-bold ellipsis" };
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "IdentifyCard",
  props: {
    item: {
      type: Object,
      required: true
    },
    selected: {
      type: Boolean,
      required: true
    },
    width: {
      type: [String],
      required: false,
      default: "160px"
    }
  },
  emits: ["on-select-result"],
  setup(__props, { emit }) {
    const props = __props;
    useCssVars((_ctx) => ({
      "cbfd8272": __props.width
    }));
    const providerName = computed(() => {
      return props.item.provider.toLowerCase().split("_").map((token) => token.charAt(0).toUpperCase() + token.slice(1)).join(" ");
    });
    function onClick() {
      emit("on-select-result", props.item);
    }
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createBlock(QCard, {
        onClick,
        class: normalizeClass(`${__props.selected ? "item-border" : ""} identify-card cursor-pointer q-hoverable`)
      }, {
        default: withCtx(() => [
          _hoisted_1$3,
          createVNode(QCardSection, {
            horizontal: "",
            class: "card-border"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_2$1, [
                createVNode(QImg, {
                  src: __props.item.imageUrl,
                  ratio: "0.7071",
                  referrerpolicy: "no-referrer"
                }, null, 8, ["src"]),
                createVNode(QCardSection, { class: "full-width" }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_3$1, [
                      createTextVNode(toDisplayString(__props.item.title) + " ", 1),
                      createVNode(QTooltip, { delay: 500 }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(__props.item.title), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    createBaseVNode("div", _hoisted_4, toDisplayString(unref(providerName)), 1)
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["class"])), [
        [Ripple]
      ]);
    };
  }
});
const IdentifyCard_vue_vue_type_style_index_0_scoped_3428dc69_lang = "";
const IdentifyCard = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-3428dc69"]]);
const _hoisted_1$2 = { class: "text-h6 gt-xs q-pb-lg" };
const _hoisted_2 = { class: "col" };
const _hoisted_3 = { class: "row" };
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "IdentifySeriesDialog",
  props: {
    seriesTitle: {
      type: String
    }
  },
  emits: [
    ...useDialogPluginComponent.emits
  ],
  setup(__props) {
    var _a2;
    const props = __props;
    const { dialogRef, onDialogHide, onDialogOK, onDialogCancel } = useDialogPluginComponent();
    const metadataService = inject(
      komfMetadataKey
    );
    const $q = useQuasar();
    const settings = useSettingsStore();
    const search = ref(true);
    const results = ref(false);
    const loading = ref(false);
    const selected = ref(false);
    const form = reactive({ title: (_a2 = props.seriesTitle) != null ? _a2 : "", edition: "" });
    const edition = ref("");
    const searchResults = ref();
    const selectedResult = ref({});
    const seriesId = computed(() => {
      let path = window.location.pathname.split("/");
      return path[path.findIndex((el) => el == "series") + 1];
    });
    const libraryId = computed(() => {
      var _a3, _b, _c;
      if (settings.mediaServer == MediaServer.Komga) {
        return (_c = Array.from((_b = (_a3 = document.querySelector(".v-main__wrap .v-toolbar__content")) == null ? void 0 : _a3.children) != null ? _b : []).find((el) => {
          let link = el.getAttribute("href");
          if (!link)
            return false;
          return /\/libraries.*/.test(link);
        })) == null ? void 0 : _c.getAttribute("href").split("/")[2];
      } else {
        let pathTokens = window.location.pathname.split("/");
        if (pathTokens[1] == "library") {
          return pathTokens[2];
        } else {
          return void 0;
        }
      }
    });
    async function dialogConfirm() {
      loading.value = true;
      await editMetadata();
      onDialogOK();
    }
    async function searchSeries() {
      loading.value = true;
      try {
        searchResults.value = await metadataService.searchSeries(form.title, libraryId.value, seriesId.value);
      } catch (e) {
        errorNotification(e, $q);
        onDialogCancel();
        return;
      }
      results.value = true;
      search.value = false;
      loading.value = false;
      edition.value = form.edition;
    }
    async function editMetadata() {
      if (seriesId.value) {
        const request = {
          libraryId: libraryId.value,
          seriesId: seriesId.value,
          provider: selectedResult.value.provider,
          providerSeriesId: selectedResult.value.resultId,
          edition: edition.value == "" ? void 0 : edition.value
        };
        try {
          await metadataService.identifySeries(request);
        } catch (e) {
          errorNotification(e, $q);
          onDialogCancel();
          return;
        }
      }
    }
    function selectResult(searchResult) {
      selectedResult.value = searchResult;
      selected.value = true;
    }
    function isResultSelected(item) {
      return selectedResult.value === item;
    }
    function handleEnterKeyPress() {
      if (search.value && !loading.value && form.title) {
        searchSeries();
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(QDialog, {
        ref_key: "dialogRef",
        ref: dialogRef,
        onHide: unref(onDialogHide),
        persistent: loading.value,
        onKeyup: withKeys(handleEnterKeyPress, ["enter"])
      }, {
        default: withCtx(() => [
          createVNode(QCard, {
            class: "q-dialog-plugin",
            style: { "max-width": "820px", "width": "820px" }
          }, {
            default: withCtx(() => [
              createVNode(QCardSection, null, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_1$2, [
                    createVNode(QIcon, {
                      name: unref(settings).mediaServer === unref(MediaServer).Komga ? "mdi-pencil" : "fa fa-pen"
                    }, null, 8, ["name"]),
                    createTextVNode(" Identify ")
                  ]),
                  search.value ? (openBlock(), createBlock(QCard, {
                    key: 0,
                    flat: ""
                  }, {
                    default: withCtx(() => [
                      createVNode(QToolbar, {
                        class: "lt-sm",
                        id: "identify_toolbar"
                      }, {
                        default: withCtx(() => [
                          createVNode(QBtn, {
                            flat: "",
                            icon: "mdi-close",
                            onClick: unref(onDialogCancel)
                          }, null, 8, ["onClick"]),
                          createVNode(QToolbarTitle, null, {
                            default: withCtx(() => [
                              createTextVNode("Identify")
                            ]),
                            _: 1
                          }),
                          createVNode(QSpace),
                          createVNode(QBtn, {
                            color: "secondary",
                            loading: loading.value,
                            disable: loading.value || form.title === "",
                            onClick: searchSeries
                          }, {
                            default: withCtx(() => [
                              createTextVNode(" Search ")
                            ]),
                            _: 1
                          }, 8, ["loading", "disable"])
                        ]),
                        _: 1
                      }),
                      createBaseVNode("div", _hoisted_2, [
                        createVNode(QInput, {
                          class: "q-pt-sm q-pb-sm",
                          modelValue: form.title,
                          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => form.title = $event),
                          label: "title",
                          filled: ""
                        }, null, 8, ["modelValue"]),
                        createVNode(QInput, {
                          class: "q-pt-sm q-pb-sm",
                          modelValue: form.edition,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => form.edition = $event),
                          label: "edition",
                          filled: ""
                        }, null, 8, ["modelValue"])
                      ]),
                      createVNode(QCardActions, {
                        align: "right",
                        class: "gt-xs q-pt-lg q-pb-sm"
                      }, {
                        default: withCtx(() => [
                          createVNode(QBtn, {
                            disable: loading.value,
                            onClick: unref(onDialogCancel)
                          }, {
                            default: withCtx(() => [
                              createTextVNode("Cancel")
                            ]),
                            _: 1
                          }, 8, ["disable", "onClick"]),
                          createVNode(QBtn, {
                            loading: loading.value,
                            disable: loading.value || form.title === "",
                            color: "secondary",
                            onClick: searchSeries
                          }, {
                            default: withCtx(() => [
                              createTextVNode(" Search ")
                            ]),
                            _: 1
                          }, 8, ["loading", "disable"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })) : createCommentVNode("", true),
                  results.value ? (openBlock(), createBlock(QCard, {
                    key: 1,
                    flat: ""
                  }, {
                    default: withCtx(() => [
                      createVNode(QToolbar, { class: "lt-sm" }, {
                        default: withCtx(() => [
                          createVNode(QBtn, {
                            flat: "",
                            icon: "mdi-close",
                            onClick: unref(onDialogCancel)
                          }, null, 8, ["onClick"]),
                          createVNode(QToolbarTitle, null, {
                            default: withCtx(() => [
                              createTextVNode("Identify")
                            ]),
                            _: 1
                          }),
                          createVNode(QSpace),
                          createVNode(QBtn, {
                            color: "secondary",
                            disable: !selected.value,
                            onClick: dialogConfirm
                          }, {
                            default: withCtx(() => [
                              createTextVNode("Confirm")
                            ]),
                            _: 1
                          }, 8, ["disable"])
                        ]),
                        _: 1
                      }),
                      createBaseVNode("div", _hoisted_3, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(searchResults.value, (item, index2) => {
                          return openBlock(), createElementBlock("div", {
                            class: "col-auto",
                            style: { "padding": "16px 16px 16px 16px" },
                            key: index2
                          }, [
                            createVNode(IdentifyCard, {
                              item,
                              selected: isResultSelected(item),
                              onOnSelectResult: selectResult
                            }, null, 8, ["item", "selected"])
                          ]);
                        }), 128))
                      ]),
                      results.value ? (openBlock(), createBlock(QCardActions, {
                        key: 0,
                        align: "right",
                        class: "gt-xs q-pt-lg q-pb-sm"
                      }, {
                        default: withCtx(() => [
                          createVNode(QBtn, {
                            flat: "",
                            disable: loading.value,
                            onClick: unref(onDialogCancel)
                          }, {
                            default: withCtx(() => [
                              createTextVNode("Cancel")
                            ]),
                            _: 1
                          }, 8, ["disable", "onClick"]),
                          createVNode(QBtn, {
                            color: "secondary",
                            disable: !selected.value || loading.value,
                            loading: loading.value,
                            onClick: dialogConfirm
                          }, {
                            default: withCtx(() => [
                              createTextVNode("Confirm ")
                            ]),
                            _: 1
                          }, 8, ["disable", "loading"])
                        ]),
                        _: 1
                      })) : createCommentVNode("", true)
                    ]),
                    _: 1
                  })) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["onHide", "persistent", "onKeyup"]);
    };
  }
});
const IdentifySeriesDialog_vue_vue_type_style_index_0_scoped_7f445e97_lang = "";
const IdentifySeriesDialog = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-7f445e97"]]);
const _hoisted_1$1 = {
  class: "q-pa-md flex flex-center",
  style: { "background-color": "rgba(89, 89, 89, 0.5)" }
};
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "SeriesActionsMenu",
  setup(__props) {
    const $q = useQuasar();
    const metadataService = inject(komfMetadataKey);
    const settings = useSettingsStore();
    const loading = ref(false);
    function seriesTitle() {
      if (settings.mediaServer == MediaServer.Komga)
        return document.querySelector(".v-main__wrap .v-toolbar__content .v-toolbar__title span").innerText;
      else
        return document.querySelector("app-series-detail app-side-nav-companion-bar div h2 span").innerText;
    }
    function seriesId() {
      let path = window.location.pathname.split("/");
      return path[path.findIndex((el) => el == "series") + 1];
    }
    function libraryId() {
      var _a2, _b;
      if (settings.mediaServer == MediaServer.Komga) {
        return Array.from((_b = (_a2 = document.querySelector(".v-main__wrap .v-toolbar__content")) == null ? void 0 : _a2.children) != null ? _b : []).find((el) => {
          let link = el.getAttribute("href");
          if (!link)
            return false;
          return /\/libraries.*/.test(link);
        }).getAttribute("href").split("/")[2];
      } else {
        let pathTokens = window.location.pathname.split("/");
        return pathTokens[pathTokens.findIndex((el) => el == "library") + 1];
      }
    }
    function promptIdentifySeries() {
      $q.dialog({
        component: IdentifySeriesDialog,
        componentProps: {
          seriesTitle: seriesTitle()
        }
      });
    }
    function promptResetSeries() {
      $q.dialog({
        component: ConfirmationDialog,
        componentProps: {
          title: "Reset Series",
          bodyHtml: "All series metadata will be reset including field locks and thumbnails uploaded by Komf. No files will be modified. Continue?",
          confirmText: "Yes, reset series",
          buttonConfirm: "Reset",
          buttonConfirmColor: "negative"
        }
      }).onOk(() => {
        resetSeries();
      });
    }
    async function resetSeries() {
      try {
        await (metadataService == null ? void 0 : metadataService.resetSeries(libraryId(), seriesId()));
      } catch (e) {
        errorNotification(e, $q);
      }
    }
    async function autoIdentify() {
      loading.value = true;
      try {
        await metadataService.matchSeries(libraryId(), seriesId());
      } catch (e) {
        errorNotification(e, $q);
      }
      loading.value = false;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(QMenu, { class: "text-body2 text-weight-medium" }, {
          default: withCtx(() => [
            withDirectives((openBlock(), createBlock(QItem, {
              clickable: "",
              onClick: promptIdentifySeries
            }, {
              default: withCtx(() => [
                createVNode(QItemSection, { "no-wrap": "" }, {
                  default: withCtx(() => [
                    createTextVNode("Identify")
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })), [
              [ClosePopup]
            ]),
            withDirectives((openBlock(), createBlock(QItem, {
              clickable: "",
              onClick: autoIdentify
            }, {
              default: withCtx(() => [
                createVNode(QItemSection, { "no-wrap": "" }, {
                  default: withCtx(() => [
                    createTextVNode("Auto-Identify")
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })), [
              [ClosePopup]
            ]),
            withDirectives((openBlock(), createBlock(QItem, {
              clickable: "",
              onClick: promptResetSeries
            }, {
              default: withCtx(() => [
                createVNode(QItemSection, { "no-wrap": "" }, {
                  default: withCtx(() => [
                    createTextVNode("Reset Metadata")
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })), [
              [ClosePopup]
            ])
          ]),
          _: 1
        }),
        createVNode(QDialog, {
          modelValue: loading.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => loading.value = $event),
          maximized: "",
          "transition-duration": "0"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_1$1, [
              createVNode(QCircularProgress, {
                indeterminate: "",
                rounded: "",
                size: "50px",
                color: "lime",
                class: "q-ma-md"
              })
            ])
          ]),
          _: 1
        }, 8, ["modelValue"])
      ], 64);
    };
  }
});
const SeriesActionsMenu_vue_vue_type_style_index_0_scoped_9f33b495_lang = "";
const SeriesActionsMenu = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-9f33b495"]]);
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "KomgaSeriesActions",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(QBtn, {
        icon: "mdi-book-edit",
        flat: "",
        rounded: "",
        padding: "0.85em"
      }, {
        default: withCtx(() => [
          createVNode(SeriesActionsMenu)
        ]),
        _: 1
      });
    };
  }
});
const KomgaSeriesActions_vue_vue_type_style_index_0_scoped_e95f9e5e_lang = "";
const KomgaSeriesActions = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-e95f9e5e"]]);
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "LibraryActionsMenu",
  setup(__props) {
    const $q = useQuasar();
    const metadataService = inject(komfMetadataKey);
    const settings = useSettingsStore();
    function libraryId() {
      let pathTokens = window.location.pathname.split("/");
      if (settings.mediaServer == MediaServer.Komga) {
        return pathTokens[pathTokens.findIndex((el) => el == "libraries") + 1];
      } else {
        return pathTokens[pathTokens.findIndex((el) => el == "library") + 1];
      }
    }
    async function autoIdentify() {
      try {
        await metadataService.matchLibrary(libraryId());
      } catch (e) {
        errorNotification(e, $q);
        return;
      }
      $q.notify({
        message: "Launched library scan",
        color: "secondary",
        closeBtn: true,
        timeout: 5e3
      });
    }
    function promptResetLibrary() {
      $q.dialog({
        component: ConfirmationDialog,
        componentProps: {
          title: "Reset Library",
          bodyHtml: "All metadata of all series inside this library  will be reset including field locks and thumbnails uploaded by Komf. No files will be modified. Continue?",
          confirmText: "Yes, reset library",
          buttonConfirm: "Reset",
          buttonConfirmColor: "negative"
        }
      }).onOk(() => {
        resetLibrary();
      });
    }
    async function resetLibrary() {
      try {
        await (metadataService == null ? void 0 : metadataService.resetLibrary(libraryId()));
      } catch (e) {
        errorNotification(e, $q);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(QMenu, { class: "text-body2 text-weight-medium" }, {
        default: withCtx(() => [
          withDirectives((openBlock(), createBlock(QItem, {
            clickable: "",
            onClick: autoIdentify
          }, {
            default: withCtx(() => [
              createVNode(QItemSection, {
                class: "text-body2 text-weight-medium",
                "no-wrap": ""
              }, {
                default: withCtx(() => [
                  createTextVNode("Auto-Identify Library")
                ]),
                _: 1
              })
            ]),
            _: 1
          })), [
            [ClosePopup]
          ]),
          withDirectives((openBlock(), createBlock(QItem, {
            clickable: "",
            onClick: promptResetLibrary
          }, {
            default: withCtx(() => [
              createVNode(QItemSection, {
                class: "text-body2 text-weight-medium",
                "no-wrap": ""
              }, {
                default: withCtx(() => [
                  createTextVNode("Reset Metadata")
                ]),
                _: 1
              })
            ]),
            _: 1
          })), [
            [ClosePopup]
          ])
        ]),
        _: 1
      });
    };
  }
});
const LibraryActionsMenu_vue_vue_type_style_index_0_scoped_2de3bff8_lang = "";
const LibraryActionsMenu = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-2de3bff8"]]);
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "KomgaLibraryActions",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(QBtn, {
        icon: "mdi-folder-edit",
        flat: "",
        rounded: "",
        padding: "0.85em"
      }, {
        default: withCtx(() => [
          createVNode(LibraryActionsMenu)
        ]),
        _: 1
      });
    };
  }
});
const KomgaLibraryActions_vue_vue_type_style_index_0_scoped_d80e76e9_lang = "";
const KomgaLibraryActions = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-d80e76e9"]]);
const _hoisted_1 = /* @__PURE__ */ createBaseVNode("div", { style: { "margin-left": "30px" } }, "Komf Settings", -1);
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "KomgaView",
  setup(__props) {
    const $q = useQuasar();
    const menuElement = ref(document.createElement("div"));
    const libraryActionsElement = ref(document.createElement("div"));
    const seriesActionsElement = ref(document.createElement("div"));
    let theme;
    let storage = localStorage.getItem("vuex");
    if (storage) {
      let state = JSON.parse(storage);
      if ("persistedState" in state) {
        theme = state.persistedState.theme;
      }
    }
    if (theme) {
      switch (theme) {
        case Theme.DARK:
          $q.dark.set(true);
          break;
        case Theme.SYSTEM:
          if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches)
            $q.dark.set(true);
          else
            $q.dark.set(false);
          break;
        default:
          $q.dark.set(false);
          break;
      }
    }
    function settingsDialog() {
      $q.dialog({
        component: SettingsDialog
      });
    }
    const observer = new window.MutationObserver((mutations) => {
      var _a2;
      for (const { addedNodes, removedNodes } of mutations) {
        if (!addedNodes || !removedNodes || addedNodes.length === 0 && removedNodes.length === 0) {
          continue;
        }
        for (const node of addedNodes) {
          if (node.nodeName != "DIV" || node.childNodes.length == 0) {
            continue;
          }
          let drawer_content = Array.from(node.getElementsByClassName("v-navigation-drawer__content"));
          let menus = (_a2 = drawer_content.find((node2) => {
            var _a3;
            return ((_a3 = node2.parentElement) == null ? void 0 : _a3.tagName) == "NAV";
          })) == null ? void 0 : _a2.children.item(2);
          if (menus) {
            menus.insertBefore(menuElement.value, menus.children[menus.children.length - 1]);
          }
          let toolbar = node.querySelector(".v-main__wrap .v-toolbar__content");
          if (toolbar && toolbar.parentElement && !toolbar.parentElement.classList.contains("hidden-sm-and-up")) {
            const path_split = window.location.pathname.split("/").reverse();
            if (path_split.find((el) => el == "libraries")) {
              toolbar == null ? void 0 : toolbar.children[4].insertAdjacentElement("afterend", libraryActionsElement.value);
            } else if (path_split.find((el) => el == "series")) {
              toolbar == null ? void 0 : toolbar.children[4].insertAdjacentElement("afterend", seriesActionsElement.value);
            }
          }
        }
      }
    });
    observer.observe(document, { childList: true, subtree: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        (openBlock(), createBlock(Teleport, { to: menuElement.value }, [
          createVNode(QBtn, {
            flat: "",
            "no-caps": "",
            align: "left",
            class: "text-body1 transparent full-width",
            icon: "mdi-puzzle",
            onClick: settingsDialog
          }, {
            default: withCtx(() => [
              _hoisted_1
            ]),
            _: 1
          })
        ], 8, ["to"])),
        (openBlock(), createBlock(Teleport, { to: libraryActionsElement.value }, [
          createVNode(KomgaLibraryActions)
        ], 8, ["to"])),
        (openBlock(), createBlock(Teleport, { to: seriesActionsElement.value }, [
          createVNode(KomgaSeriesActions)
        ], 8, ["to"]))
      ], 64);
    };
  }
});
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "KavitaSeriesActionsMenu",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(QBtn, {
        icon: "fa fa-pen-to-square",
        flat: "",
        padding: ".375rem .75rem",
        style: { "background": "#6c757d", "border-radius": "15%" }
      }, {
        default: withCtx(() => [
          createVNode(SeriesActionsMenu)
        ]),
        _: 1
      });
    };
  }
});
const KavitaSeriesActionsMenu_vue_vue_type_style_index_0_scoped_5c09e4ef_lang = "";
const KavitaSeriesActionsMenu = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-5c09e4ef"]]);
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "KavitaLibraryActions",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(QBtn, {
        icon: "fa fa-pen-to-square",
        flat: "",
        padding: "0.55em 0 0.55em 0",
        class: "q-ml-sm",
        style: { "background": "#6c757d", "border-radius": "10%" }
      }, {
        default: withCtx(() => [
          createVNode(LibraryActionsMenu)
        ]),
        _: 1
      });
    };
  }
});
const KavitaLibraryActions_vue_vue_type_style_index_0_scoped_2d61344c_lang = "";
const KavitaLibraryActions = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-2d61344c"]]);
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "KavitaView",
  setup(__props) {
    const $q = useQuasar();
    $q.dark.set(true);
    ref(false);
    ref(false);
    const settingsElement = ref(document.createElement("div"));
    const libraryActionsElement = ref(document.createElement("div"));
    libraryActionsElement.value.setAttribute("class", "col-auto");
    const seriesActionsElement = ref(document.createElement("div"));
    seriesActionsElement.value.setAttribute("class", "col-auto ms-2");
    function settingsDialog() {
      $q.dialog({
        component: SettingsDialog
      });
    }
    const observer = new window.MutationObserver(
      (mutations) => {
        var _a2, _b;
        for (const { addedNodes } of mutations) {
          if (!addedNodes || addedNodes.length === 0) {
            continue;
          }
          for (const node of addedNodes) {
            if (node.nodeType != Node.ELEMENT_NODE || node.children.length == 0) {
              continue;
            }
            const element = node;
            let navBar;
            if (element.nodeName == "APP-NAV-HEADER") {
              navBar = (_a2 = element.firstElementChild) == null ? void 0 : _a2.firstElementChild;
            } else if (element.nodeName == "NAV") {
              navBar = element.firstElementChild;
            }
            if (navBar) {
              navBar.insertBefore(settingsElement.value, navBar.children[4]);
            }
            let buttons = Array.from(element.getElementsByTagName("button"));
            let editSeriesButton = buttons.find((elem) => elem.getAttribute("id") == "edit-btn--komf");
            if (editSeriesButton) {
              (_b = editSeriesButton.parentElement) == null ? void 0 : _b.insertAdjacentElement("afterend", seriesActionsElement.value);
            }
            let libraryFilterButton = buttons.find((elem) => elem.getAttribute("id") == "filter-btn--komf");
            if (libraryFilterButton && libraryFilterButton.parentElement) {
              libraryActionsElement.value = libraryFilterButton.parentElement;
            }
          }
        }
      }
    );
    observer.observe(document, { childList: true, subtree: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        (openBlock(), createBlock(Teleport, { to: settingsElement.value }, [
          createVNode(QBtn, {
            flat: "",
            "no-caps": "",
            align: "left",
            outline: "",
            size: "14px",
            class: "text-body1 transparent full-width settings-button",
            icon: "fa fa-puzzle-piece",
            onClick: settingsDialog
          })
        ], 8, ["to"])),
        (openBlock(), createBlock(Teleport, { to: libraryActionsElement.value }, [
          createVNode(KavitaLibraryActions)
        ], 8, ["to"])),
        (openBlock(), createBlock(Teleport, { to: seriesActionsElement.value }, [
          createVNode(KavitaSeriesActionsMenu)
        ], 8, ["to"]))
      ], 64);
    };
  }
});
const KavitaView_vue_vue_type_style_index_0_scoped_2c371c7b_lang = "";
const KavitaView = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-2c371c7b"]]);
var mdiV6 = {
  name: "mdi-v6",
  type: {
    positive: "mdi-check-circle",
    negative: "mdi-alert",
    info: "mdi-information",
    warning: "mdi-exclamation"
  },
  arrow: {
    up: "mdi-arrow-up",
    right: "mdi-arrow-right",
    down: "mdi-arrow-down",
    left: "mdi-arrow-left",
    dropdown: "mdi-menu-down"
  },
  chevron: {
    left: "mdi-chevron-left",
    right: "mdi-chevron-right"
  },
  colorPicker: {
    spectrum: "mdi-gradient-vertical",
    tune: "mdi-tune",
    palette: "mdi-palette-swatch"
  },
  pullToRefresh: {
    icon: "mdi-refresh"
  },
  carousel: {
    left: "mdi-chevron-left",
    right: "mdi-chevron-right",
    up: "mdi-chevron-up",
    down: "mdi-chevron-down",
    navigationIcon: "mdi-circle"
  },
  chip: {
    remove: "mdi-close-circle",
    selected: "mdi-check"
  },
  datetime: {
    arrowLeft: "mdi-chevron-left",
    arrowRight: "mdi-chevron-right",
    now: "mdi-clock-outline",
    today: "mdi-calendar-today"
  },
  editor: {
    bold: "mdi-format-bold",
    italic: "mdi-format-italic",
    strikethrough: "mdi-format-strikethrough-variant",
    underline: "mdi-format-underline",
    unorderedList: "mdi-format-list-bulleted",
    orderedList: "mdi-format-list-numbered",
    subscript: "mdi-format-subscript",
    superscript: "mdi-format-superscript",
    hyperlink: "mdi-link",
    toggleFullscreen: "mdi-fullscreen",
    quote: "mdi-format-quote-close",
    left: "mdi-format-align-left",
    center: "mdi-format-align-center",
    right: "mdi-format-align-right",
    justify: "mdi-format-align-justify",
    print: "mdi-printer",
    outdent: "mdi-format-indent-decrease",
    indent: "mdi-format-indent-increase",
    removeFormat: "mdi-format-clear",
    formatting: "mdi-format-color-text",
    fontSize: "mdi-format-size",
    align: "mdi-format-align-left",
    hr: "mdi-minus",
    undo: "mdi-undo",
    redo: "mdi-redo",
    heading: "mdi-format-size",
    heading1: "mdi-format-header-1",
    heading2: "mdi-format-header-2",
    heading3: "mdi-format-header-3",
    heading4: "mdi-format-header-4",
    heading5: "mdi-format-header-5",
    heading6: "mdi-format-header-6",
    code: "mdi-code-tags",
    size: "mdi-format-size",
    size1: "mdi-numeric-1-box",
    size2: "mdi-numeric-2-box",
    size3: "mdi-numeric-3-box",
    size4: "mdi-numeric-4-box",
    size5: "mdi-numeric-5-box",
    size6: "mdi-numeric-6-box",
    size7: "mdi-numeric-7-box",
    font: "mdi-format-font",
    viewSource: "mdi-code-tags"
  },
  expansionItem: {
    icon: "mdi-chevron-down",
    denseIcon: "mdi-menu-down"
  },
  fab: {
    icon: "mdi-plus",
    activeIcon: "mdi-close"
  },
  field: {
    clear: "mdi-close-circle",
    error: "mdi-alert-circle"
  },
  pagination: {
    first: "mdi-chevron-double-left",
    prev: "mdi-chevron-left",
    next: "mdi-chevron-right",
    last: "mdi-chevron-double-right"
  },
  rating: {
    icon: "mdi-star"
  },
  stepper: {
    done: "mdi-check",
    active: "mdi-pencil",
    error: "mdi-alert"
  },
  tabs: {
    left: "mdi-chevron-left",
    right: "mdi-chevron-right",
    up: "mdi-chevron-up",
    down: "mdi-chevron-down"
  },
  table: {
    arrowUp: "mdi-arrow-up",
    warning: "mdi-alert",
    firstPage: "mdi-chevron-double-left",
    prevPage: "mdi-chevron-left",
    nextPage: "mdi-chevron-right",
    lastPage: "mdi-chevron-double-right"
  },
  tree: {
    icon: "mdi-play"
  },
  uploader: {
    done: "mdi-check",
    clear: "mdi-close",
    add: "mdi-plus-box",
    upload: "mdi-cloud-upload",
    removeQueue: "mdi-notification-clear-all",
    removeUploaded: "mdi-check-all"
  }
};
var fontawesomeV6 = {
  name: "fontawesome-v6",
  type: {
    positive: "fas fa-check",
    negative: "fas fa-triangle-exclamation",
    info: "fas fa-circle-info",
    warning: "fas fa-exclamation"
  },
  arrow: {
    up: "fas fa-arrow-up",
    right: "fas fa-arrow-right",
    down: "fas fa-arrow-down",
    left: "fas fa-arrow-left",
    dropdown: "fas fa-caret-down"
  },
  chevron: {
    left: "fas fa-chevron-left",
    right: "fas fa-chevron-right"
  },
  colorPicker: {
    spectrum: "fas fa-eye-dropper",
    tune: "fas fa-sliders",
    palette: "fas fa-swatchbook"
  },
  pullToRefresh: {
    icon: "fas fa-rotate"
  },
  carousel: {
    left: "fas fa-chevron-left",
    right: "fas fa-chevron-right",
    up: "fas fa-chevron-up",
    down: "fas fa-chevron-down",
    navigationIcon: "fas fa-circle"
  },
  chip: {
    remove: "fas fa-circle-xmark",
    selected: "fas fa-check"
  },
  datetime: {
    arrowLeft: "fas fa-chevron-left",
    arrowRight: "fas fa-chevron-right",
    now: "far fa-clock",
    today: "far fa-calendar-check"
  },
  editor: {
    bold: "fas fa-bold",
    italic: "fas fa-italic",
    strikethrough: "fas fa-strikethrough",
    underline: "fas fa-underline",
    unorderedList: "fas fa-list-ul",
    orderedList: "fas fa-list-ol",
    subscript: "fas fa-subscript",
    superscript: "fas fa-superscript",
    hyperlink: "fas fa-link",
    toggleFullscreen: "fas fa-maximize",
    quote: "fas fa-quote-right",
    left: "fas fa-align-left",
    center: "fas fa-align-center",
    right: "fas fa-align-right",
    justify: "fas fa-align-justify",
    print: "fas fa-print",
    outdent: "fas fa-outdent",
    indent: "fas fa-indent",
    removeFormat: "fas fa-eraser",
    formatting: "fas fa-heading",
    fontSize: "fas fa-text-height",
    align: "fas fa-align-left",
    hr: "far fa-square-minus",
    undo: "fas fa-rotate-left",
    redo: "fas fa-rotate-right",
    heading: "fas fa-heading",
    code: "fas fa-code",
    size: "fas fa-text-height",
    font: "fas fa-font",
    viewSource: "fas fa-code"
  },
  expansionItem: {
    icon: "fas fa-chevron-down",
    denseIcon: "fas fa-caret-down"
  },
  fab: {
    icon: "fas fa-plus",
    activeIcon: "fas fa-xmark"
  },
  field: {
    clear: "fas fa-circle-xmark",
    error: "fas fa-circle-exclamation"
  },
  pagination: {
    first: "fas fa-backward-step",
    prev: "fas fa-chevron-left",
    next: "fas fa-chevron-right",
    last: "fas fa-forward-step"
  },
  rating: {
    icon: "fas fa-star"
  },
  stepper: {
    done: "fas fa-check",
    active: "fas fa-pencil",
    error: "fas fa-triangle-exclamation"
  },
  tabs: {
    left: "fas fa-chevron-left",
    right: "fas fa-chevron-right",
    up: "fas fa-chevron-up",
    down: "fas fa-chevron-down"
  },
  table: {
    arrowUp: "fas fa-arrow-up",
    warning: "fas fa-triangle-exclamation",
    firstPage: "fas fa-backward-step",
    prevPage: "fas fa-chevron-left",
    nextPage: "fas fa-chevron-right",
    lastPage: "fas fa-forward-step"
  },
  tree: {
    icon: "fas fa-play"
  },
  uploader: {
    done: "fas fa-check",
    clear: "fas fa-xmark",
    add: "fas fa-square-plus",
    upload: "fas fa-upload",
    removeQueue: "fas fa-bars-staggered",
    removeUploaded: "fas fa-clipboard-check"
  }
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const $q = useQuasar();
    const settings = useSettingsStore();
    const title = document.title.split(" ")[0];
    const komga = ref(false);
    const kavita = ref(false);
    if (title == "Komga") {
      komga.value = true;
      settings.mediaServer = MediaServer.Komga;
      $q.iconSet.set(mdiV6);
    } else if (title == "Kavita") {
      kavita.value = true;
      settings.mediaServer = MediaServer.Kavita;
      $q.iconSet.set(fontawesomeV6);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        komga.value ? (openBlock(), createBlock(_sfc_main$4, { key: 0 })) : createCommentVNode("", true),
        kavita.value ? (openBlock(), createBlock(KavitaView, { key: 1 })) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const App_vue_vue_type_style_index_0_scoped_7068b1fc_lang = "";
const App_vue_vue_type_style_index_1_lang = "";
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-7068b1fc"]]);
class KomfConfigService {
  constructor(http2) {
    __publicField(this, "http");
    __publicField(this, "settings", useSettingsStore());
    this.http = http2;
  }
  async getConfig() {
    return this.getConfigFromUrl(this.settings.komfUrl);
  }
  async getConfigFromUrl(url) {
    let config;
    try {
      config = (await this.http.get(`${url}/config`)).data;
    } catch (e) {
      let msg = "Failed to retrieve config";
      if (axios$1.isAxiosError(e)) {
        msg = e.message;
      }
      throw new Error(msg);
    }
    if (typeof config != "object" || !("metadataProviders" in config)) {
      throw new Error("Connection Failed");
    }
    return config;
  }
  async updateConfig(config) {
    try {
      await this.http.patch(`${this.settings.komfUrl}/config`, config);
    } catch (e) {
      let msg = "Failed to retrieve config";
      if (axios$1.isAxiosError(e)) {
        msg = e.message;
      }
      throw new Error(msg);
    }
  }
}
const mountElement = document.createElement("div");
mountElement.id = "komf";
document.body.appendChild(mountElement);
let app = createApp(App);
app.use(Quasar, { plugins: { Notify, Dialog } });
app.use(createPinia());
const http = axios$1.create({ headers: { "X-Requested-With": "XMLHttpRequest" } });
const komfMetadata = new KomfMetadataService(http);
const komfConfig = new KomfConfigService(http);
app.provide(httpKey, http);
app.provide(komfMetadataKey, komfMetadata);
app.provide(komfConfigKey, komfConfig);
app.mount(mountElement);
